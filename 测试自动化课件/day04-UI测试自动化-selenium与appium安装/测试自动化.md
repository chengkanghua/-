# 基本概念

自动化测试，也叫软件测试自动化。要学习软件测试自动化，首先就需要清楚什么是软件测试。

## 软件测试

因为当局者迷，旁观者清的道理，软件开发是个复杂而周期性的过程，期间很容易产生或遗留下错误，而对于开发人员自己所编写与开发的应用程序（软件），往往有很多问题是他们自己发现不了，所以如果直接把存在不足的、有错误、有漏洞的应用程序直接运营上线提供给用户使用，那么很可能会给企业带来商业风险或影响企业受益，所以就需要软件测试人员进行软件测试了。

而软件测试（Software Testing）就是为了尽快尽早地发现软件的各种软件缺陷而展开的贯穿整个软件生命周期、对软件（包括阶段性产品）进行验证和确认的活动过程。这个过程是在规定的条件下对程序进行测试操作并对其是否能满足设计要求进行评估，以达到发现、纠正程序错误，衡量和提升软件质量的目的。通俗点说，软件测试就是通过各种各样的手段或工具来尽可能的找到软件的不足和错误。

软件测试只能查找出软件中的错误或不足，但不能证明程序中没有错误，而且软件测试不能完全消灭软件的错误，只能尽早尽量多的发现软件中的错误与不足。

```
软件生命周期是指从软件产品的可行性分析到软件不再使用而结束的时间。如果把软件看成是有生命的事物，那么软件的生命周期可分为6个阶段：需求分析、计划、设计、编码开发、测试、运行维护
```



### 测试分类

软件测试从不同的角度有着不同的分类方式。

![image-20220513075004943](assets/image-20220513075004943.png)

在实际开发中，往往我们都是根据实际情况采用多种不同的测试手段、测试方式来对软件测试测试的。



### 软件缺陷

软件缺陷，通常又被叫做bug或者defect，即为软件或程序中存在的某种破坏正常运行能力的问题、错误，其存在的最终表现为用户所需要的功能没有完全实现，不能满足或不能全部满足用户的需求。

+   从**产品内部**来说，软件缺陷是软件产品开发或维护过程中所存在的错误、误差等各种问题。

+   从**产品外部**来说，软件缺陷是系统所需要实现的某种功能的没有或不足。

#### 出现原因

bug出现的原因一般有如下几种情况，也就是说符合以下情况的问题都属于bug：

| 原因     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 功能遗漏 | 软件未实现用户或产品需求要求的或应有的功能。                 |
| 异常错误 | 软件出现了不应该出现的错误。                                 |
| 功能冗余 | 软件出现了用户或产品需求没有要求的功能。                     |
| 体验度低 | 软件的使用过程过于复杂或难以理解、软件运行缓慢导致用户体验不好。 |



#### 缺陷管理

缺陷管理也叫bug管理，一般会集成到项目管理工具中，常用的项目管理工具：[Teambition](https://www.teambition.com/)、[禅道](https://demo.zentao.net/)、[pingcode](https://pingcode.com/)、飞书、钉钉等。大部分的项目管理工具内置的缺陷管理功能都会对缺陷划分成不同类型、严重等级、优先级别，以及不同的状态。

##### 缺陷类型

| bug类型    | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 功能缺陷   | 软件中的功能没有实现或不完善而导致<br>使用过程出现异常错误、逻辑错误等问题。 |
| 界面缺陷   | 用户界面外观缺失或不足，影响了用户正常使用的问题。<br>如：名称过长时被遮挡、文字部分被遮挡、图片只展示部分等。 |
| 需求缺陷   | 需求规格说明书未明确或存在遗留需求的问题。                   |
| 性能问题   | 不满足系统可测量的属性值，如执行时间、处理速度等。<br>如：一个功能被用户使用时没有响应，或需要用户等待时间过久等。 |
| 接口缺陷   | 与其他组件、模块或程序、调用参数或参数列表等不匹配、出现冲突问题。<br>如传参个数与接口不匹配、传参类型与接口不匹配等。 |
| 兼容性缺陷 | 软件运行环境不匹配的问题<br>如操作系统、浏览器、网络环境等不匹配 |
| 易用性缺陷 | 新用户对软件难以快速熟悉或难以快速上手使用的问题。           |
| 代码错误   | 不满足需求、功能实现错误；对产品或项目质量有影响的bug        |
| 配置相关   | 由于提供的配置不当或者配置不能够满足实际要求而出现的问题     |
| 安装部署   | 由于部署安装引起的问题                                       |
| 安全相关   | 出现安全隐患问题，如存在SQL注入，xss攻击等。                 |
| 标准规范   | 不符合相关的国际、国家标准规范或业界规范等                   |



##### 严重等级

| 等级           | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 致命缺陷（S1） | 软件任何一个主要功能完全丧失，用户数据受到破坏，软件崩溃、<br>悬挂或者危及用户人身安全。如软件崩溃造成硬件设备漏电等 |
| 严重缺陷（S2） | 软件的主要功能部分丧失，数据不能保存，软件的次要功能完全丧失，<br>系统所提供的功能或服务受到明显的影响。如软件的某个菜单不起作用 |
| 一般缺陷（S3） | 软件的次要功能没有完全实现，但不影响用户的正常使用。<br>如软件内的某些内容输入有误或无法输入。 |
| 较小缺陷（S4） | 用户体验不好或操作不方便，但不影响功能使用和运行。<br>如软件内出现错别字或排版有问题等。 |

##### 优先级别

| 优先级         | 描述                                                   |
| -------------- | ------------------------------------------------------ |
| 立即解决（P1） | 针对软件的致命缺陷，往往需要立即修复。                 |
| 优先解决（P2） | 针对软件的严重缺陷，影响了测试，需要优先修复。         |
| 等候解决（P3） | 针对软件的一般缺陷，需要正常排队等待修复。             |
| 建议解决（P4） | 针对软件的较小缺陷，可以在开发人员有时间时再进行修复。 |



##### 生命周期

从发现bug到关闭bug的这个时间段，我们称之为缺陷（bug）的生命周期。

![image-20220513060547806](assets/image-20220513060547806.png)

在整个bug处理的流程上，一般会把bug划分成多个不同状态。

| 状态                        | 描述                                                         |
| --------------------------- | ------------------------------------------------------------ |
| 新建（New）                 | 当bug首次被发现时，测试人员会确认并记录下来，并将bug的状态为New |
| 已指派（Assigned）          | 当bug被指认为New之后，将其传递给开发组，开发组将确认这是否是bug，如果是则开发组的leader会将bug指派给某位开发人员处理，并将bug的状态<br>设定为“Assigned”。 |
| 重新指派（Reassigned）      | bug被重新指派给某位开发人员处理处理。                        |
| 已打开（Open）              | 一旦开发人员开始处理bug，就将bug的状态设为“Open”。           |
| 已修复（Fixed）             | 当开发人员进行处理（并认为已经解决）之后，就可以将bug的状态设置为“Fixed”并将其提交给开发组leader，然后leader将bug返还给测试组。 |
| 等待再测试（Pending Reset） | 当bug被返还到测试组后，会将bug的状态设置为“Pending Reset”    |
| 再测试(Reset)               | 测试组的leader将bug指定给某位测试人员进行再测试，并将bug的状态设置为“Reset”。 |
| 已关闭的（Closed）          | 如测试人员经过再次测试之后确认bug已被解决，会将bug的状态设置为 “Closed”。 |
| 再次打开的（Reopen）        | 如果经过再次测试发现bug仍然存在的话，测试人员将bug再次传递给开发组，并将bug的状态设置为“Reopen” |
| 拒绝中（Pending Reject）    | 如果测试人员传递到开发组的bug被开发组认为不是bug时，这种情况下开发组可以拒绝，将bug的状态设置为“Pending Reject”并返还给测试组。 |
| 被拒绝的(Rejected)          | 测试组的负责人接到拒绝的bug时，如果发现并不能算作bug时，测试组负责人将bug的状态设置为“Rejected”。当然，无法重现，bug信息不足或重复的bug，有时候也会被拒绝。 |
| 延期（Postponed）           | 对于一些特殊的bug的测试需要搁置一段时间，这种情况下，bug的状态就被设置为“Postponed“。 |



#### 缺陷报告

缺陷报告，也叫bug报告，是软件测试人员重要的产出物之一，也是主要工作之一。一份高质量的缺陷报告可以帮助开发人员快速定位问题，修复Bug；也便于测试人员对缺陷进行统计、分析和跟踪管理，是测试人员和开发人员重要的沟通工具。开发中针对需求，测试bug，最怕的就是口口相传。

缺陷报告的基本组成：**缺陷ID**，**缺陷标题**，发现者，前置条件，是否可重现，操作系统，发现时间，所属项目，所属模块，所属版本，缺陷状态，**严重等级**，**优先级别**，**附件描述**，**重现步骤**，预期效果，实际效果等。注意：加粗部分为BUG六要素。

参考模板：

![img](assets/e2a4213e-757c-4e2b-b185-6c67a1887e961.gif)

缺陷报告就是软件测试的结果产出物，而如何验证和测试缺陷？那就要继续往下学习更多内容了。



### 测试原则

| 原则                         | 描述                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 测试显示软件存在缺陷         | 测试只能证明软件中存在缺陷，但并不能证明软件中不存在缺陷，即零缺陷是不可能的。<br>软件测试是为了降低存在缺陷的可能性，即便是没有找到缺陷，也不能证明软件是完美的。 |
| 穷尽测试是不可能的           | 现在软件的规模越来越大，复杂度越来越高，想做到完全性的测试是不可能的。<br>测试人员可以根据严重等级、优先级、场景、目的来分类别进行集中和高强度的测试，从而保证软件的质量。 |
| 测试尽早介入                 | 测试人员越早介入软件开发流程越好，最好在需求阶段就开始介入，使缺陷在需求或设计阶段就被发现，<br>缺陷发现越早，修复的成本就越小，反之，越晚发现修复成本就越高。 |
| 缺陷存在集群现象（二八定律） | 80%的缺陷往往存在于20%的模块中。一般项目复杂功能往往会占据所有功能的20%左右，而这20%的复杂功能往往有可能会包含大部分的缺陷。一个功能模块发现的缺陷频率越高，那存在的未被发现的缺陷出现频率也越高，故发现的缺陷与未发现的缺陷成正比。**开发团队里面最菜的人写的代码bug最多，开发团队里面负责开发功能最复杂难度最高的人bug最多**。 |
| 杀虫剂悖论                   | 反复使用相同的杀虫剂会导致害虫对杀虫剂产生免疫而无法杀死害虫，软件测试也一样。如果一直使用相同的测试方法或手段，可能无法发现新的bug。为了解决这个问题，测试用例应当定期修订和评审，增加新的或不同的测试用例帮助发现更多的缺陷。 |
| 测试依赖于环境               | 测试在不同环境（操作系统，浏览器，解释器）下是不同的。所以不应该以完全相同的⽅法去测试两个不同的系统。 |
| 不存在缺陷的谬论             | 与第一条类似，期望仅仅发现并修复⼤量缺陷就能确保系统的成功，这是⼀个谬论。 |



## 测试自动化

著名的敏捷开发布道师 Mike Cohn（迈克·科恩） 在他的着作《Succeeding with Agile》(中文名：《Scrum敏捷软件开发》)一书中提出了测试金字塔的概念。

![测试金字塔.jpg](assets/测试金字塔.jpg)

根据 Mike Cohn 的测试金字塔，测试的组合应该至少由以下三层组成 (自下往上分别是)：

-   单元测试（Unit Tests）
-   服务测试（Services Tests）
-   用户界面测试（UI Tests）

意思是，应该把测试不同粒度的测试分布到整个软件不同层次中，而随着层次越高，编写的测试内容应该越少，也就是写许多小而快的低层次单元测试，适当写一些更粗粒度的中层次接口测试或集成测试，写很少的高层次UI测试、系统测试或验收测试。

所以，根据测试金字塔理论，接下来我们按部就班对测试自动化的内容进行学习。



# 单元测试自动化

所谓的单元测试(Unit Test)是根据特定的输入数据，针对程序代码中的最小实体单元的输入输出的正确性进行验证测试的过程。所谓的最小实体单元就是组织项目代码的最基本代码结构：**函数，类，模块**等。在Python中比较知名的单元测试模块：

-   **unittest**
-   **pytest**
-   nose
-   doctest

```
php phpunit
java javaunit
```



## 测试用例

所谓的测试用例(Test Case)，就是执行测试的依据和记录，把测试应用程序的操作步骤**用文档的形式描述**出来的一份文档。文档的格式可以是Excel、markdown、html、xmind网页。

一份合格的测试用例有利于测试人员理清测试思路，确保需要测试的功能周全没有遗漏，方便测试工作的开展和评估测试工作量，同时还可以便于测试人员记录测试数据和测试工作进度，为后续的回归测试提供样本参考，提升测试效率以及后续测试工作的交接。

那么一份合格的测试用例长什么样子或有什么内容呢？

一份合格的测试用例，应该包含测试时间、测试人员、**测试模块名**、**功能点名称**、**用例ID**、**用例说明（测试目的）**、**前置条件**、**输入数据**、**预期结果**、**测试结果（输出结果、实际结果）**等。注意：加粗内容为必备的测试用例八要素。

参考文档：

![image-20220515072055298](assets/image-20220515072055298.png)

在实际工作中，因为缺陷报告与测试用例作用相似，因此有时候会合并一起或只选择其中一种。

### 设计方法

那么在工作中，我们一般都应该编写测试用例或者应该怎么设计测试用例来完成我们的测试工作呢？实际上在工作中，测试人员都是基于测试用例的7种基本设计方法来设计与编写测试用例的：

+   **等价类划分法**：根据输入数据的有效性与无效性设计测试用例。
+   边界值分析法：对等价类划分法的一个补充，从等价类的边缘值（临界点）去寻找错误，基于这些错误来设计测试用例。
+   **判定表法**：把输入数据的各种可能情况进行组合罗列成一个判断表，以判断表来设计测试用例。
+   因果图法：用图解的方式表示输入数据的各种组合关系，以此写出判定表，从而设计相应的测试用例。
+   正交表法：基于[正交表](http://support.sas.com/techsup/technote/ts723_Designs.txt)来设计测试用例。
+   场景法：基于流程图展示业务流程或功能的调用流程，对流程图的走向路径设计测试用例。
+   错误推测法：基于经验和直觉，找出程序中认为可能出现的错误来设计测试用例。

一般在工作中，我们比较常用的是等价类划分法与判定表法。

#### 等价类划分法

等价类划分法就是按照测试要求，把具有共同特征的测试数据划分为2类：有效等价类和无效等价类，把测试数据进行分类以后设计测试用例。

+   有效等价类，就是符合程序使用要求或调用代码要求的，能正确使用程序或调用代码的一类数据。
+   无效等价类，就是不符合程序使用要求或调用代码要求的，会导致程序出现异常或结果不正确的一类数据。

使用等价类划分法，可以让我们设计的测试工作更加科学有依据，避免出现穷举测试的情况，减少测试用例的数量。

例如，注册功能中用户名的测试用例，如果功能需求中，要求用户名必须长度为3-11个长度的字符。

| 系统模块 | 功能点   | 用例ID | 测试目的   | 前置条件         | 输入              | 预期 | 结果 |
| -------- | -------- | ------ | ---------- | ---------------- | ----------------- | ---- | ---- |
| 会员模块 | 用户注册 | 01     | 验证用户名 | 打开用户注册页面 | "abc"             | 正确 |      |
| 会员模块 | 用户注册 | 02     | 验证用户名 | 打开用户注册页面 | "abdefgthssaaaaa" | 错误 |      |



#### 判定表法

判定表是分析和表达多逻辑条件下执行不同操作的情况的工具。而软件测试中的判定表法，就是把输入数据的各种可能情况进行组合罗列成一个判断表格，以判断表来设计测试用例。

判定表的表结构一般有如下2种：横向判断表与纵向判定表。

横向判断表：

| 条件桩 | 条件项 |
| ------ | ------ |
| 动作桩 | 动作项 |

纵向判定表：

| 条件桩 | 动作桩 |
| ------ | ------ |
| 条件项 | 动作项 |



例子，测试一个功能是否能修改文件。

| 如果使用纵向判定表： |                 |                 |                 |
| -------------------- | --------------- | --------------- | --------------- |
| 条件1：是否有权限    | 条件2：是否存在 | 结果1：可以修改 | 结果2：不能修改 |
| √                    | √               | √               | ✖               |
| √                    | ✖               | ✖               | √               |
| ✖                    | √               | ✖               | √               |
| ✖                    | ✖               | ✖               | √               |



| 如果使用横向判断表： |      |      |      |      |
| -------------------- | ---- | ---- | ---- | ---- |
| 条件桩：是否有权限   | ✔    | ✔    | ✖    | ✖    |
| 条件桩：是否存在     | ✔    | ✖    | ✔    | ✖    |
| 动作桩：可以修改     | ✔    | ✖    | ✖    | ✖    |
| 动作桩：不能修改     | ✖    | ✔    | ✔    | ✔    |



## 单元测试框架-Unittest

Unittest是Python开发中常用于单元测试的内置框架，免安装使用简单方便，其设计的灵感来源于Java的单元测试框架-Junit。

Unittest具备完整的测试结构，支持自动化测试的执行，对测试用例进行组织，并且提供了丰富的断言方法，还提供生成测试报告。

官方文档：https://docs.python.org/zh-cn/3/library/unittest.html

```
import unittest
print(dir(unittest))
```

上面的代码中，我们就引入了Unittest模块， 同时可以通过打印发现Unittest框架中内置了大量的工具成员。这些工具成员中除了以下5个以外，其他的都不怎么常用。

+   TestCase（测试用例）

    是unittest中最重要的一个类，用于编写测试用例类，是所有测试用例类的父类，实现了测试用例的基本代码。

    

+   TestSuite（测试套件、测试集）

    可以把多个TestCase组织、打包集成到一个测试集中一起执行，TestSuite可以实现多个测试用例的执行。

    

+   TextTestRunner（测试运行器）

    TestSuite本身不具备执行的功能，所以使用TextTestRunner执行测试套件和输出测试结果。

    

+   TestLoader（测试加载器）

    用于加载测试用例TestCase，并生成测试套件TestSuite，实现自动从代码中加载**大量**测试用例到测试套件中。

    

+   TestFixture（测试脚手架）

    所谓的测试脚手架就是为了开展一项或多项测试所需要进行的准备工作，以及所有相关的清理操作。测试脚手架实际上会在执行一些测试代码之前与之后，让我们编写一些初始化和销毁的代码。



### 快速入门

#### 测试用例-TestCase

前面讲到TestCase就是提供给我们编写测试用例的测试代码的，那么怎么编写一个测试用例？需要4个步骤即可。

1.  导入unittest模块

    ```python
    import unittest
    ```

2.  定义测试用例类

    ```python
    import unittest
    class 测试用例类名(unittest.TestCase): # 所有的测试用例类都必须直接或者间接继承unittest.TestCase.
        """测试用例"""
        pass
    ```

3.  定义测试用例方法（此处的测试用例方法，就是上面所说的测试用例设计方法中的一行信息的测试代码）

    ```python
    import unittest
    class 测试用例类名(unittest.TestCase):
        """测试用例"""
        # ....
        def test_测试方法名(参数):  # 测试方法必须以test开头或test_开头
            pass
        # ....
    ```

4.  执行测试用例

    ```python
    unittest.main()
    ```

在实际工作中，我们肯定是在项目中进行测试代码的编写或单独编写一个测试项目，但是我们现在刚开始学习，所以我们可以先编写一个例子代码，对其进行测试，以达到学习的目的。

unittest_01_测试用例的编写.py，代码：

```python
import unittest

# 被测试的代码单元
def add(x,y):
    return x+y

class FuncTest(unittest.TestCase):
    """测试用例"""
    def test_01(self):
        print(add(10, 20))

    def test_02(self):
        print(add("hello", "world"))

    # def test_03(self):
    #     print(add("hello", 20))


# 因为pycharm本身内置了执行unittest的功能，所以不适用以下代码也能执行，但是终端下或者使用其他的代码编辑器时，则需要加上。
if __name__ == '__main__':
    unittest.main()
```



#### 测试套件-TestSuite

前面我们将到测试套件，主要用于把多个测试用例类打包集成到一个测试集中一起执行。工作中，一个项目往往需要编写非常多的测试用例，而那么多的测试用例也不可能只编写在一个文件中，此时就需要使用测试套件了。2个步骤：

1.  通过unittest.TestSuite实例化测试套件对象

    ```
    suite = unittest.TestSuite()
    ```

    

2.  通过addTest方法添加测试用例

    +   添加测试用例方法

        ```python
        # 添加测试用例方法
        suite.addtest(测试用例类名("测试用例方法名"))
        
        # 批量添加测试用例方法
        test_data = (测试用例类名("测试用例方法名1"), 测试用例类名("测试用例方法名2"))
        suite.addtests(test_data)
        ```

    +   添加测试用例类(一次性添加测试用例的所有test_方法)

        ```python
        # 添加测试用例类
        suite.addtest(unittest.makeSuite(测试用例类名))
        
        # 批量添加测试用例类
        test_data = (unittest.makeSuite(测试用例类名1),  unittest.makeSuite(测试用例类名2))
        suite.addTests(test_data)
        ```

unittest_02_测试套件的基本使用.py，代码：

```python
import unittest

import unittest_01_测试用例的编写 as unittest_01

suite = unittest.TestSuite()

# # 1. 添加测试用例方法
# suite.addTest(unittest_01.FuncTest("test_01"))
# suite.addTest(unittest_01.FuncTest("test_02"))

# # 2. 批量添加测试用例方法
# test_data = (unittest_01.FuncTest("test_01"), unittest_01.FuncTest("test_02"))
# suite.addTests(test_data)


# # 3. 添加测试用例类
# suite.addTest(unittest.makeSuite(unittest_01.FuncTest))


# 4. 批量添加测试用例类
test_data = (unittest.makeSuite(unittest_01.FuncTest),  unittest.makeSuite(unittest_01.FuncTest))
suite.addTests(test_data)
```

TestSuite的作用仅仅是把多个测试用例打包集成到一块，但是并没有提供批量执行测试用例的方法，所以我们需要使用TextTestRunner了。



#### 测试运行器-TextTestRunner

前面说过，TextTestRunner是用于执行测试用例、测试套件和输出测试结果的。2个步骤：

+   实例化运行器对象

+   通过run方法执行测试



unittest_03_测试运行器基本使用.py，代码：

```python
import unittest

import unittest_01_测试用例的编写 as unittest_01

suite = unittest.TestSuite()

# # 添加测试用例方法
# suite.addTest(unittest_01.FuncTest("test_01"))
# suite.addTest(unittest_01.FuncTest("test_02"))

# # 批量添加测试用例方法
# test_data = (unittest_01.FuncTest("test_01"), unittest_01.FuncTest("test_02"))
# suite.addTests(test_data)


# # 添加测试用例类
# suite.addTest(unittest.makeSuite(unittest_01.FuncTest))


# 批量添加测试用例类
test_data = (unittest.makeSuite(unittest_01.FuncTest),  unittest.makeSuite(unittest_01.FuncTest))
suite.addTests(test_data)

if __name__ == '__main__':
    runner = unittest.TextTestRunner()
    runner.run(suite)
```



####  测试加载器-TestLoader

前面说过，用于加载测试用例TestCase，并生成测试套件TestSuite，实现自动从代码中加载**大量**测试用例到测试套件中。2个步骤：

+   实例化unittest.TestLoader对象

    ```python
    loader = unittest.TestLoader()
    ```

+   使用discover方法自动搜索指定目录下指定文件格式的python模块，并把查找到的测试用例组装打包集成到测试组件作为返回值。

    ```python
    loader.discover(目录路径, pattern="文件名格式")
    ```

    注意：pattern支持`*`号表示0到多个字符。

unittest_04_测试加载器基本使用.py，代码：

```python
import unittest
loader = unittest.TestLoader()
# 在当前目录下，搜索以unittest开头作为文件名的所有python文件，并把文件中的测试用例类打包集成到测试套件中
suite =loader.discover("./", pattern="unittest*.py")

if __name__ == '__main__':
    runner = unittest.TextTestRunner()
    runner.run(suite)
```



#### 测试脚手架-TestFixture

前面提到，测试脚手架会在执行一些测试代码之前与之后，让我们编写一些初始化和销毁的代码，主要分三个级别：

+   方法级别：在方法执行前与执行后都提供自动调用的实例方法

    setUp和tearDown

+   类级别：在类执行前与执行后都提供自动调用的类方法，不管类中有多少方法，只执行一次。

    setUpClass和tearDownClass

+   模块级别：在模块执行前与执行后都提供自动调用的函数，不管模块中有多少类或方法，只执行一次。

    setUpModule和tearDownModule



##### 方法级别的脚手架

在测试用例类中提供了2个固定名字的实例方法（setUp与tearDown），用于完成方法执行前与执行后的操作。

unittest_05_测试脚手架_方法级别的脚手架.py，代码：

```python
import unittest

# 被测试的代码单元
def add(x,y):
    return x+y

class AddTest(unittest.TestCase):
    """测试用例"""
    def setUp(self):
        print("每个方法执行前都会执行一遍setUp实例方法，用于完成通用的前置操作或初始化工作")

    def tearDown(self):
        print("每个方法执行后都会执行一遍tearDown实例方法，用于完成通用的后置操作或销毁工作")

    def test_01(self):
        print(add(10, 20))

    def test_03(self):
        print(add("hello", 20))


# 因为pycharm本身内置了执行unittest的功能，所以不适用以下代码也能执行，但是终端下或者使用其他的代码编辑器时，则需要加上。
if __name__ == '__main__':
    unittest.main()
```



##### 类级别的脚手架

在测试用例类中提供了2个固定名字的类方法（setUpClass与tearDownClass），用于完成类执行前与执行后的操作。

unittest_06_测试脚手架_类级别的脚手架.py，代码：

```python
import unittest

# 被测试的代码单元
def add(x,y):
    return x+y

class AddTest(unittest.TestCase):
    """测试用例"""
    @classmethod
    def setUpClass(cls):
        print("当前类执行前都会执行一遍setUpClass类方法，用于完成通用的前置操作或初始化工作")

    @classmethod
    def tearDownClass(cls):
        print("当前类执行后都会执行一遍tearDownClass类方法，用于完成通用的后置操作或销毁工作")

    def test_01(self):
        print(add(10, 20))

    def test_03(self):
        print(add("hello", 20))


# 因为pycharm本身内置了执行unittest的功能，所以不适用以下代码也能执行，但是终端下或者使用其他的代码编辑器时，则需要加上。
if __name__ == '__main__':
    unittest.main()
```



##### 模块级别的脚手架

在测试用例类中提供了2个固定名字的函数（setUpModule与tearDownModule），用于完成类执行前与执行后的操作。

unittest_07_测试脚手架_模块级别的脚手架.py，代码：

```python
import unittest


def setUpModule():
    print("当前模块执行前都会执行一遍setUpModule函数，用于完成通用的前置操作或初始化工作")


def tearDownModule():
    print("当前模块执行前都会执行一遍tearDownModule函数，用于完成通用的前置操作或初始化工作")


# 被测试的代码单元
def add(x, y):
    return x + y


class AddTest1(unittest.TestCase):
    """测试用例"""

    @classmethod
    def setUpClass(cls):
        print("当前类执行前都会执行一遍setUpClass类方法，用于完成通用的前置操作或初始化工作")

    @classmethod
    def tearDownClass(cls):
        print("当前类执行后都会执行一遍tearDownClass类方法，用于完成通用的后置操作或销毁工作")

    def test_01(self):
        print(add(10, 20))


class AddTest2(unittest.TestCase):
    """测试用例"""

    @classmethod
    def setUpClass(cls):
        print("当前类执行前都会执行一遍setUp方法，用于完成通用的前置操作或初始化工作")

    @classmethod
    def tearDownClass(cls):
        print("当前类执行后都会执行一遍tearDown方法，用于完成通用的后置操作或销毁工作")

    def test_03(self):
        print(add("hello", 20))


# 因为pycharm本身内置了执行unittest的功能，所以不适用以下代码也能执行，但是终端下或者使用其他的代码编辑器时，则需要加上。
if __name__ == '__main__':
    unittest.main()
```



#### 生成HTML格式测试报告(很少使用，基本不使用)

使用HTMLTestRunner模块可以直接生成HTML格式的报告。HTMLTestRunner是一个不再维护的第三方的模块，通过pip工具安装不了，只能下载后手动导入。

HTMLTestRunner官网：http://tungwaiyip.info/software/HTMLTestRunner.html

HTMLTestRunner下载：http://tungwaiyip.info/software/HTMLTestRunner_0_8_2/HTMLTestRunner.py

因为HTMLTestRunner是python2模块的，所以在python3.x以后需要做些修改才可以使用，修改后版本代码如下：

```python
"""
A TestRunner for use with the Python unit testing framework. It
generates a HTML report to show the result at a glance.

The simplest way to use this is to invoke its main method. E.g.

    import unittest
    import HTMLTestRunner

    ... define your tests ...

    if __name__ == '__main__':
        HTMLTestRunner.main()


For more customization options, instantiates a HTMLTestRunner object.
HTMLTestRunner is a counterpart to unittest's TextTestRunner. E.g.

    # output to a file
    fp = file('my_report.html', 'wb')
    runner = HTMLTestRunner.HTMLTestRunner(
                stream=fp,
                title='My unit test',
                description='This demonstrates the report output by HTMLTestRunner.'
                )

    # Use an external stylesheet.
    # See the Template_mixin class for more customizable options
    runner.STYLESHEET_TMPL = '<link rel="stylesheet" href="my_stylesheet.css" type="text/css">'

    # run the test
    runner.run(my_test_suite)


------------------------------------------------------------------------
Copyright (c) 2004-2007, Wai Yip Tung
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name Wai Yip Tung nor the names of its contributors may be
  used to endorse or promote products derived from this software without
  specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

# URL: http://tungwaiyip.info/software/HTMLTestRunner.html

__author__ = "Wai Yip Tung"
__version__ = "0.8.2"


"""
Change History

Version 0.8.2
* Show output inline instead of popup window (Viorel Lupu).

Version in 0.8.1
* Validated XHTML (Wolfgang Borgert).
* Added description of test classes and test cases.

Version in 0.8.0
* Define Template_mixin class for customization.
* Workaround a IE 6 bug that it does not treat <script> block as CDATA.

Version in 0.7.1
* Back port to Python 2.3 (Frank Horowitz).
* Fix missing scroll bars in detail log (Podi).
"""

# TODO: color stderr
# TODO: simplify javascript using ,ore than 1 class in the class attribute?

import datetime
import io
import sys
import time
import unittest
from xml.sax import saxutils


# ------------------------------------------------------------------------
# The redirectors below are used to capture output during testing. Output
# sent to sys.stdout and sys.stderr are automatically captured. However
# in some cases sys.stdout is already cached before HTMLTestRunner is
# invoked (e.g. calling logging.basicConfig). In order to capture those
# output, use the redirectors for the cached stream.
#
# e.g.
#   >>> logging.basicConfig(stream=HTMLTestRunner.stdout_redirector)
#   >>>

class OutputRedirector(object):
    """ Wrapper to redirect stdout or stderr """
    def __init__(self, fp):
        self.fp = fp

    def write(self, s):
        self.fp.write(s)

    def writelines(self, lines):
        self.fp.writelines(lines)

    def flush(self):
        self.fp.flush()

stdout_redirector = OutputRedirector(sys.stdout)
stderr_redirector = OutputRedirector(sys.stderr)



# ----------------------------------------------------------------------
# Template

class Template_mixin(object):
    """
    Define a HTML template for report customerization and generation.

    Overall structure of an HTML report

    HTML
    +------------------------+
    |<html>                  |
    |  <head>                |
    |                        |
    |   STYLESHEET           |
    |   +----------------+   |
    |   |                |   |
    |   +----------------+   |
    |                        |
    |  </head>               |
    |                        |
    |  <body>                |
    |                        |
    |   HEADING              |
    |   +----------------+   |
    |   |                |   |
    |   +----------------+   |
    |                        |
    |   REPORT               |
    |   +----------------+   |
    |   |                |   |
    |   +----------------+   |
    |                        |
    |   ENDING               |
    |   +----------------+   |
    |   |                |   |
    |   +----------------+   |
    |                        |
    |  </body>               |
    |</html>                 |
    +------------------------+
    """

    STATUS = {
    0: 'pass',
    1: 'fail',
    2: 'error',
    }

    DEFAULT_TITLE = 'Unit Test Report'
    DEFAULT_TESTER = 'Unit Test'
    DEFAULT_DESCRIPTION = ''

    # ------------------------------------------------------------------------
    # HTML Template

    HTML_TMPL = r"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>%(title)s</title>
    <meta name="generator" content="%(generator)s"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    %(stylesheet)s
</head>
<body>
<script language="javascript" type="text/javascript"><!--
output_list = Array();

/* level - 0:Summary; 1:Failed; 2:All */
function showCase(level) {
    trs = document.getElementsByTagName("tr");
    for (var i = 0; i < trs.length; i++) {
        tr = trs[i];
        id = tr.id;
        if (id.substr(0,2) == 'ft') {
            if (level < 1) {
                tr.className = 'hiddenRow';
            }
            else {
                tr.className = '';
            }
        }
        if (id.substr(0,2) == 'pt') {
            if (level > 1) {
                tr.className = '';
            }
            else {
                tr.className = 'hiddenRow';
            }
        }
    }
}


function showClassDetail(cid, count) {
    var id_list = Array(count);
    var toHide = 1;
    for (var i = 0; i < count; i++) {
        tid0 = 't' + cid.substr(1) + '.' + (i+1);
        tid = 'f' + tid0;
        tr = document.getElementById(tid);
        if (!tr) {
            tid = 'p' + tid0;
            tr = document.getElementById(tid);
        }
        id_list[i] = tid;
        if (tr.className) {
            toHide = 0;
        }
    }
    for (var i = 0; i < count; i++) {
        tid = id_list[i];
        if (toHide) {
            document.getElementById('div_'+tid).style.display = 'none'
            document.getElementById(tid).className = 'hiddenRow';
        }
        else {
            document.getElementById(tid).className = '';
        }
    }
}


function showTestDetail(div_id){
    var details_div = document.getElementById(div_id)
    var displayState = details_div.style.display
    // alert(displayState)
    if (displayState != 'block' ) {
        displayState = 'block'
        details_div.style.display = 'block'
    }
    else {
        details_div.style.display = 'none'
    }
}


function html_escape(s) {
    s = s.replace(/&/g,'&amp;');
    s = s.replace(/</g,'&lt;');
    s = s.replace(/>/g,'&gt;');
    return s;
}

/* obsoleted by detail in <div>
function showOutput(id, name) {
    var w = window.open("", //url
                    name,
                    "resizable,scrollbars,status,width=800,height=450");
    d = w.document;
    d.write("<pre>");
    d.write(html_escape(output_list[id]));
    d.write("\n");
    d.write("<a href='javascript:window.close()'>close</a>\n");
    d.write("</pre>\n");
    d.close();
}
*/
--></script>

%(heading)s
%(report)s
%(ending)s

</body>
</html>
"""
    # variables: (title, generator, stylesheet, heading, report, ending)


    # ------------------------------------------------------------------------
    # Stylesheet
    #
    # alternatively use a <link> for external style sheet, e.g.
    #   <link rel="stylesheet" href="$url" type="text/css">

    STYLESHEET_TMPL = """
<style type="text/css" media="screen">
body        { font-family: verdana, arial, helvetica, sans-serif; font-size: 80%; }
table       { font-size: 100%; }
pre         { }

/* -- heading ---------------------------------------------------------------------- */
h1 {
  font-size: 16pt;
  color: gray;
}
.heading {
    margin-top: 0ex;
    margin-bottom: 1ex;
}

.heading .attribute {
    margin-top: 1ex;
    margin-bottom: 0;
}

.heading .description {
    margin-top: 4ex;
    margin-bottom: 6ex;
}

/* -- css div popup ------------------------------------------------------------------------ */
a.popup_link {
}

a.popup_link:hover {
    color: red;
}

.popup_window {
    display: none;
    position: relative;
    left: 0px;
    top: 0px;
    /*border: solid #627173 1px; */
    padding: 10px;
    background-color: #E6E6D6;
    font-family: "Lucida Console", "Courier New", Courier, monospace;
    text-align: left;
    font-size: 8pt;
    width: 500px;
}

}
/* -- report ------------------------------------------------------------------------ */
#show_detail_line {
    margin-top: 3ex;
    margin-bottom: 1ex;
}
#result_table {
    width: 80%;
    border-collapse: collapse;
    border: 1px solid #777;
}
#header_row {
    font-weight: bold;
    color: white;
    background-color: #777;
}
#result_table td {
    border: 1px solid #777;
    padding: 2px;
}
#total_row  { font-weight: bold; }
.passClass  { background-color: #6c6; }
.failClass  { background-color: #c60; }
.errorClass { background-color: #c00; }
.passCase   { color: #6c6; }
.failCase   { color: #c60; font-weight: bold; }
.errorCase  { color: #c00; font-weight: bold; }
.hiddenRow  { display: none; }
.testcase   { margin-left: 2em; }


/* -- ending ---------------------------------------------------------------------- */
#ending {
}

</style>
"""



    # ------------------------------------------------------------------------
    # Heading
    #

    HEADING_TMPL = """<div class='heading'>
<h1>%(title)s</h1>
%(parameters)s
<p class='description'>%(description)s</p>
</div>

""" # variables: (title, parameters, description)

    HEADING_ATTRIBUTE_TMPL = """<p class='attribute'><strong>%(name)s:</strong> %(value)s</p>
""" # variables: (name, value)



    # ------------------------------------------------------------------------
    # Report
    #

    REPORT_TMPL = """
<p id='show_detail_line'>Show
<a href='javascript:showCase(0)'>Summary</a>
<a href='javascript:showCase(1)'>Failed</a>
<a href='javascript:showCase(2)'>All</a>
</p>
<table id='result_table'>
<colgroup>
<col align='left' />
<col align='right' />
<col align='right' />
<col align='right' />
<col align='right' />
<col align='right' />
</colgroup>
<tr id='header_row'>
    <td>Test Group/Test case</td>
    <td>Count</td>
    <td>Pass</td>
    <td>Fail</td>
    <td>Error</td>
    <td>View</td>
</tr>
%(test_list)s
<tr id='total_row'>
    <td>Total</td>
    <td>%(count)s</td>
    <td>%(Pass)s</td>
    <td>%(fail)s</td>
    <td>%(error)s</td>
    <td>&nbsp;</td>
</tr>
</table>
""" # variables: (test_list, count, Pass, fail, error)

    REPORT_CLASS_TMPL = r"""
<tr class='%(style)s'>
    <td>%(desc)s</td>
    <td>%(count)s</td>
    <td>%(Pass)s</td>
    <td>%(fail)s</td>
    <td>%(error)s</td>
    <td><a href="javascript:showClassDetail('%(cid)s',%(count)s)">Detail</a></td>
</tr>
""" # variables: (style, desc, count, Pass, fail, error, cid)


    REPORT_TEST_WITH_OUTPUT_TMPL = r"""
<tr id='%(tid)s' class='%(Class)s'>
    <td class='%(style)s'><div class='testcase'>%(desc)s</div></td>
    <td colspan='5' align='center'>

    <!--css div popup start-->
    <a class="popup_link" onfocus='this.blur();' href="javascript:showTestDetail('div_%(tid)s')" >
        %(status)s</a>

    <div id='div_%(tid)s' class="popup_window">
        <div style='text-align: right; color:red;cursor:pointer'>
        <a onfocus='this.blur();' onclick="document.getElementById('div_%(tid)s').style.display = 'none' " >
           [x]</a>
        </div>
        <pre>
        %(script)s
        </pre>
    </div>
    <!--css div popup end-->

    </td>
</tr>
""" # variables: (tid, Class, style, desc, status)


    REPORT_TEST_NO_OUTPUT_TMPL = r"""
<tr id='%(tid)s' class='%(Class)s'>
    <td class='%(style)s'><div class='testcase'>%(desc)s</div></td>
    <td colspan='5' align='center'>%(status)s</td>
</tr>
""" # variables: (tid, Class, style, desc, status)


    REPORT_TEST_OUTPUT_TMPL = r"""
%(id)s: %(output)s
""" # variables: (id, output)



    # ------------------------------------------------------------------------
    # ENDING
    #

    ENDING_TMPL = """<div id='ending'>&nbsp;</div>"""

# -------------------- The end of the Template class -------------------


TestResult = unittest.TestResult

class _TestResult(TestResult):
    # note: _TestResult is a pure representation of results.
    # It lacks the output and reporting ability compares to unittest._TextTestResult.

    def __init__(self, verbosity=1):
        TestResult.__init__(self)
        self.stdout0 = None
        self.stderr0 = None
        self.success_count = 0
        self.failure_count = 0
        self.error_count = 0
        self.verbosity = verbosity

        # result is a list of result in 4 tuple
        # (
        #   result code (0: success; 1: fail; 2: error),
        #   TestCase object,
        #   Test output (byte string),
        #   stack trace,
        # )
        self.result = []


    def startTest(self, test):
        TestResult.startTest(self, test)
        # just one buffer for both stdout and stderr
        self.outputBuffer = io.StringIO()
        stdout_redirector.fp = self.outputBuffer
        stderr_redirector.fp = self.outputBuffer
        self.stdout0 = sys.stdout
        self.stderr0 = sys.stderr
        sys.stdout = stdout_redirector
        sys.stderr = stderr_redirector


    def complete_output(self):
        """
        Disconnect output redirection and return buffer.
        Safe to call multiple times.
        """
        if self.stdout0:
            sys.stdout = self.stdout0
            sys.stderr = self.stderr0
            self.stdout0 = None
            self.stderr0 = None
        return self.outputBuffer.getvalue()


    def stopTest(self, test):
        # Usually one of addSuccess, addError or addFailure would have been called.
        # But there are some path in unittest that would bypass this.
        # We must disconnect stdout in stopTest(), which is guaranteed to be called.
        self.complete_output()


    def addSuccess(self, test):
        self.success_count += 1
        TestResult.addSuccess(self, test)
        output = self.complete_output()
        self.result.append((0, test, output, ''))
        if self.verbosity > 1:
            sys.stderr.write('ok ')
            sys.stderr.write(str(test))
            sys.stderr.write('\n')
        else:
            sys.stderr.write('.')

    def addError(self, test, err):
        self.error_count += 1
        TestResult.addError(self, test, err)
        _, _exc_str = self.errors[-1]
        output = self.complete_output()
        self.result.append((2, test, output, _exc_str))
        if self.verbosity > 1:
            sys.stderr.write('E  ')
            sys.stderr.write(str(test))
            sys.stderr.write('\n')
        else:
            sys.stderr.write('E')

    def addFailure(self, test, err):
        self.failure_count += 1
        TestResult.addFailure(self, test, err)
        _, _exc_str = self.failures[-1]
        output = self.complete_output()
        self.result.append((1, test, output, _exc_str))
        if self.verbosity > 1:
            sys.stderr.write('F  ')
            sys.stderr.write(str(test))
            sys.stderr.write('\n')
        else:
            sys.stderr.write('F')


class HTMLTestRunner(Template_mixin):
    """
    """
    def __init__(self, stream=sys.stdout, verbosity=1, title=None, description=None, tester=None):
        self.stream = stream
        self.verbosity = verbosity
        if title is None:
            self.title = self.DEFAULT_TITLE
        else:
            self.title = title
        if description is None:
            self.description = self.DEFAULT_DESCRIPTION
        else:
            self.description = description

        self.startTime = datetime.datetime.now()
        if tester is None:
            self.tester = self.DEFAULT_TITLE
        else:
            self.tester = tester

    def run(self, test):
        "Run the given test case or test suite."
        result = _TestResult(self.verbosity)
        test(result)
        self.stopTime = datetime.datetime.now()
        self.generateReport(test, result)
        print (sys.stderr, "\nTime Elapsed: %s" %(self.stopTime-self.startTime))
        return result


    def sortResult(self, result_list):
        # unittest does not seems to run in any particular order.
        # Here at least we want to group them together by class.
        rmap = {}
        classes = []
        for n,t,o,e in result_list:
            cls = t.__class__
            if not cls in rmap:
                rmap[cls] = []
                classes.append(cls)
            rmap[cls].append((n,t,o,e))
        r = [(cls, rmap[cls]) for cls in classes]
        return r


    def getReportAttributes(self, result):
        """
        Return report attributes as a list of (name, value).
        Override this to add custom attributes.
        """
        startTime = str(self.startTime)[:19]
        duration = str(self.stopTime - self.startTime)
        status = []
        if result.success_count: status.append('Pass %s'    % result.success_count)
        if result.failure_count: status.append('Failure %s' % result.failure_count)
        if result.error_count:   status.append('Error %s'   % result.error_count  )
        if status:
            status = ' '.join(status)
        else:
            status = 'none'
        return [
            ('Start Time', startTime),
            ('Duration', duration),
            ('Status', status),
            ('Tester', self.tester),
        ]


    def generateReport(self, test, result):
        report_attrs = self.getReportAttributes(result)
        generator = 'HTMLTestRunner %s' % __version__
        stylesheet = self._generate_stylesheet()
        heading = self._generate_heading(report_attrs)
        report = self._generate_report(result)
        ending = self._generate_ending()
        output = self.HTML_TMPL % dict(
            title = saxutils.escape(self.title),
            generator = generator,
            stylesheet = stylesheet,
            heading = heading,
            report = report,
            ending = ending,
        )
        self.stream.write(output.encode('utf8'))


    def _generate_stylesheet(self):
        return self.STYLESHEET_TMPL


    def _generate_heading(self, report_attrs):
        a_lines = []
        for name, value in report_attrs:
            line = self.HEADING_ATTRIBUTE_TMPL % dict(
                    name = saxutils.escape(name),
                    value = saxutils.escape(value),
                )
            a_lines.append(line)
        heading = self.HEADING_TMPL % dict(
            title = saxutils.escape(self.title),
            parameters = ''.join(a_lines),
            description = saxutils.escape(self.description),
        )
        return heading


    def _generate_report(self, result):
        rows = []
        sortedResult = self.sortResult(result.result)
        for cid, (cls, cls_results) in enumerate(sortedResult):
            # subtotal for a class
            np = nf = ne = 0
            for n,t,o,e in cls_results:
                if n == 0: np += 1
                elif n == 1: nf += 1
                else: ne += 1

            # format class description
            if cls.__module__ == "__main__":
                name = cls.__name__
            else:
                name = "%s.%s" % (cls.__module__, cls.__name__)
            doc = cls.__doc__ and cls.__doc__.split("\n")[0] or ""
            desc = doc and '%s: %s' % (name, doc) or name

            row = self.REPORT_CLASS_TMPL % dict(
                style = ne > 0 and 'errorClass' or nf > 0 and 'failClass' or 'passClass',
                desc = desc,
                count = np+nf+ne,
                Pass = np,
                fail = nf,
                error = ne,
                cid = 'c%s' % (cid+1),
            )
            rows.append(row)

            for tid, (n,t,o,e) in enumerate(cls_results):
                self._generate_report_test(rows, cid, tid, n, t, o, e)

        report = self.REPORT_TMPL % dict(
            test_list = ''.join(rows),
            count = str(result.success_count+result.failure_count+result.error_count),
            Pass = str(result.success_count),
            fail = str(result.failure_count),
            error = str(result.error_count),
        )
        return report


    def _generate_report_test(self, rows, cid, tid, n, t, o, e):
        # e.g. 'pt1.1', 'ft1.1', etc
        has_output = bool(o or e)
        tid = (n == 0 and 'p' or 'f') + 't%s.%s' % (cid+1,tid+1)
        name = t.id().split('.')[-1]
        doc = t.shortDescription() or ""
        desc = doc and ('%s: %s' % (name, doc)) or name
        tmpl = has_output and self.REPORT_TEST_WITH_OUTPUT_TMPL or self.REPORT_TEST_NO_OUTPUT_TMPL

        # o and e should be byte string because they are collected from stdout and stderr?
        if isinstance(o,str):
            # TODO: some problem with 'string_escape': it escape \n and mess up formating
            # uo = unicode(o.encode('string_escape'))
            uo=o
        else:
            uo = o

        ue = e

        script = self.REPORT_TEST_OUTPUT_TMPL % dict(
            id = tid,
            output = saxutils.escape(uo+ue),
        )

        row = tmpl % dict(
            tid = tid,
            Class = (n == 0 and 'hiddenRow' or 'none'),
            style = n == 2 and 'errorCase' or (n == 1 and 'failCase' or 'none'),
            desc = desc,
            script = script,
            status = self.STATUS[n],
        )
        rows.append(row)
        if not has_output:
            return

    def _generate_ending(self):
        return self.ENDING_TMPL


##############################################################################
# Facilities for running tests from the command line
##############################################################################

# Note: Reuse unittest.TestProgram to launch test. In the future we may
# build our own launcher to support more specific command line
# parameters like test title, CSS, etc.
class TestProgram(unittest.TestProgram):
    """
    A variation of the unittest.TestProgram. Please refer to the base
    class for command line parameters.
    """
    def runTests(self):
        # Pick HTMLTestRunner as the default test runner.
        # base class's testRunner parameter is not useful because it means
        # we have to instantiate HTMLTestRunner before we know self.verbosity.
        if self.testRunner is None:
            self.testRunner = HTMLTestRunner(verbosity=self.verbosity)
        unittest.TestProgram.runTests(self)

main = TestProgram

##############################################################################
# Executing this module from the command line
##############################################################################

if __name__ == "__main__":
    main(module=None)
```



打印HTML格式的测试报告，unittest_08_打印HTML格式的测试报告.py，代码：

```python
import unittest
from HTMLTestRunner import HTMLTestRunner
import unittest_01_测试用例的编写 as unittest_01

suite = unittest.TestSuite()

test_data = (unittest.makeSuite(unittest_01.FuncTest),  unittest.makeSuite(unittest_01.FuncTest))
suite.addTests(test_data)

if __name__ == '__main__':
    # 生成html报告
    with open("test_report.html", "wb") as file:
        runner = HTMLTestRunner(
            stream=file,
            title="单元测试的HTML格式报告",
            description="python单元测试报告",
            tester="墨落"
        )
        runner.run(suite)
```



#### 断言

断言(assertion)是一种在程序中的判断测试用例执行结果是否符合预期结果的方式，所以断言也被称之为“期望”。当程序执行到断言的位置时，对应的断言应该为真。若断言不为真时，程序会中止执行，并给出错误信息。

unittest中常用的断言方法（加粗为重要方法）：

| 断言方法                                 | 断言描述                               |
| :--------------------------------------- | :------------------------------------- |
| **assertEqual(arg1, arg2, msg=None)**    | 验证arg1=arg2，不等则fail              |
| **assertNotEqual(arg1, arg2, msg=None)** | 验证arg1 != arg2, 相等则fail           |
| **assertTrue(expr, msg=None)**           | 验证expr是true，如果为false，则fail    |
| **assertFalse(expr,msg=None)**           | 验证expr是false，如果为true，则fail    |
| **assertIs(arg1, arg2, msg=None)**       | 验证arg1、arg2是同一个对象，不是则fail |
| **assertIsNot(arg1, arg2, msg=None)**    | 验证arg1、arg2不是同一个对象，是则fail |
| **assertIsNone(expr, msg=None)**         | 验证expr是None，不是则fail             |
| **assertIsNotNone(expr, msg=None)**      | 验证expr不是None，是则fail             |
| **assertIn(arg1, arg2, msg=None)**       | 验证arg1是arg2的子串，不是则fail       |
| **assertNotIn(arg1, arg2, msg=None)**    | 验证arg1不是arg2的子串，是则fail       |
| assertIsInstance(obj, cls, msg=None)     | 验证obj是cls的实例，不是则fail         |
| assertNotIsInstance(obj, cls, msg=None)  | 验证obj不是cls的实例，是则fail         |



unittest_09_断言.py，代码：

```python
import unittest

def add(x ,y):
    return x + y


class AddTest(unittest.TestCase):
    def test_01(self):
        res = add(1,2)
        # 断言结果是否与预期内容相同
        # self.assertEqual(res, 3, msg="断言失败！一般会错误的结果与原因")
        # self.assertEqual(res, 2, msg="断言失败！一般会错误的结果与原因")
        self.assertIn(res, [1, 2], msg="断言失败！一般会错误的结果与原因")

if __name__ == '__main__':
    unittest.main()

```



#### 跳过

针对开发中有时候针对不同环境或者不同的时间段，不同的代码版本，有时候部分测试用例不希望被执行，则可以使用跳过。

```python
@unittest.skipIf(判断条件表达式, 跳过原因)
```

unittest_10_跳过.py，代码：

```python
import unittest


def add(x, y):
    return x + y


version = (2, 7, 0)

class AddTest(unittest.TestCase):
    def setUp(self):
        print("setUP执行....")

    @unittest.skipIf(version <= (3, 5, 0), "版本低于3.5，所以不测试test_01")
    def test_01(self):
        res = add(1, 2)
        self.assertIn(res, [1, 3], msg="断言失败！一般会错误的结果与原因")

    def test_02(self):
        res = add("a", "B")
        self.assertEqual(res, "aB", msg="断言失败！一般会错误的结果与原因")


if __name__ == '__main__':
    unittest.main()

```





#### 参数化

当需要使用多组不同的测试数据测试同一个方法时，可以使用unittest参数化来解决。常用的参数化方法有ddt、parameterized

```python
pip install parameterized
```

unittest_11_参数化.py，代码：

```python
import unittest
from parameterized import parameterized

def add(x, y):
    return x + y


version = (2, 7, 0)

class AddTest(unittest.TestCase):
    def setUp(self):
        print("setUP执行....")

    @parameterized.expand([(10,20), ("a","B"), (50, 20)])
    def test_00(self, x, y):
        res = add(x, y)
        self.assertIn(res, [1, 30, "aB", 70], msg="断言失败！一般会错误的结果与原因")


    # def test_01(self):
    #     res = add(1, 2)
    #     self.assertIn(res, [1, 3], msg="断言失败！一般会错误的结果与原因")
    #
    # def test_02(self):
    #     res = add("a", "B")
    #     self.assertEqual(res, "aB", msg="断言失败！一般会错误的结果与原因")
    #
    # def test_03(self):
    #     print(add("a", 20))

if __name__ == '__main__':
    unittest.main()
```



### 数据驱动测试

Data-Driven Tests（DDT）即数据驱动测试，可以实现多个数据对同一个方法进行测试，达到数据和测试代码分离，目的是为了减少测试用例的数量。

基本安装

```python
pip install ddt
```

直接传递单个数据

unittest_12_参数化_基于ddt直接传递数据.py，代码：

```python
import unittest
from ddt import ddt, data

def add(a,b):
    return a+b

@ddt
class AddTest(unittest.TestCase):
    # # 单次传递一个数据到测试用例方法中
    # @data(100)
    # @data([1,2,3,4])
    # @data({"a":1,"b":2})
    # @data((1,2,3))

    # # 多次传递一个数据到测试用例方法中
    # @data(*["a","b","c"]) # 字符串
    # @data(*[{"a":1}, {"a":2}, {"a":3}]) # 字典
    # @data(*[[1, 1, 1], [1, 1, 2], [1, 1, 3]])
    @data([1, 1, 1], [1, 1, 2], [1, 1, 3])
    def test_01(self, a):
        print(a)


if __name__ == '__main__':
    unittest.main()
```

unittest_13_参数化-基于ddt解包传递多个数据.py，使用unpack装饰器解包数据

```python
import unittest
from ddt import ddt, data, unpack

def add(a, b, c):
    return a + b + c

@ddt
class AddTest(unittest.TestCase):
    @data((1,2,3),(1,2,1),(1,3,1),(1,1,3))
    @unpack
    def test_01(self,a,b,c):
        add(a,b,c)

if __name__ == '__main__':
    unittest.main()
```





## 单元测试框架-Pytest

Pytest是基于Python语言的单元测试框架，也是一个命令行的工具，比 unittest 测试框架更灵活。具有以下特点：

1.  入门简单，易上手，官方文档丰富而且使用广泛，有大量的参数例子。
2.  unittest有的，它都有，而且支持更为复杂的功能测试
3.  支持大量第三方插件，如：失败重试、控制用例执行顺序等。
4.  基于配置文件可以很简单的集成CI（持续集成）工具中。

安装

```python
pip install pytest
```



### 快速入门

#### 基本格式

pytest_01_基本格式.py，代码：

```python
def add(x, y):
    return x + y

class TestAddFunc(object):  # 测试用例类名必须用Test开头
    def test_01(self):   # 方法名与函数名必须要用test_开头
        print(add(10, 20))

    def test_02(self):
        print(add("a", "B"))

    def test_03(self):
        print(add("a", 20))
```

#### 测试运行

pytest提供了三种方式给测试人员执行测试用例：

+ **命令行运行**

  ```python
  pytest -s 文件名
  pytest -s -v 文件名
  # -s 输出测试用例的print语句打印的信息
  # -v 输出执行的测试用用例的类名以及方法名
  # -x 一旦发现失败用例，立即停止继续运行
  # -maxfail=2 当测试遇到2条失败用例，立即停止继续运行
  ```

  

+   Pycharm运行

    file -> settings，打开配置窗口。

    ![image-20220515134914741](assets/image-20220515134914741.png)

+   main函数运行（基本不用）

    ```python
    pytest.main(["模块文件名::类名::方法名", "参数"])
    pytest.main(["pytest_01_基本格式.py::TEstAddFunc::test_01", "-sv"])
    ```



#### 测试脚手架

方法级别：setup与teardown

类级别：setup_class与teardown_class，注意：这是实例方法，不是类方法

模块级别：setup_module与teardown_module

pytest_02_测试脚手架.py，代码：

```python
def add(x, y):
    return x + y


def setup_module():
    print("模块执行初始化操作")

def teardown_module():
    print("模块执行初始化putest")

class TestAddFunc(object):  # 测试用例类名必须用Test开头
    def setup(self):
        print('setup执行初始化操作')
    def teardown(self):
        print('teardown执销毁操作')

    def setup_class(self):    # 注意：此处方法类型是实例方法。
        print('类级别：setup_class执行初始化操作')

    def teardown_class(self):  # 注意：此处方法类型是实例方法。
        print('类级别：teardown_class执行初始化操作')



    def test_01(self):   # 方法名与函数名必须要用test_开头
        print(add(10, 20))

    def test_02(self):
        print(add("a", "B"))

    def test_03(self):
        print(add(20, 20))

```



#### 基于配置文件运行pytest

在pytest提供的终端运行测试用例的方式的基础上，pytest还支持使用配置文件来简化运行参数。

可以通过pytest --help 查看pytest配置文件的名：**pytest.ini**、tox.ini、**setup.cfg**。

配置文件一般保存在项目根目录下。

pytest.ini，配置文件格式：

```ini
; 命名空间，表示以下选项属于pytest配置
[pytest]
; 运行参数
addopts = -s -v
; 匹配搜索的测试文件的目录路径
testpaths = ./
; 匹配搜索的测试文件名格式
python_files = test_*.py
; 匹配搜索的测试类格式
python_classes = Test*
; 匹配搜索的测试方法名格式
python_functions = test_*
; markers
markers = "测试标记-一般就是本轮测试的项目名或者模块"
```

上面的注释，必须清除否则报错。有了配置文件以后，使用pytest命令即可运行测试用例。

```bash
pytest
```



#### 断言

Pytest的断言比unittest提供的断言更加简单易用，仅仅只需要使用assert关键字，后续跟上python原生的表达式即可。

```python
assert "m" in "moluo"
assert "m" not in "moluo"
assert 1 == 2
assert 1 != 1
assert 1 > 2
assert not True
assert type(1) is int
assert type(1) not is int
```

pytest_03_断言.py，代码：

```python
def add(x, y):
    return x + y


class TestAddFunc(object):  # 测试用例类名必须用Test开头
    def test_01(self):   # 方法名与函数名必须要用test_开头
        res = add(10, 20)
        assert res == 30

    def test_02(self):
        res = add("a", "B")
        assert type(res) is int

    def test_03(self):
        res = add(20, 20)
        assert res != 20
```



#### 跳过

根据特定的条件，不执行标识的测试函数。

```python
@pytest.mark.skipif(判断条件, reason="跳过原因")
```

pytest_04_跳过.py，代码：

```python
import pytest


def add(x, y):
    return x + y

version = (2, 7, 12)

class TestAddFunc(object):  # 测试用例类名必须用Test开头
    def test_01(self):   # 方法名与函数名必须要用test_开头
        res = add(10, 20)
        assert res == 30

    @pytest.mark.skipif(version <= (2, 7, 12), reason="高于2.7以下，不测试test_02")
    def test_02(self):
        res = add("a", "B")
        assert type(res) is int

    def test_03(self):
        res = add(20, 20)
        assert res != 20
```



#### 参数化

pytest也支持参数化操作，而且不需要安装任何第三方模块即可使用，也不再需要ddt。

```python
import pytest


def add(x, y):
    return x + y


class TestAddFunc(object):  # 测试用例类名必须用Test开头
    @pytest.mark.parametrize("x,y", [(10, 20), {"x":10, "y":20}, ("a", "b"), ("a", 20)])
    def test_01(self, x, y):   # 方法名与函数名必须要用test_开头
        res = add(x, y)
        assert res == 30
```



### 进阶使用

#### fixture-脚手架

在Unittest中我们经常需要针对不同的测试用例使用脚手架完成一些测试的前置与后置操作，但是很多测试用例的前置与后置操作基本一样，所以pytest提供的fixture脚手架相比Unittest提供的脚手架进行了显著改进：

1. 有独立的命名，并通过声明它们从测试函数、模块、类或整个项目中的使用来激活脚手架。
2. 也可以按模块化的方式实现，每个fixture脚手架都可以在各个测试用例之间互相调用。
3. fixture的范围从简单的单元测试到复杂的功能测试，可以对fixture配置参数，或者跨函数function，类class，模块module或整个测试项目范围session。

pytest的fixture有个scope参数可以控制fixture的作用范围（从大到小）：session>module>class>function。

```
session：是多个文件调用一次，可以跨.py文件调用，每个.py文件就是module
module：每一个.py文件调用一次，该文件内又有多个function和class
class：每一个类调用一次，一个类中可以有多个方法
function：每一个函数或方法都会调用
```

##### 实现参数化效果

```python
import pytest


# 类级别的脚手架
@pytest.fixture(scope="class")
def fixture_01_data():  # 建议脚手架的函数名以fixture开头.
    a = 10
    b = 20
    print("脚手架运行了!")
    return a, b  # 脚手架的函数可以有返回值，也可以没有返回值


# 被测试的代码单元
def add(x, y):
    return x + y


class TestAddFunc(object):
    def test_01(self, fixture_01_data):  # 此处的参数名，就是上面的脚手架名称，注意：参数名要与上面的脚手架函数保持一致
        print(f"fixture_01_data={fixture_01_data}")
        res = add(fixture_01_data[0], fixture_01_data[1])
        assert res == 30

```



##### 使用装饰器修饰用例实现参数化效果

```python
import pytest


@pytest.fixture(scope="class")
def fixture_01_data():
    print("fixture_01_data")
    a = 10
    b = 20
    return a, b

@pytest.fixture(scope="class")
def fixture_02_data():
    print("fixture_02_data")
    a = "10"
    b = "20"
    return a, b


def add(x, y):
    return x + y


@pytest.mark.usefixtures("fixture_01_data")  #  此处参数为脚手架函数名
@pytest.mark.usefixtures("fixture_02_data")
class TestAddFunc(object):
    def test_01(self, fixture_01_data):
        res = add(fixture_01_data[0], fixture_01_data[1])
        assert res == 30

    def test_02(self, fixture_02_data):
        res = add(fixture_02_data[0], fixture_02_data[1])
        assert res == 30

```



##### fixture自动执行

fixture提供了autouse=True的参数选项，让我们可以不需要装饰，就可以直接自动执行。

代码：

```python
import pytest


@pytest.fixture(scope="class", autouse=True)
def fixture_01_data():
    print("fixture_01_data")
    a = 10
    b = 20
    return a, b


@pytest.fixture(scope="class", autouse=True)
def fixture_02_data():
    print("fixture_02_data")
    a = "10"
    b = "20"
    return a, b


def add(x, y):
    return x + y

@pytest.mark.usefixtures("fixture_01_data")  #  此处参数为脚手架函数名
@pytest.mark.usefixtures("fixture_02_data")
class TestAddFunc(object):
    def test_01(self, fixture_01_data):
        res = add(fixture_01_data[0], fixture_01_data[1])
        assert res == 30

    def test_02(self, fixture_02_data):
        res = add(fixture_02_data[0], fixture_02_data[1])
        assert res == 30
```



##### 使用yield实现setup/teardown效果

pytest的fixture不仅可以在单元测试、集成测试中被广泛使用，甚至在UI测试或系统测试中也会经常用到，针对UI测试或系统测试中的功能测流或流程测试，总是经常需要打开相关环境，例如：web项目进行UI测试，每次都会需要打开浏览器或关闭浏览器等前置或后置的操作的。

代码：

```python
import pytest


@pytest.fixture(scope="class", autouse=True)
def fixture_open_browser():
    print("打开浏览器")  # 相当于setup
    yield "xiaoming", "123456"
    # 生成器函数中的暂停关键字，作用是当代码运行到yield时，把yield右边的数据作为返回值提供给调用处，把代码执行权交出去。
    print("关闭浏览器")  # 相当于teardown


class TestUser(object): # object是一个基类，python中所有的类都是默认继承于object的。
    def test_01(self, fixture_open_browser):
        print(f"fixture_open_browser={fixture_open_browser}")
        print("注册流程，测试用户是否能注册成功")

    def test_02(self, fixture_open_browser):
        print(f"fixture_open_browser={fixture_open_browser}")
        print("登陆流程，测试用户是否能登陆成功")

```



##### 单独存放fixture代码

我们还可以基于fixture脚手架把代码提前写好，放在在一个pytest能自动识别的conftest.py文件中，这样可以有效避免出现重复的fixture代码。注意：conftest.py的文件名必须固定，而且里面只存放fixture代码，并保证该文件与被测试代码文件在同一目录即可。

conftest.py，代码：

```python
import pytest


@pytest.fixture(scope="class", autouse=True)
def fixture_open_browser():
    print("打开浏览器")  # 相当于setup
    yield "xiaoming", "123456"
    # 生成器函数中的暂停关键字，作用是当代码运行到yield时，把yield右边的数据作为返回值提供给调用处，把代码执行权交出去。
    print("关闭浏览器")  # 相当于teardown

```

5-单独存放fixture代码.py，代码：

```python
class TestUser(object):
    def test_01(self, fixture_open_browser):
        print(f"fixture_open_browser={fixture_open_browser}")
        print("注册流程，测试用户是否能注册成功")

    def test_02(self, fixture_open_browser):
        print(f"fixture_open_browser={fixture_open_browser}")
        print("登陆流程，测试用户是否能登陆成功")
```



#### 第三方常用组件

##### 控制测试用例执行顺序

unittest执行测试用例的默认顺序是根据测试用例方法名的ASCII码排序[0-9A-Za-z]而定的，值越小，越靠前执行。

pytest执行测试用例的默认顺序是根据测试方法的源代码上下顺序来排序的。

而如果在完成接口测试或集成测试时，我们要控制测试用例的执行顺序，可以通过pytest的第三方模块pytest-ordering来实现。

安装

```python
pip install pytest-ordering
```

使用

```python
class TestAdd(object):
    @pytest.mark.run(order=n)  # n表示执行顺序，可以是正负整数。
    def test_测试方法名(self):
        pass
# 执行顺序为优先执行正数排序的方法，接着到没有排序的方法，最后是负数排序的方法。
# 如果多个方法都是正数，则先执行排序值小的，同理如果多个方法都是负数，也是一样先执行排序值小的。
```

pytest-ordering.py组件的使用，代码：

```python
"""
前置步骤，安装插件：
pip install pytest-ordering
"""
import pytest


class TestAdd(object):

    @pytest.mark.run(order=-1)
    def test_01(self):
        print(f"test_01执行了，order=-1")

    @pytest.mark.run(order=-10)
    def test_02(self):
        print(f"test_02执行了，order=-10")

    @pytest.mark.run(order=10)
    def test_03(self):
        print(f"test_03执行了，order=10")

    @pytest.mark.run(order=3)
    def test_04(self):
        print(f"test_04执行了，order=3")

    def test_05(self):
        print(f"test_05执行了，没有指定排序值")

    def test_06(self):
        print(f"test_06执行了，没有指定排序值")

"""
多个方法排序值为正整数的情况：以小为先
test_04
test_03
没有排序值的情况下，源代码中先写的先执行，后写的后执行：先写为先
test_05
test_06
多个方法排序值为负整数的情况：以小为先
test_02
test_01
"""
```

pytest-ordering用于解决测试开发中，UI测试、系统测试、接口测试等多个测试用例有先后流程的场景。

例如，系统测试的购物车流程：

1. 先访问商品详情页
2. 添加商品购物车
3. 点击购物车的结算
4. 填写或选择发货地址
5. 确定支付

注意：pytest-ordering组件如果和参数化fixtrue脚手架一起使用会导致参数解析错误，所以不能一起使用。因此pytest-ordering使用时，如果需要对测试用例实现参数化，则可以使用pytest.mark.parametrize，注意：不能使用ddt。



##### 失败用例重试

针对网络场景或服务端性能不稳定的情况下，进行测试时经常遇到用例运行失败的情况，特别在性能测试方面，此时我们可以让失败用例重试指定次数，以达到测试的更准确的结果。

安装

```python
pip install pytest-rerunfailures -i http://pypi.douban.com/simple/
    
# pip freeze | findstr rerunfailures # windows系统
# pip freeze | grep rerunfailures    # mac OS X 或 linux、Windows10以上
```

使用

```python
安装 pytest-rerunfailures 插件到本地以后，在pytest运行参数中会新增选项：
--reruns n (n为正整数，表示重试n次)
--reruns-delay m (m为正整数，表示重试的间隔时间为m秒)
```

###### 全局失败用例重试

全局失败用例重试.py，代码

```python
import random

def add(x, y):
    return x + y


class TestAdd(object):
    def test_01(self):
        res = add(10, 20)
        assert res is 30

    def test_02(self):
        ret = random.randint(1, 3)
        assert ret % 2 == 0

```

配置文件pytest.ini，代码：

```ini
[pytest]
addopts =--reruns 3 --reruns-delay 2 -s -v
testpaths = ./
python_files = test_*.py
python_classes = Test*
python_functions = test_*

```

###### 局部失败用例重试

局部失败用例重试.py，代码：

```python
import random
import pytest

def add(x, y):
    return x + y


class TestAdd(object):
    def test_01(self):
        res = add(10, 20)
        assert res is 30

    # 只设置当前测试用例方法失败重试
    @pytest.mark.flaky(reruns=3, reruns_delay=2)
    def test_02(self):
        ret = random.randint(1, 3)
        assert ret % 2 == 0
```

注意：

1. **局部重试参数会覆盖全局重试参数**，也就是说，当使用了局部用法，全局用法就失效了。
2. 与pytest.fixture脚手架也会存在参数解释冲突问题，所以使用了失败重试就不要使用pytest.fixture。



##### 并发运行测试用例

当测试用例非常多的时候，一条条按顺序执行测试用例，是很浪费测试时间的。此时如果测试用例之间没有先后运行的依赖关系，可以完全独立运行的情况下，我们也可以并发运行测试用例，让自动化测试用例可以分布式执行，从而大大节省测试时间。pytest-xdist 就可以完成我们上面希望的并发执行测试用例的效果，它是属于进程级别的并发。

安装

```bash
pip install pytest-xdist
```

使用

pytest-xdist安装以后，pytest会新增一个参数-n，可以让我们指定本次运行测试所开启的进程数量。

参数设置如下：

```python
pytest -s -v -n 4  # 使用4个进程运行，也可以改成auto
pytest -s -v -n auto  # 自动检测系统的CPU核数，并根据CPU核算创建对应数量的进程数量
```

pytest.ini，代码：

```ini
[pytest]
addopts =-s -v -n auto
testpaths = ./
python_files = test_*.py
python_classes = Test*
python_functions = test_*
```



代码：

```python
def add(x, y):
    return x + y


class TestAdd(object):
    def test_01(self):
        res = add(10, 20)
        assert res is 30

    def test_02(self):
        res = add("10", "20")
        assert res == "1020"

    def test_03(self):
        res = add("10", "20")
        assert res == "1020"

    def test_04(self):
        res = add("10", "20")
        assert res == "1020"

    def test_05(self):
        res = add("10", "20")
        assert res == "1020"

    def test_06(self):
        res = add("10", "20")
        assert res == "1020"
```



#### 生成HTML格式测试报告[了解下即可]

安装

```python
pip install pytest-html
```

使用

```python
安装插件到本地以后，在pytest运行参数中会新增选项：--html=report.html
```

生成HTML格式测试报告.py，代码

```python
import random
import pytest

def add(x, y):
    return x + y


class TestAdd(object):
    def test_01(self):
        res = add(10, 20)
        assert res is 30

    # 只设置当前测试用例方法失败重试
    @pytest.mark.flaky(reruns=3, reruns_delay=2)
    def test_02(self):
        ret = random.randint(1, 3)
        assert ret % 2 == 0
```

pytest.ini，代码：

```python
[pytest]
addopts =-s -v --html=report.html
testpaths = ./
python_files = test_*.py
python_classes = Test*
python_functions = test_*
```



## Allure

**Allure** 是一款轻量级的开源自动化测试报告生成框架，Java语言开发出来的。它支持绝大部分测试框架，比如 pytest、unittest 等。比起上面那些丑陋的测试报告生成，Allure是最漂亮的，而且还可以配合pytest与Jenkins实现CI持续集成。pytest+Allure+git+pycharm+Jenkins+gitlab/gitee/github= CI持续集成

官方文档：https://docs.qameta.io/allure/#_get_started

### 安装

#### 安装java环境

Allure的运行起来需要依赖于java环境，此处下载安装jdk1.8环境（Java 8）。

java的jdk1.8下载地址：https://www.java.com/zh-CN/download/

此处我们演示windows下的java环境安装。

鼠标右键点选下载到本地的java的jdk安装包，选择以"管理员身份运行"，窗口如下，勾选窗口左下角的"
更改目标文件夹"，点击"安装"，进入下一步。

![image-20220618201926856](assets/image-20220618201926856.png)

![image-20220618201948408](assets/image-20220618201948408.png)

默认情况下，java的jdk会选择在C盘的"Program Files"目录下安装，如果不想要在此目录安装，则可以点击更改，如果无所谓，则点击"下一步"即可。建议修改“Program Files”之前的路径，后半段保持原样。

![image-20220618202006796](assets/image-20220618202006796.png)

![image-20220618202031884](assets/image-20220618202031884.png)

jre与jdk同样保存在一个父目录下即可。

![image-20220618202048101](assets/image-20220618202048101.png)

OK，接下来，喝杯茶，等待一会即可。

![image-20220618202141055](assets/image-20220618202141055.png)

效果如下，则没有问题。

![image-20220618202151445](assets/image-20220618202151445.png)

注意：如果是在windows以外的操作系统中安装java环境，则需要单独在终端下配置java环境变量。

#### 安装Allure命令行工具

```bash
# windows10系统打开powershell来安装，不能使用cmd
# 安装Allure可以借助第三方包管理器scoop，scoop用于提供给开发人员安装各种开发软件到windows系统的
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
y
iwr -useb https://gitee.com/RubyKids/scoop-cn/raw/master/install.ps1 | iex
# https://scoop.sh/#/apps?q=allure&s=0&d=1&o=true
scoop bucket add main
scoop install allure

# # Ubuntu系统使用apt-get包管理器
# sudo apt install -y openjdk-8-jdk
# sudo apt-add-repository ppa:qameta/allure
# sudo apt-get update 
# sudo apt-get install allure

# # Mac OS X系统使用brew包管理器
# brew install openjdk
# brew install allure
```

接下来，我们重新打开一个**新的命令行窗口**，输入"allure"，显示如下即表示allure命令行工具安装正确。

![image-20220522081917552](assets/image-20220522081917552.png)

#### 安装pytest-allure集成模块

接下来，只需要安装allure集成到pytest的pytest-allure集成模块即可。

```bash
pip install allure-pytest
```



### 基本使用

生成allure测试结果，结果以json文件格式保存在--alluredir选项指定的目录下。

pytest.ini，代码：

```bash
[pytest]
addopts =-s -v --alluredir=./results
testpaths = ./
python_files = test_*.py
python_classes = Test*
python_functions = test_*
```

基于json报告结果使用浏览器展示allure测试结果报告

```python
allure serve ./results
```

**生成HTML格式文档的测试报告**

HTML格式文档的测试报告也是要基于上面的json文件格式的测试结果才能生成的。

```bash
# 必须先生成json格式的测试报告，才能生成HTML格式的测试报告
allure generate ./results -o ./reports --clean

```

基于json格式的报告生成HTML报告，代码：

```python
import os
import random
import pytest
import shutil

def add(x, y):
    return x + y


class TestAdd(object):
    def test_01(self):
        res = add(10, 20)
        assert res is 30

    # 只设置当前测试用例方法失败重试
    @pytest.mark.flaky(reruns=3, reruns_delay=2)
    def test_02(self):
        ret = random.randint(1, 3)
        assert ret % 2 == 0

    def test_03(self):
        ret = random.randint(1, 3)
        assert ret % 2 == 0

if __name__ == '__main__':
    # 先删除旧的测试报告
    try:
        shutil.rmtree("./results")
        shutil.rmtree("./resports")
    except:
        pass
    # 运行pytest执行测试测试用例，并生成json测试报告
    pytest.main()
    # 基于os.system执行终端名，生成HTML格式文档的测试报告
    os.system("allure generate ./results -o ./reports --clean")
```

注意：生成的报告，只能通过http协议访问，不能直接在硬盘双击点击打开（这种方式是基于本地文件协议file访问文件）。



### 常用方法

| 方法                                                         | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **@allure.testcase(url, name=None)**                         | 设置测试用例的站点访问地址                                   |
| **@allure.issue(url, name=None)**                            | 设置测试用例的站点的缺陷管理地址                             |
| **@allure.feature(*features)**                               | 设置测试用例的模块名称                                       |
| **@allure.severity(severity_level)**                         | 设置测试用例的优先级，allure对测试用例的优先级划分成五个等级（allure.severity_level），值为：<br>CRITICAL（严重缺陷），NORMAL（普通缺陷），MINOR（较小缺陷），TRIVIAL（不重要缺陷），BLOCKER(阻塞缺陷)。 默认值为NORMAL。 |
| **@allure.title(test_title)**                                | 设置测试用例的标题名称                                       |
| @allure.description(test_description)                        | 设置测试用例的详细描述（纯文本）                             |
| **@allure.description_html(test_description_html)**          | 设置测试用例的详细描述（HTML文本）                           |
| **@allure.link(url, link_type=LinkType.LINK, name=None)**    | 设置指定测试用例的缺陷访问地址                               |
| **allure.step(title)**                                       | 设置测试用例执行过程中的步骤信息                             |
| allure.attach(body, name=None, attachment_type=None, extension=None) | 设置测试用例的文本附件信息，allure.attachment_type的常见文本附件类型支持：TEXT，SVG，HTML，JSON，YAML，CSV。<br>添加文本格式：allure.attach("HTML代码", "文件标题", allure.attachment_type.HTML) |
| allure.attach.file(source, name=None, attachment_type=None, extension=None) | 设置测试用例的文件附件信息，支持的类型参考上方使用。<br>allure.attachment_type的常见文本附件类型支持：PNG，GIF，JPG，PDF。添加二进制格式：allure.attach.file("文件路径", "文件名", attachment_type=allure.attachment_type.PNG) |

代码：

```python
import os
import random
import pytest
import shutil
import allure
from allure_commons.types import LinkType


def add(x, y):
    return x + y


@allure.testcase("http://www.luffycity.com", "测试地址站点的首页地址")
@allure.issue("http://www.luffycity.com", "软件缺陷的管理站点的首页地址")
class TestAdd(object):
    @allure.feature("测试用例模块的描述: 购物车模块，用户模块")
    @allure.story("测试用例的分类描述")
    @allure.title("测试用例test_01的标题描述")
    @allure.description("测试用例test_01的详细描述")
    @allure.severity(allure.severity_level.MINOR)  # 较小缺陷等级的用例，如果不设置这个，默认是NORMAL普通缺陷等级的用例
    def test_01(self):
        res = add(10, 20)
        assert res == 30

    @allure.feature("测试用例模块的描述: 购物车模块，用户模块")
    @allure.story("测试用例的分类描述")
    @allure.title("测试用例test_02的标题描述")
    # @allure.description("测试用例test_02的详细描述")    # 纯文本描述
    @allure.description_html("<b style='color: red;'>测试用例test_02的详细描述</b>")  # HTML文本描述
    @allure.severity(allure.severity_level.BLOCKER)  # 阻塞缺陷等级的用例
    @allure.link("http://test.luffycity.com/test_02", link_type=LinkType.LINK, name="测试用例：02")

    # 只设置当前测试用例方法失败重试
    @pytest.mark.flaky(reruns=3, reruns_delay=2)
    def test_02(self):
        # 注意是使用with上下文管理器语句
        with allure.step("步骤1：内容描述"):
            result = 1+1

        with allure.step("步骤2：内容描述"):
            result +=1

        print(f"测试结果是：{result}")
        assert result == 3

    @allure.feature("测试用例模块的描述: 购物车模块，用户模块")
    @allure.story("测试用例的分类2描述")
    @allure.title("测试用例test_03的标题描述")
    @allure.description("测试用例test_03的详细描述")
    @allure.severity(allure.severity_level.CRITICAL)  # 致命缺陷等级的用例
    def test_03(self):
        # 图片附件
        allure.attach.file("./images/demo.jpg", 'demo.jpg', allure.attachment_type.JPG)
        # 文本附件
        allure.attach("""<h1>Test with some complicated html description</h1>
<table style="width:100%">
  <tr>
    <th>Firstname</th>
    <th>Lastname</th>
    <th>Age</th>
  </tr>
  <tr align="center">
    <td>William</td>
    <td>Smith</td>
    <td>50</td>
  </tr>
  <tr align="center">
    <td>Vasya</td>
    <td>Jackson</td>
    <td>94</td>
  </tr>
</table>""", "Test with some complicated html attachment", allure.attachment_type.HTML)

        ret = random.randint(1, 3)
        assert ret % 2 == 0

# __name__ 是一个魔术变量，在当前文本被python解释器作为主程序运行是，值固定就是 "__main__"，
# 如果当前文件作为模块被其他文件导包使用，则__name__的值，则为当前文件名或者其他的自定义名称，总之不是 "__main__"了。
if __name__ == '__main__':
    try:
        # 删除之前的测试结果与测试文件目录内容
        shutil.rmtree("reports")
        shutil.rmtree("results")
    except:
        pass
    pytest.main(["-sv", "main.py", "--alluredir", "./results"])
    # 生成报告html文件
    os.system('allure generate ./results -o ./reports --clean')
    # 基于http协议打开HTML测试报告
    os.system('allure open ./reports')
```

测试运行，使用终端

```bash
python main.py
```

# 接口自动化测试

基于pytest和allure构建接口自动化测试框架构与项目。

## 框架目录结构

我们要构建一个自动化测试框架，就要以项目的概念来对项目中所有的代码文件进行划分目录和文件结构，不同的代码功能不一样，所以我们需要设计一个合理的目录结构，以方便与测试开发团队的其他人员进行测试功能的开发与测试，也方便将来的项目代码维护。

```bash
根目录/
 ├─ config.py    # 项目代码配置文件
 ├─ pytest.ini    # pytest模块配置文件
 ├─ main.py      # 主程序，执行入口
 ├─ api/         # 封装被测试项目的api接口存放目录[用于mock测试、冒烟测试]
 ├─ data/        # 测试数据/测试用例的存放目录
 ├─ results/     # 测试报告结果生成目录
 ├─ reports/     # HTML测试报告生成目录
 ├─ tests/       # 测试用例脚本存放目录
 ├─ libs/         # 第三方工具类的存放目录[开源模块，不是当前项目封装的模块]
 └─ utils/        # 自定义工具类的存放目录[当前项目自己封装的模块]
```

配置文件，config.py，代码：

```python
import pathlib  # 路径操作模块，替代 os.path模块，os.path采用字符串来操作路径，pathlib采用面向对象来操作路径

# 项目目录的主目录路径[字符串路徑]
BASE_DIR_STR = pathlib.Path(__file__).parent.resolve().as_posix()  # 基本操作系统转换路径的分隔符 as_posix
# 項目目录的主目录路径[路径对象]
BASE_DIR = pathlib.Path(BASE_DIR_STR)

# 项目名
WEB_NAME = "路飞自动化接口测试框架"

# 测试自动化项目的运行端口与IP地址
HOST = "127.0.0.1"
PORT = 8088

```

入口文件，main.py，代码：

```python
import pytest
import os
import sys

import config

if __name__ == '__main__':
    os.system(f"rd /s /q results")
    os.system(f"rd /s /q reports")

    # 让python解释器，追加3个项目中的核心目录为导包路径
    sys.path.insert(0, str(config.BASE_DIR / "api"))
    sys.path.insert(0, str(config.BASE_DIR / "tests"))
    sys.path.insert(0, str(config.BASE_DIR / "utils"))

    # 启动pytest框架
    pytest.main()

    # 生成报告html文件
    os.system('allure generate ./results -o ./reports')

    # 基于http协议打开HTML测试报告
    os.system(f'allure open ./reports -h {config.HOST} -p {config.PORT}')

```

在根目录下创建pytest配置文件pytest.ini，内容如下：

```ini
[pytest]
addopts =-s -v --alluredir=./results
testpaths = ./
python_files = test_*.py
python_classes = Test*
python_functions = test_*
```

OK，完成了上面操作以后，我们就可以写一个测试用例来测试下现在我们的基本框架是否能正常运行了。

`tests/users/test_login.py`，代码：

```python
import allure
import config


@allure.epic(config.WEB_NAME)
@allure.feature("用户模块")
@allure.story("登录")
class TestLogin(object):
    @allure.severity(allure.severity_level.CRITICAL)
    def test_username_by_empty(self,):
        allure.dynamic.title("用户名为空，登陆失败")
        allure.dynamic.description("测试用户名为空的登陆结果")
        allure.attach('附件内容', '附件名字')

    def test_password_by_empty(self,):
        allure.dynamic.title("密码为空，登陆失败")
        allure.dynamic.description("测试密码为空的登陆结果")
        allure.attach('附件内容', '附件名字')
```

运行框架，效果：

![image-20220611101450834](assets/image-20220611101450834.png)

当然自动化接口框架的构建开发过程肯定不是一夜之间就能完成的，所以我们需要长期构建，不断完善的准备。所以需要使用git代码版本管理工具把代码推送到git仓库中进行代码版本的管理（在企业中一般我们会使用公司内部构建的gitlab平台来管理内部项目，但现在我们处于学习阶段，所以可以先把代码提交到[gitee码云](https://gitee.com/)上）。

## 代码托管

注意：公司内部的代码不要私自自己往gitee（码云），github去推。

gitee官网地址：https://gitee.com/

### 准备工作

需要提前在当前开发机子上安装git代码版本管理工具。

windows下载地址：https://git-scm.com/



### 创建仓库

![image-20220529061911628](assets/image-20220529061911628.png)

我们是学习，所以我这创建项目库名luffytest。项目库名建议是英文的。

![image-20220529062141957](assets/image-20220529062141957.png)

选择git-flow自定义分支模型。

![image-20220327031446181](assets/image-20220327031446181.png)

所谓的分支，其实就是一个项目的代码的不同流程版本。

![image-20220327035313097](assets/image-20220327035313097.png)

git-flow分支命名规范：

| 分支前缀 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| master   | 生产环境分支，将来可以部署到生产环境（公司的外网服务器）的代码 |
| release  | 预发布环境分支，将来可以部署到预发布环境的代码，也可以是rel  |
| develop  | 开发环境分支，也可以是dev                                    |
| feature  | 新功能，新增业务分支，也可以是feat                           |
| hotfix   | 修复bug问题、漏洞分支，也可以是fix                           |
| test     | 测试相关分支                                                 |

补充说明：

```bash
release/feature/xxx   # 表示待发布分支下的xxx业务功能相关代码
develop/feature/xxx   # 表示开发分支下的xxx业务的新功能代码
develop/test/xxx      # 表示开发分支下的正在测试的xxx业务功能的代码
develop/hotfix/xxx    # 表示开发分支下的修复xxx业务相关功能的bug

# 当然，分支名称并不是固定的，只要能让开发人员一目了然，名字都可以换，所以也可以这样：
release/xxx   # 表示待发布的xxx业务新功能代码
feature/xxx   # 表示正在开发的xxx业务功能代码
test/xxx      # 表示正在测试的xxx业务功能代码
hotfix/user   # 表示正在修复bug的xxx业务功能的代码
```

创建私有空仓库以后的界面：

![image-20220529062535656](assets/image-20220529062535656.png)



#### 免密提交代码

接下来，我们可以使用ssh连接远程的git仓库，需要先在本地电脑下生成ssh秘钥对。

```python
# 例如我的码云账号是 649641514@qq.com，那么该账号生成ssh秘钥对（基于rsa加密算法生成的秘钥对，公钥和私钥）
ssh-keygen -t rsa -C "649641514@qq.com"
```

![image-20220611103038268](assets/image-20220611103038268.png)

复制终端下出现的公钥信息，复制到码云上面。

```bash
# 查看生成的秘钥对中的公钥（私钥id_rsa保存在自己电脑不要乱动，公钥id_rsa.pub需要复制文件内容到码云平台）
cat C:\Users\Administrator/.ssh/id_rsa.pub
# 把公钥进行复制到码云平台上 https://gitee.com/profile/sshkeys
```

![image-20220611103112560](assets/image-20220611103112560.png)

在浏览器打开https://gitee.com/profile/sshkeys，保存公钥。

![image-20220327040326605](assets/image-20220327040326605.png)

切换项目的仓库地址，设置线上仓库

```bash
git config --global user.name "mooluo"
git config --global user.email "649641514@qq.com"

# 在项目根目录下初始化git仓库
cd luffytest/  # 具体的路径根据自己的设置而定
git init

# git remote remove origin # 删除仓库地址，origin可以理解是一个变量，因为当前时一个新仓库，所以不需要执行这段。
git remote add origin git@gitee.com:mooluo_admin/luffytest.git # 新仓库地址，等同于origin= git..../luffycity.git
```

分支管理，git提交代码版本并同步到远程服务器。

```bash
git branch    # 查看分支
# 刚执行git init 初始化时，会没有分支，因此我们需要进行第一次的代码提交。

git add .
git commit -m "feature: 项目初始化"
# 经过上面的命令操作，本地的git就会自动生成一个master分支

# git branch <分支名称>    # 新建分支
# git branch test         # 例如：创建一个test分支

# git checkout <分支名称>  # 切换分支
# git checkout test       # 例如：切换到test分支，检出分支代码

# git branch -d <分支名称>   # 删除分支
# git branch -d test

# git push <远程仓库别名> --delete <分支名称>    # 删除远程服务器分支
# git push origin --delete test  # 例如：删除远程仓库origin中的test

# 推送代码记录到远程服务器的代码仓库
git push origin master # 推送的过程中，如果本地有该分支，但是线上没有这个分支，则git会自动在远程中创建该分支，默认的空仓库是一个分支都没有的。
```

使用`.gitignore`可以在git上传或下载代码时，把一些不必要记录的垃圾文件/目录过滤掉。

注意：必须保证.git目录 和.gitignore在同一级目录下，才能生效。

![image-20220611104441754](assets/image-20220611104441754.png)

.gitignore编写参考地址：https://github.com/github/gitignore

.gitignore文件内容：

```.gitignore
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
.idea/

# vue https://github.com/vuejs/vue/blob/dev/.gitignore
.DS_Store
node_modules
*.log
explorations
TODOs.md
dist/*.gz
dist/*.map
dist/vue.common.min.js
test/e2e/reports
test/e2e/screenshots
coverage
RELEASE_NOTE*.md
dist/*.js
packages/vue-server-renderer/basic.js
packages/vue-server-renderer/build.js
packages/vue-server-renderer/server-plugin.js
packages/vue-server-renderer/client-plugin.js
packages/vue-template-compiler/build.js
.vscode

# luffytest
reports/*
results/*
logs/*
```

记录并保存.gitignore到git中

```bash
git add .
git commit -m "feature: 新建.gitignore忽略文件"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```

git commit 提交版本的描述信息，编写前缀规范：

| 描述前缀  | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| feature:  | 本次提交的代码用于开发新功能，新增业务                       |
| fix:      | 本次提交的代码用于修复bug问题、漏洞                          |
| docs:     | 本次提交的代码用于修改文档，注释等相关                       |
| style:    | 本次提交的代码用于修改代码格式，不影响代码逻辑，常见的代码规范：PEP8，PEP484 |
| refactor: | 本次提交的代码用于项目/代码重构，理论上不影响现有功能(针对代码的重写，改造原来的模块/类/函数/方法) |
| perf:     | 本次提交的代码用于提升性能，代码优化                         |
| test:     | 本次提交的代码用于增加或修改测试用例代码                     |
| deps:     | 本次提交的代码用于升级项目依赖（更新依赖模块）               |

最终，成功提交了代码版本到gitee平台。



## 新增日志功能

针对的项目开发，将来肯定需要把测试框架这个项目保存公司的服务器的，所以如果项目在公司服务器报错了，我们有可能不在场，或者其他同时去运作，那么我们针对当前这个项目在这个运行期间，有没有出现异常，那就需要记录整个项目的运行信息。

config.py，新增如下日志配置代码，代码：

```python
import pathlib  # 路径操作模块，替代 os.path模块，os.path采用字符串来操作路径，pathlib采用面向对象来操作路径

# 项目目录的主目录路径[字符串路徑]
BASE_DIR_STR = pathlib.Path(__file__).parent.resolve().as_posix()  # 基本操作系统转换路径的分隔符 as_posix
# 項目目录的主目录路径[路径对象]
BASE_DIR = pathlib.Path(BASE_DIR_STR)

# 项目名
WEB_NAME = "路飞自动化接口测试框架-master"

# 测试自动化项目的运行端口与IP地址
HOST = "127.0.0.1"
PORT = 8088

"""日志配置"""
LOGGING = {
    "name": "luffytest",  # 日志处理器的名称，一般使用当前项目名作为名称
    "filename": (BASE_DIR / "logs/luffytest.log").as_posix(),  # 日志文件存储路径，注意，一定要在项目根目录下手动创建logs目录
    "charset": "utf-8",  # 日志内容的编码格式
    "backup_count": 31,  # 日志文件的备份数量
    "when": "d",   # 日志文件的创建间隔事件,m 表示每分钟创建1个，h表示每小时创建1个，d表示每天创建1个，m0~m6表示每周星期日~星期六创建1个，midnight表示每日凌晨
}

```

在项目根目录下创建logs目录，并编写日志工具类，utils/logger.py，代码：

```python
import logging
import logging.handlers
import config


class LogHandle(object):
    """日志处理工具类"""

    def __init__(self, name=None, filename=None):
        self.name = config.LOGGING.get("name", "pytest")
        if name:
            self.name = name

        self.filename = config.LOGGING.get("filename", None)
        if filename:
            self.filename = filename

        self.charset = config.LOGGING.get("charset", "utf-8")
        self.log_backup_count = config.LOGGING.get("backup_count", 31)
        self.when = config.LOGGING.get("when", "d")

    def get_logger(self):
        # 创建logger，如果参数name表示日志器对象名，name为空则返回root logger
        logger = logging.getLogger(self.name)
        # 务必设置一个初始化的日志等级
        logger.setLevel(logging.DEBUG)
        # 这里进行判断，如果logger.handlers列表为空则添加，否则多次调用log日志函数会重复添加
        if not logger.handlers:
            # 创建handler
            fh = logging.handlers.TimedRotatingFileHandler(
                filename=self.filename,
                when=self.when,
                backupCount=self.log_backup_count,
                encoding=self.charset
            )
            sh = logging.StreamHandler()

            # 单独设置logger日志等级
            fh.setLevel(logging.INFO)
            # 设置输出日志格式
            simple_formatter = logging.Formatter(
                fmt="{levelname} {name} {module}:{lineno} {message}",
                style="{"
            )
            verbose_formatter = logging.Formatter(
                fmt="{levelname} {asctime} {name} {pathname}:{lineno} {message}",
                datefmt="%Y/%m/%d %H:%M:%S",
                style="{"
            )

            # 为handler指定输出格式
            fh.setFormatter(verbose_formatter)
            sh.setFormatter(simple_formatter)
            # 为logger添加的日志处理器
            logger.addHandler(fh)
            logger.addHandler(sh)

        return logger  # 直接返回logger

if __name__ == '__main__':
    from datetime import datetime

    log = LogHandle()
    log.filename = "../logs/pytest.log"
    logger = log.get_logger()
    logger.debug("日期测试")
    logger.info("普通日志")
    logger.warning("警告日志")
    logger.error("错误日志")
    logger.fatal("致命错误信息")

```

在测试用例中简单使用，`tests/users/test_login.py`，代码：

```python
import allure
from logger import LogHandle


@allure.epic(config.WEB_NAME)
@allure.feature("用户模块")
@allure.story("登录")
class TestLogin(object):
    def test_username_by_empty(self,):
        logger = LogHandle().get_logger()
        logger.debug("debug")
        logger.info("运行日志-info")
        logger.warning("warning")
        logger.error("error")
        logger.critical("critical")

        allure.attach('附件内容', '附件名字')

    def test_login(self,):
        allure.attach('附件内容', '附件名字')
```

提交代码版本，代码：

```bash
git add .
git commit -m "feature: 新增日志功能"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



## 实现接口自定义测试

#### 封装请求工具

接口测试肯定离不开http网络请求，在工作中python开发常用的http网络请求模块有：urllib，requests、httpx与aiohttp。

其中我们作为测试开发，比较常用的就是requests模块了。

Requests 是一个⽤Python编写，基于urllib的开源HTTP网络请求工具第三方库。它⽐python内置的urllib模块使用更加简单⽅便，可以节约我们⼤量的⼯作，完全满⾜HTTP测试需求。

##### requests快速使用

###### 安装

```bash
pip install requests
```

######  GET请求

发送无参数的GET请求

`demo/demo_requests.py`，代码：

```python
import requests

response = requests.get('http://httpbin.org/get')
print(response.content)  # 获取原生内容
print(response.text)   # 获取文本内容
```

发送有参数的GET请求

```python
import requests

params = {
    'name': 'moluo',
    'age': 18
}
response = requests.get("http://httpbin.org/get?sex=1", params=params)
print(response.text)

```



###### 接收数据

接收文本格式数据

```python
import requests
 
params = {
 'name': 'moluo',
 'age': 18
}
response = requests.get("http://httpbin.org/get", params=params)
print(response.text)
```

接受json格式数据

```python
import requests
import json

response = requests.get("http://httpbin.org/get")
# 方式I：
print(json.loads(response.text))
# 方式2：
print(response.json())
```

接受二进制格式数据

```python
import requests

response = requests.get("http://httpbin.org/image/png")
with open("1.png", "wb") as f:
    f.write(response.content)

```



###### POST请求

发送表单数据

```python
import requests

body = {'name': 'moluo', 'age': '22'}
response = requests.post("http://httpbin.org/post", data=body)
print(response.text)

```

发送json数据

```python
import requests

data = {'name': 'moluo', 'age': '22'}
response = requests.post("http://httpbin.org/post", json=data)
print(response.text)

```

文件上传

```python
import requests

# 支持上传一张或多张图片
files = {'avatar': open('1.png', 'rb')}
response = requests.post("http://httpbin.org/post", files=files)
print(response.text)
```



###### 发送请求头

```python
import requests

headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36'
}

response = requests.get("https://www.zhihu.com/explore", headers=headers)
print(response.text)

```



###### 代理IP

```python
import requests
# https://www.beesproxy.com/free
proxies = {
    # "http": "http://112.6.117.135:8085",
    "http": "http://223.68.190.136:9091",
}
req = requests.get('http://icanhazip.com/', proxies=proxies)
print(req.text)

```



###### 会话保持

提取Cookie

```python
import requests

r = requests.get('https://www.baidu.com')
print(r.cookies)
print(r.cookies['BDORZ'])
print(tuple(r.cookies))
```

发送Cookie

```python
import requests

url = 'http://httpbin.org/cookies'
cookies = {'testCookies_1': 'Hello_Python3', 'testCookies_2': 'Hello_Requests'}
# 在Cookie Version 0中规定空格、方括号、圆括号、等于号、逗号、双引号、斜杠、问号、@，冒号，分号等特殊符号都不能作为Cookie的内容。
r = requests.get(url, cookies=cookies)
print(r.json())

```

其他方法

```python
# 现在大部分的公司在开发项目都会会考虑多终端的问题，所以往往项目整体架构都是基于前后端分离的，那么实现前后端的分离的项目，往往服务端就是一个单独基于RestFul API接口的服务端。

import requests
# 只有args查询字符串参数，没有请求体
requests.get('http://httpbin.org/get')
requests.delete('http://httpbin.org/delete')
# 有请求体的
requests.post('http://httpbin.org/post')
requests.put('http://httpbin.org/put')
requests.patch('http://httpbin.org/patch')
```

自动化测试时，大家肯定都是希望自己写的代码越简洁越好，避免代码重复造成维护成本的提升，因此针对工作中常用的http网络请求模块requests，我们就需要在使用前对其进行简单的封装处理了。

`utils/requestor.py`，代码：

```python
import requests
from logger import LogHandle

class Request(object):
    """http请求工具类"""
    def __init__(self):
        # 实例化session管理器，维持会话, 跨请求的时候保存参数
        self.session = requests.session()
        self.logger = LogHandle().get_logger()

    def send(self, method, url, params=None, data=None, json=None, headers=None, **kwargs):
        """
        :param method: http请求方式
        :param url: 请求地址
        :param params: 字典或bytes，作为参数增加到url中
        :param data: data类型传参，字典、字节序列或文件对象，作为Request的内容
        :param json: json传参，作为Request的内容
        :param headers: 请求头，字典
        :param kwargs: 若还有其他的参数，使用可变参数字典形式进行传递
        :return:
        """
        # 对异常进行捕获
        try:
            self.logger.info(f"请求方法：{method}")
            self.logger.info(f"请求地址：{url}")
            self.logger.info(f"请求头：{headers}")
            if params: self.logger.info(f"查询参数：params={params}")
            if data: self.logger.info(f"请求体：data={data}")
            if json: self.logger.info(f"请求体：json={json}")
            if kwargs: self.logger.info(f"额外参数：kwargs={kwargs}")
            response = self.session.request(method, url, params=params, data=data, json=json, headers=headers, **kwargs)
            self.logger.info(f"状态码：{response.status_code}")
            self.logger.info(f"响应头：{response.headers}")
            self.logger.info(f"响应体[纯文本]：{response.text}")
            self.logger.info(f"响应体[二进制]：{response.content}")
            self.logger.info(f"响应体[json]：{response.json()}")
            # 返回响应结果
            return response

        except Exception as e:
            # 异常处理 报错在日志中打印具体信息
            self.logger.error(f"请求失败：{e}")

    def __call__(self, method, url, params=None, data=None, json=None, headers=None, **kwargs):
        """当把一个对象，当成函数来使用，那么就指定执行当前对象的__call__"""
        return self.send(method, url, params=params, data=data, json=json, headers=headers, **kwargs)

if __name__ == '__main__':
    """"基本使用"""
    # 实例化
    request = Request()

    """发送get请求"""
    # # response = request("GET", 'http://httpbin.org/get')
    # response = request(method="GET", url='http://httpbin.org/get')
    # # 打印响应结果
    # print(response.text)


    """发送post请求"""
    # 请求地址
    url = 'http://httpbin.org/post'
    # 请求参数
    json = {"usernam": "moluo", "password": "123456"}
    # 请求头
    headers = {"company": "luffytest"}
    response = request(method="POST", url=url, json=json, headers=headers)
    # 打印响应结果
    print(response.text)

```

提交代码版本，代码：

```bash
git add .
git commit -m "feature: 新增requtsts http网络请求工具类"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



#### 基于flask实现mockserver

在实际项目开发中，经常出现服务端与客户端分离的情况，那么我们在做测试开发时，有可能服务端的功能还没有实现，此时我们可以自己先模拟出服务器返回结果，直接对接口基本功能进行联调测试并编写自动化测试脚本，等服务器上线之后，切换server地址，直接可以简化调试时间，缩短项目测试周期。flask是一个轻量级的python web框架，非常适用于在测试开发中构建模拟api服务器。

##### 安装模块

```bash
pip install flask
pip install pymysql
pip install flask_sqlalchemy
```



##### 项目初始化

`api/__init__.py`，代码：

```python
import config
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

# SQLAlchemy初始化
db = SQLAlchemy()

app = Flask(__name__)

def init_app():
    # 加载配置
    app.config.from_object(config)

    # 加载mysql数据库配置
    db.init_app(app)

    # db创建数据表
    with app.app_context():
        db.create_all()

    return app
```

`config.py`，添加配置信息，代码：

```python
import pathlib  # 路径操作模块，替代 os.path模块，os.path采用字符串来操作路径，pathlib采用面向对象来操作路径

# 项目目录的主目录路径[字符串路徑]
BASE_DIR_STR = pathlib.Path(__file__).parent.resolve().as_posix()  # 基本操作系统转换路径的分隔符 as_posix
# 項目目录的主目录路径[路径对象]
BASE_DIR = pathlib.Path(BASE_DIR_STR)

# 项目名
WEB_NAME = "路飞自动化接口测试框架-master"

# 测试自动化项目的运行端口与IP地址
HOST = "127.0.0.1"
PORT = 8088

"""日志配置"""
LOGGING = {
    "name": "luffytest",  # 日志处理器的名称，一般使用当前项目名作为名称
    "filename": (BASE_DIR / "logs/luffytest.log").as_posix(),  # 日志文件存储路径，注意，一定要在项目根目录下手动创建logs目录
    "charset": "utf-8",  # 日志内容的编码格式
    "backup_count": 31,  # 日志文件的备份数量
    "when": "d",   # 日志文件的创建间隔事件,m 表示每分钟创建1个，h表示每小时创建1个，d表示每天创建1个，m0~m6表示每周星期日~星期六创建1个，midnight表示每日凌晨
}


"""mock server 的服务端配置"""
# 数据库连接
SQLALCHEMY_DATABASE_URI: str = "mysql+pymysql://root:123@127.0.0.1:3306/pytest?charset=utf8mb4"
# 查询时会显示原始SQL语句
SQLALCHEMY_ECHO: bool = True

# 调试模式
DEBUG = True
# 监听端口
API_PORT = 8000
# 监听地址
API_HOST = "0.0.0.0"

```



##### mock接口实现

`api/models.py`，代码：

```python
from datetime import datetime
from werkzeug.security import generate_password_hash, check_password_hash

from . import db


class BaseModel(db.Model):
    """公共模型"""
    __abstract__ = True  # 抽象模型
    id = db.Column(db.Integer, primary_key=True, comment="主键ID")
    name = db.Column(db.String(255), default="", comment="名称/标题")
    is_deleted = db.Column(db.Boolean, default=False, comment="逻辑删除")
    orders = db.Column(db.Integer, default=0, comment="排序")
    status = db.Column(db.Boolean, default=True, comment="状态(是否显示,是否激活)")
    created_time = db.Column(db.DateTime, default=datetime.now, comment="创建时间")
    updated_time = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now, comment="更新时间")

    def __repr__(self):
        return f"<{self.__class__.__name__}: {self.name}>"


class User(BaseModel):
    """用户基本信息表"""
    __tablename__ = "py_user"
    name = db.Column(db.String(255), index=True, comment="用户账户")
    nickname = db.Column(db.String(255), comment="用户昵称")
    _password = db.Column(db.String(255), comment="登录密码")
    intro = db.Column(db.String(500), default="", comment="个性签名")
    avatar = db.Column(db.String(255), default="", comment="头像url地址")
    sex = db.Column(db.SmallInteger, default=0, comment="性别")  # 0表示未设置,保密, 1表示男,2表示女
    email = db.Column(db.String(32), index=True, default="", nullable=False, comment="邮箱地址")
    mobile = db.Column(db.String(32), index=True, nullable=False, comment="手机号码")

    # 存取器
    @property
    def password(self):  # user.password
        return self._password

    @password.setter
    def password(self, rawpwd):  # user.password = '123456'
        """密码加密"""
        self._password = generate_password_hash(rawpwd)

    def check_password(self, rawpwd):
        """验证密码"""
        return check_password_hash(self.password, rawpwd)

```

`api/views.py`，代码：

```python
from flask import request
from sqlalchemy import or_

from . import app
from .models import User,db


@app.route("/user/register", methods=["POST"])
def register():
    """
    用户信息注册
    :return:
    """
    try:
        data = request.json
        # 创建用户数据
        user = User(**data)
        db.session.add(user)
        db.session.commit()
        return {"msg": "注册成功！", "data": {"id":user.id, "name": user.name}}, 200
    except Exception as e:
        return {"msg": "注册失败！", "data": {}}, 400


@app.route("/user/login", methods=["POST"])
def login():
    """
    用户登录
    :return:
    """
    user = User.query.filter(
        or_(
            User.mobile == request.json.get("username"),
            User.name == request.json.get("username"),
            User.email == request.json.get("username")
        )
    ).first()  # 实例化模型

    if not user:
        return {"msg": "登录失败！用户不存在！", "data": {}}, 400

    if not user.check_password(request.json.get("password")):
        return {"msg": "登录失败！密码错误！", "data": {}}, 400

    return {"msg": "登录成功", "data":{"id": user.id, "name": user.name}}, 200

```

进入数据库终端，创建一个数据库.

```sql
create database pytest;
```

项目根目录下，单独创建run.py文件，启动mock server，代码：

```python
import config
from api import init_app

# 注意，务必把模型models的内容以及 views 中的服务端接口引入当前文件，否则flask不识别。
from api import models
from api import views

app = init_app()

if __name__ == '__main__':
    app.run(host=config.API_HOST, port=config.API_PORT)

```



提交代码版本，代码：

```bash
git add .
git commit -m "feature: 基于flask实现mockserver"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



##### 编写测试用例测试mockserver

`tests/users/test_login.py`，代码：

```python
import allure
import config
from logger import LogHandle
from requestor import Request


logger = LogHandle().get_logger()
SERVER_URl = f"http://{config.API_HOST}:{config.API_PORT}"

@allure.epic(config.WEB_NAME)
@allure.feature("用户模块")
@allure.story("登录")
class TestLogin(object):
    @allure.severity(allure.severity_level.CRITICAL)
    def test_username_by_empty(self,):
        allure.dynamic.title("用户名为空，登陆失败")
        allure.dynamic.description("测试用户名为空的登陆结果")

        # 发送请求
        request = Request()
        request("POST", f"{SERVER_URl}/user/login", json={
            "username": "",
            "password": "123456"
        })

    def test_password_by_empty(self,):
        allure.dynamic.title("密码为空，登陆失败")
        allure.dynamic.description("测试密码为空的登陆结果")

        # 发送请求
        request = Request()
        request("POST", f"{SERVER_URl}/user/login", json={
            "username": "xiaoming",
            "password": ""
        })
 
```

提交代码版本，代码：

```bash
git add .
git commit -m "test: 编写测试用例测试mockserver"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



## 基于数据驱动生成用例代码

在实际测试开发中，我们一般使用参数化来自动生成测试用例，前面介绍过常用的有ddt与parametrize。那么在pytest中，因为本身提供了parametrize参数化，所以我们往往会在unittest中采用ddt来实现参数化，而在pytest中采用内置的parametrize即可。

而参数化所需要的测试用例，一般我们也是可以采用json，yaml或Excel文件来存储，如果用例数量太多，还可以改成数据库保存。

### YAML

YAML（递归缩写：YAML Ain't a Markup Language，译作：YAML 不是一种标记语言）是一种可读性高，用来表达数据序列化的数据格式，使用场景与xml、json类似，2001年首次发布，在最初开发YAML语言时YAML的意思其实是："Yet Another Markup Language"（仍是一种标记语言）。后面之所以改了名称，原因是为了强调YAML语言以数据为中心，而不是以标记语言为重点。

#### 语法特点

```bash
1. 大小写敏感
2. 使用缩进表示嵌套层级关系，且缩进不允许使用tab，只允许使用空格缩进（缩进的空格数不重要，只要相同层级的元素左对齐即可）
3. '#' 表示注释
4. '~' 表示 空(None, null)，也可以使用null表示None，但是尽量不要在属性中出现null或者~
5. yaml文件中，属性唯一不能重复，否则报错
6. 文件扩展名为yml或yaml，如：data.yaml 或者 data.yml
```

`test.yaml`，代码：

```python
username: 'xiaoming'
age: 16
```

#### 数据类型

| 类型名称        | 对应python的数据类型               | 描述                                                         |
| --------------- | ---------------------------------- | ------------------------------------------------------------ |
| 纯量（scalars） | 整型、浮点型、布尔型、字符串、None | 单个的、不可再分的值                                         |
| 数组（Array）   | 列表、元祖                         | 一组按次序排列的值，又称为序列（sequence） / 列表（list）    |
| 对象（object）  | 字典                               | 键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） |

##### 纯量

纯量是最基本的，不可再分的值。类似python中的字符串、布尔值、整型、浮点型、None等

```yaml
# 纯量
# 字符串
name: 小明
# 字符串内容太多可以换行，yaml中针对源码中的连续多个空格或换行，只会识别成一个空格
title: 如果内容太长，则可以换行
       换行后，两段字符串会被使用空格拼接
       但注意，缩进左对齐，否则报错
# yaml中的属性声明，建议采用python变量的命名规范
content_type: "*/*"  # 如果字符串内容中出现特殊符号，建议加上引号，否则有时候会报错

# 布尔值 False / True
sex: TRUE  # true,True 都可以

# 浮点型
score: 13.5
point: 6.8523015e+5   # 支持科学计数法，也可以6.8523015E+5

# 整型
age: 13
goods_id: 100_200_300  # 支持千分位

# 日期与时间
date: 2022-10-01
time: 12:30:00
datetime: 2018-02-17T15:02:31+08:00

# 空
data1: null
data2: ~
null: ~  # 避免这种情况，不能使用null作为属性名！
```

##### 数组

一组按次序排列的值，又称为序列（sequence） / 列表（list），类似python的列表。

```yaml
# 数组
# 数组的成员可以是任意的数据类型
# 方式1：使用中括号进行数组声明，中括号可以换行也可以不换行，无需左对齐
arr1: ["A", "B", True, 1, 1.3]  # 最终还是数组，属性名叫tuple，但并不代表他是元组。
arr2: [
  1,
  2,
  3
]

# 方式2：使用-标记成员进行数组声明，数组成员必须缩进左对齐，否则报错，并且-与成员值必须使用空格隔开
arr3:
  - 1
  - 2
  - 3

# 多层数组嵌套[类似python的多维列表]，这里只演示2层，还可以声明更多层嵌套
arr4: [
  [1,2,3,4,5],
  [6,7,8,9,10]
]

arr5:
  -
    - 1.a
    - 1.b
  -
    - 2.a
    - 2.b

```

##### 对象

键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary），类似python中的字典，但比字典灵活。

```yaml
# 对象
# 对象的成员是键值对格式数据，属性与属性之间必须使用英文冒号(:)来映射，同时每一个之间使用英文逗号(,)隔开
# 方式1：使用花括号声明，花括号可以换行，无需左对齐
dict: {name: xiaoming, age: 17}
map: {
  name: xiaohong,
  age: 16,
  sex: false
}

# 方式2：使用缩进键值对成员进行对象声明，对象成员必须缩进左对齐，不对齐则报错
data:
  name: xiaoming
  age: 16

# 多层嵌套对象[类似python的多维字典]
people:
  name: xiaoming
  age: 26
  love:
    - code
    - watching TV
    - shopping
  son:
    name: xiaohui
    age: 3

goods_list:
  -
    name: 立白洗衣粉
    price: 39.90
    num: 3
  -
    name: 黑猫神蚊香液
    price: 56.50
    num: 6
```



#### python操作YAML

安装yaml模块

```bash
pip install pyyaml
```

基本使用

```python
import yaml
"""读取yaml文件的数据"""
# with open("./data.yaml", "r",encoding="utf-8") as f:
#     content = f.read()
#     data = yaml.load(content, Loader=yaml.FullLoader)
#     print(data)
#     print(data["name"])


"""把数据写入yaml文件"""
from datetime import datetime


with open("./data2.yaml", "w", encoding="utf-8") as f:
    # yaml.dump(data, f, Dumper=yaml.SafeDumper) # 没有多字节内容的情况下
    data = {
        "name": "xiaoming",
        "age": 17,
        "datetime": datetime.now(),
        "point": 1.245464E10,
        "goods_list": [
            {"name": "xiaoming","age": 17, "sex": True},
            {"name": "xiaoming","age": 17, "sex": True},
            {"name": "xiaoming","age": 17, "sex": True},
            {"name": "xiaoming","age": 17, "sex": True},
        ],
        "author_list": ["小明", "小白", "小红"],
        "user_info": {"username":"小明", "password": "123456"}
    }
    yaml.dump(data, f, Dumper=yaml.SafeDumper, allow_unicode=True)  # 有多字节内容的情况下，中文就是多字节内容

```



封装yaml工具类，utils/yamler.py，代码：

```python
import yaml
from logger import LogHandle


class Yaml(object):
    """yaml操作工具类"""
    __instance = None

    def __new__(cls, *args, **kwargs):
        if not cls.__instance:
            print("创建Yaml的单例")
            cls.__instance = super(Yaml, cls).__new__(cls, *args, **kwargs)
        return cls.__instance

    def __init__(self):
        self.logger = LogHandle().get_logger()

    def read(self, path):
        """读取yaml文件"""
        with open(path, encoding="utf-8") as f:
            result = f.read()
            if result:
                result = yaml.load(result, Loader=yaml.FullLoader)
            return result

    def write(self, path, data):
        """写入yaml文件"""
        try:
            with open(path, "w", encoding="utf-8") as f:
                yaml.dump(data, f, Dumper=yaml.SafeDumper, allow_unicode=True)
            return True
        except Exception as e:
            self.logger(f"写入数据到yaml文件失败：{e}")
            return False


if __name__ == '__main__':
    ya = Yaml()
    data = ya.read("../demo/yaml_demo/data.yaml")
    print(data, type(data))

```

提交代码版本，代码：

```bash
git add .
git commit -m "feature: 封装yaml工具类"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



#### 基于yaml数据驱动生成测试用例

`data/user_login.yaml`，代码：

```yaml
-
  name: 用户登录-测试用户名与密码为空的情况
  request:
    method: post
    url: /user/login
    json:
      "username": ""
      "password": ""
  assert:
    - code == 400

-
  name: 用户登录-测试密码为空的情况
  request:
    method: post
    url: /user/login
    json:
      "username": "xiaoming"
      "password": ""
  assert:
    - code == 400


-
  name: 用户登录-测试有账号密码但是密码错误的情况
  request:
    method: post
    url: /user/login
    json:
      "username": "xiaoming"
      "password": "1234562222"
  assert:
    - code == 400


-
  name: 用户登录-测试有账号密码单而且正确的情况
  request:
    method: post
    url: /user/login
    json:
      "username": "xiaoming"
      "password": "123456"
  assert:
    - code == 200

```

`utils/assertor.py`，代码：

```python
from logger import LogHandle

logger = LogHandle().get_logger()


def assertor(assert_list, response):
    """断言函数"""
    if type(assert_list) is not list:
        assert_list = [assert_list]

    for expr in assert_list:
        logger.info(f"开始断言：assert {expr}")
        if expr:
            exec(f"assert {expr}", {
                "code": response.status_code,
                "json": response.json(),
                "text": response.text,
                "content": response.content,
                "headers": response.headers,
            })

        logger.info(f"断言通过：assert {expr}")

if __name__ == '__main__':
    # Response就是模拟requests HTTP请求工具的返回结果对象
    class Response(object):
        status_code = 400
        text = "对不起，登陆失败!"
        content = "对不起，登陆失败!"
        headers = []

        @classmethod
        def json(cls):
            return {"id": 1},

    assert_list = [
        "code == 400",
        "'失败'in text",
    ]

    assertor(assert_list, Response())

```



`tests/users/test_login.py`，代码：

```python
import allure
import config
import pytest
from logger import LogHandle
from requestor import Request
from yamler import  Yaml
from assertor import assertor

logger = LogHandle().get_logger()
SERVER_URl = f"http://{config.API_HOST}:{config.API_PORT}"
yaml = Yaml()


@allure.epic(config.WEB_NAME)
@allure.feature("用户模块")
@allure.story("登录")
class TestLogin(object):
    # @allure.severity(allure.severity_level.CRITICAL)
    # def test_username_by_empty(self,):
    #     allure.dynamic.title("用户名为空，登陆失败")
    #     allure.dynamic.description("测试用户名为空的登陆结果")
    #
    #     # 发送请求
    #     request = Request()
    #     request("POST", f"{SERVER_URl}/user/login", json={
    #         "username": "",
    #         "password": "123456"
    #     })
    #
    # def test_password_by_empty(self,):
    #     allure.dynamic.title("密码为空，登陆失败")
    #     allure.dynamic.description("测试密码为空的登陆结果")
    #
    #     # 发送请求
    #     request = Request()
    #     request("POST", f"{SERVER_URl}/user/login", json={
    #         "username": "xiaoming",
    #         "password": ""
    #     })

    @pytest.mark.parametrize("kwargs", yaml.read(config.BASE_DIR / "data/user_login.yaml"))
    def test_login(self, kwargs):
        request = Request()
        allure.dynamic.title(kwargs.get('name'))
        request.logger.info(f"开始请求测试接口：{kwargs.get('name')}")
        data = kwargs.get('request')
        response = request(data.get("method"), f'{SERVER_URl}{data.get("url")}', json=data.get("json"))
        assertor(kwargs.get("assert"), response)

```

提交代码版本，代码：

```bash
git add .
git commit -m "feature: 基于yaml数据驱动生成测试用例"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



### Excel

在测试开发中，如果测试用例数量太多，使用yaml也存在很大的维护成本，此时可以考虑使用Excel或者数据库保存更多的测试用例，python中操作Exeel文件的模块有很多，常用的有：xlrd+xlwt，pyexcel+openpyxl等等。

安装模块

```bash
pip install xlrd
pip install xlwt
```



#### 封装Excel工具类

`utils/excel.py`，代码：

```python
import xlrd, json

class Excel(object):
    """Excel文件操作工具类"""
    def __init__(self, filename):
        self.workbook = xlrd.open_workbook(filename, formatting_info=True)

    def get_sheet_names(self):
        """
        获取当前excel文件所有的工作表的表名
        :return:
        """
        return self.workbook.sheet_names()

    def __get_sheet(self, sheet_index_or_name):
        """
        根据sheet的索引或名称，获取sheet对象
        :param sheet_index_or_name: sheet的索引或名称
        :return:sheet对象
        """
        if isinstance(sheet_index_or_name, int):
            if len(self.workbook.sheet_names()) > sheet_index_or_name:
                return self.workbook.sheet_by_index(sheet_index_or_name)
            else:
                raise Exception("Invalid Sheet Index!")
        elif isinstance(sheet_index_or_name, str):
            if sheet_index_or_name in self.workbook.sheet_names():
                return self.workbook.sheet_by_name(sheet_index_or_name)
            else:
                raise Exception("Invalid Sheet Name!")

    def get_rows_num(self,sheet_index_or_name):
        """
        获取指定工作表的数据总行数
        :param sheet_index_or_name: 工作表名或索引
        :return:
        """
        return self.__get_sheet(sheet_index_or_name).nrows

    def get_cols_num(self,sheet_index_or_name):
        """
        获取指定工作表的数据总列数
        :param sheet_index_or_name: 工作表名或索引
        :return:
        """
        return self.__get_sheet(sheet_index_or_name).ncols

    def get_cell_value(self, sheet_index_or_name, row_index, col_index):
        """
        获取指定工作表的指定位置的数据值
        :param sheet_index_or_name: 工作表名或索引
        :param row_index: 行下标，从0开始
        :param col_index: 列下标，从0开始
        :return:
        """
        sheet = self.__get_sheet(sheet_index_or_name)
        if sheet.nrows and sheet.ncols:
            return sheet.cell_value(row_index, col_index)
        else:
            raise Exception("Index out of range!")

    def get_data(self, sheet_index_or_name, fields, first_line_is_header=True):
        """
        获取工作表的所有数据
        :param sheet_index_or_name: 工作表名或索引
        :param fields: 返回数据的字段名
        :param first_line_is_header: 工作表是否是否表头，也就是非数据
        :return:
        """
        rows = self.get_rows_num(sheet_index_or_name)
        cols = self.get_cols_num(sheet_index_or_name)
        data = []
        for row in range(int(first_line_is_header), rows):
            row_data = {}
            for col in range(cols):
                cell_data = self.get_cell_value(sheet_index_or_name, row, col)
                if type(cell_data) is str and ("{" in cell_data and "}" in cell_data or "[" in cell_data and "]" in cell_data):
                    """判断如果表格中填写的数据是json格式键值对，则采用json模块转换成字典"""
                    cell_data = json.loads(cell_data)
                row_data[fields[col]] = cell_data
            data.append(row_data)

        return data

if __name__ == '__main__':
    xls = Excel("../data/case_user.xls")
    fields = [
        "case_id",
        "module_name",
        "case_name",
        "method",
        "url",
        "headers",
        "params_desc",
        "params",
        "assert_result",
        "real_result",
        "remark",
    ]

    print(xls.get_data(0, fields))

"""
[
    {'case_id': 1.0, 'module_name': '用户模块', 'case_name': '用户登录-测试用户名为空的情况', 'method': 'post', 'url': 'http://127.0.0.1:8000/user/login', 'headers': '', 'params_desc': 'username: 用户名\npassword: 密码', 'params': {'username': '', 'password': '123456'}, 'assert_result': 'code==400', 'real_result': '', 'remark': ''}, 
    {'case_id': 2.0, 'module_name': '用户模块', 'case_name': '用户登录-测试密码为空的情况', 'method': 'post', 'url': 'http://127.0.0.1:8000/user/login', 'headers': '', 'params_desc': 'username: 用户名\npassword: 密码', 'params': {'username': 'xiaoming', 'password': ''}, 'assert_result': 'code==400', 'real_result': '', 'remark': ''}, 
    {'case_id': 3.0, 'module_name': '用户模块', 'case_name': '用户登录-测试账号密码正确的情况', 'method': 'post', 'url': 'http://127.0.0.1:8000/user/login', 'headers': '', 'params_desc': 'username: 用户名\npassword: 密码', 'params': {'username': 'xiaoming', 'password': '123456'}, 'assert_result': 'code==200', 'real_result': '', 'remark': ''}, 
    {'case_id': 4.0, 'module_name': '用户模块', 'case_name': '用户登录-测试使用手机号码登录', 'method': 'post', 'url': 'http://127.0.0.1:8000/user/login', 'headers': '', 'params_desc': 'username: 手机号\npassword: 密码', 'params': {'username': '13312345678', 'password': '123456'}, 'assert_result': 'code==200', 'real_result': '', 'remark': ''}]

"""

```

`config.py`，代码：

```python
import pathlib  # 路径操作模块，替代 os.path模块，os.path采用字符串来操作路径，pathlib采用面向对象来操作路径

# 项目目录的主目录路径[字符串路徑]
BASE_DIR_STR = pathlib.Path(__file__).parent.resolve().as_posix()  # 基本操作系统转换路径的分隔符 as_posix
# 項目目录的主目录路径[路径对象]
BASE_DIR = pathlib.Path(BASE_DIR_STR)

# 项目名
WEB_NAME = "路飞自动化接口测试框架-master"

# 测试自动化项目的运行端口与IP地址
HOST = "127.0.0.1"
PORT = 8088

"""日志配置"""
LOGGING = {
    "name": "luffytest",  # 日志处理器的名称，一般使用当前项目名作为名称
    "filename": (BASE_DIR / "logs/luffytest.log").as_posix(),  # 日志文件存储路径，注意，一定要在项目根目录下手动创建logs目录
    "charset": "utf-8",  # 日志内容的编码格式
    "backup_count": 31,  # 日志文件的备份数量
    "when": "d",   # 日志文件的创建间隔事件,m 表示每分钟创建1个，h表示每小时创建1个，d表示每天创建1个，m0~m6表示每周星期日~星期六创建1个，midnight表示每日凌晨
}


# excel测试用例字段格式
FIELD_LIST = [
    "case_id",        # 用例编号
    "module_name",    # 模块名称
    "case_name",      # 用例名称
    "method",         # 请求方式
    "url",            # 接口地址
    "headers",        # 请求头
    "params_desc",    # 参数说明
    "params",         # 请求参数
    "assert_result",  # 预期结果
    "real_result",    # 实际结果
    "remark",         # 备注
]


"""mock server 的服务端配置"""
# 数据库连接
# SQLALCHEMY_DATABASE_URI: str = "数据库类型://账户:密码@IP地址:端口/数据库名称?charset=utf8mb4"
SQLALCHEMY_DATABASE_URI: str = "mysql+pymysql://root:123@127.0.0.1:3306/pytest?charset=utf8mb4"
# 查询时会显示原始SQL语句
SQLALCHEMY_ECHO: bool = True

# 调试模式
DEBUG = True
# 监听端口
API_PORT = 8000
# 监听地址
API_HOST = "127.0.0.1"

```

提交代码版本，代码：

```bash
git add .
git commit -m "feature: 封装Excel工具类"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



#### 基于excel文件实现数据驱动生成测试用例

`tests/users/user_login.py`，代码：

```python
import allure
import config
import pytest
from logger import LogHandle
from requestor import Request
from yamler import  Yaml
from assertor import assertor
from utils.excel import Excel

logger = LogHandle().get_logger()
SERVER_URl = f"http://{config.API_HOST}:{config.API_PORT}"
yaml = Yaml()


@allure.epic(config.WEB_NAME)
@allure.feature("用户模块")
@allure.story("登录")
class TestLogin(object):
    # @allure.severity(allure.severity_level.CRITICAL)
    # def test_username_by_empty(self,):
    #     allure.dynamic.title("用户名为空，登陆失败")
    #     allure.dynamic.description("测试用户名为空的登陆结果")
    #
    #     # 发送请求
    #     request = Request()
    #     request("POST", f"{SERVER_URl}/user/login", json={
    #         "username": "",
    #         "password": "123456"
    #     })
    #
    # def test_password_by_empty(self,):
    #     allure.dynamic.title("密码为空，登陆失败")
    #     allure.dynamic.description("测试密码为空的登陆结果")
    #
    #     # 发送请求
    #     request = Request()
    #     request("POST", f"{SERVER_URl}/user/login", json={
    #         "username": "xiaoming",
    #         "password": ""
    #     })

    # @pytest.mark.parametrize("kwargs", yaml.read(config.BASE_DIR / "data/user_login.yaml"))
    # def test_login(self, kwargs):
    #     """数据驱动自动化测试-基于yaml生成"""
    #     request = Request()
    #     allure.dynamic.title(kwargs.get('name'))
    #     request.logger.info(f"开始请求测试接口：{kwargs.get('name')}")
    #     data = kwargs.get('request')
    #     response = request(data.get("method"), f'{data.get("url")}', json=data.get("json"))
    #     assertor(kwargs.get("assert"), response)

    @pytest.mark.parametrize("kwargs", Excel(config.BASE_DIR / "data/case_user.xls").get_data(0, config.FIELD_LIST))
    def test_login(self, kwargs):
        """数据驱动自动化测试-基于excel生成"""
        request = Request()
        allure.dynamic.title(kwargs.get('case_name'))
        request.logger.info(f"开始请求测试接口：{kwargs.get('case_name')}")
        if kwargs.get("method").lower() in ["get", "delete"]:
            """发送get或delete"""
            response = request(kwargs.get("method"), f'{kwargs.get("url")}', params=kwargs.get("params"))
        else:
            """发送post，put，patch"""
            response = request(kwargs.get("method"), f'{kwargs.get("url")}', json=kwargs.get("params"))
        assertor(kwargs.get("assert_result"), response)

```

提交代码版本，代码：

```bash
git add .
git commit -m "feature: 基于excel数据驱动生成测试用例"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



## 认证测试

在用户注册/登陆以后，往往项目会返回登陆状态（jwt,session, cookie）提供给客户端，所以上面我们所实现的mockserver实际上是有问题的。因此接下来我们继续来模拟存在jwt认证鉴权的服务端，并在测试框架中基于conftest.py来实现认证测试的这个流程。

![image-20220611183354232](assets/image-20220611183354232.png)

安装jwt

```bash
pip install flask-jwt-extended
```

`config.py`，代码：

```python

# 秘钥，不管是使用session还是jwt认证，都需要对认证的信息鉴权加密
SECRET_KEY = "ac361a52518d99f4525c1cfe5ba635572190aa6ac52bc8f27ae1b07529feafd0"
```

`api/__init__.py`，代码：

```python
import config
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager

# SQLAlchemy初始化
db = SQLAlchemy()

app = Flask(__name__)

jwt = JWTManager()

def init_app():
    """服务端初始化"""
    # 加载配置
    app.config.from_object(config)
    # 加载mysql数据库配置
    db.init_app(app)

    # jwt初始化
    jwt.init_app(app)

    # 自动创建数据表
    with app.app_context():
        db.create_all()

    return app
```

`api/views.py`，代码：

```python
from flask import request
from sqlalchemy import or_
from flask_jwt_extended import jwt_required, create_access_token

from . import app
from .models import User,db


@app.route("/user/register", methods=["POST"])
def register():
    """
    用户信息注册
    :return:
    """
    try:
        data = request.json
        # 创建用户数据
        user = User(**data)
        db.session.add(user)
        db.session.commit()
        return {"msg": "注册成功！", "data": {"id":user.id, "name": user.name}}, 200
    except Exception as e:
        return {"msg": "注册失败！", "data": {}}, 400


@app.route("/user/login", methods=["POST"])
def login():
    """
    用户登录
    :return:
    """
    user = User.query.filter(
        or_(
            User.mobile == request.json.get("username"),
            User.name == request.json.get("username"),
            User.email == request.json.get("username")
        )
    ).first()  # 实例化模型

    if not user:
        return {"msg": "登录失败！用户不存在！", "data": {}}, 400

    if not user.check_password(request.json.get("password")):
        return {"msg": "登录失败！密码错误！", "data": {}}, 400

    # 生成token，并返回给客户端
    access_token = create_access_token(identity={"id": user.id, "username": user.name})
    return {"msg": "登录成功", "data": {"token": access_token}}, 200


@app.route("/user", methods=["GET"])
@jwt_required()   # 当前这个装饰器的作用就是 校验用户是否登录
def user_center():
    return {"errmsg": "访问成功"}

```

项目根目录下创建`conftest.py`，代码：

```python
import pytest
import config
from utils.requestor import Request
from utils.yamler import Yaml

yaml = Yaml()


@pytest.fixture(scope="class", autouse=False)
def jwt_token():
    request = Request()
    request.logger.info("获取token")
    data = yaml.read(config.BASE_DIR / "data/test_user.yaml")
    response = request(data.get("method"), data.get("url"), json=data.get("json"))
    token = response.json().get("data", {}).get("token")
    yield token
    # 生成器函数中的暂停关键字，作用是当代码运行到yield时，把yield右边的数据作为返回值提供给调用处，把代码执行权交出去。
    request.logger.info("移除token")
```

`data/test_user.yaml`，填写一个保存正确用户信息的用例，方便在conftest中发送正确的账户信息获取token，代码：

```yaml
method: post
url: http://127.0.0.1:8000/user/login
json:
  "username": "xiaoming"
  "password": "123456"
```

新建一个测试用例，`tests/test_user.py`，代码：

```python
import allure
import pytest
import config
from utils.requestor import Request
from utils.yamler import Yaml
from utils.assertor import assertor


yaml = Yaml()


@allure.epic(config.WEB_NAME)
@allure.feature("用户模块")
@allure.story("用户中心")
class TestUser(object):
    @pytest.mark.usefixtures("jwt_token")
    @pytest.mark.parametrize("kwargs", yaml.read(config.BASE_DIR / "data/user_info.yaml"))
    def test_user(self, jwt_token, kwargs):
        allure.dynamic.title(kwargs.get('name'))
        request = Request()
        request.logger.info(f"开始请求测试接口：{kwargs.get('name')}")
        data = kwargs.get('request')
        data['headers']["Authorization"] = data['headers']["Authorization"].format(token=jwt_token)
        response = request(data.get("method"), data.get("url"), headers=data.get("headers"))
        assertor(kwargs.get("assert"), response)

```

`data/user_info.yaml`，代码：

```yaml
-
  name: 用户中心-测试jwt认证鉴权
  request:
    method: get
    url: http://127.0.0.1:8000/user
    headers:
      Authorization: "Bearer {token}"
  assert:
    - code == 200

```

提交代码版本，代码：

```bash
git add .
git commit -m "feature: 基于conftest实现jwt认证鉴权的测试用例"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```

# UI自动化测试

UI测试（User Interface Test，译作：用户界面测试），UI测试侧重产品的UI交互是否正确，模拟后端进行测试也可以，放在单元测试里去做也可以。

## Web自动化测试

常用的web自动化测试工具有：selenium，Playwright、QTP、Cypress、Rapise、TestProject、Ranorex、Katalon、Subject7、Serenity等等

### selenium

![img](assets/ec48d0a64c1a41dd9b5e6530081e5d05.png)

Selenium是由杰森·哈金斯（Jason Huggins）于2004年在思特沃克（ThoughtWorks）开发的一款专门为Web应用而开发的自动化测试工具（最早是作为火狐浏览器的一个插件存在，内核基于javascript实现）， 适合进行功能测试、验收测试，同时支持所有基于web的管理任务自动化。简单来说，就是用程序模拟人操作浏览器网页，可以实现UI自动化测试。

Selenium基于webdriver协议可以控制浏览器模仿用户操作完成UI自动化测试，同时它也是一个生态系统，其主要功能包括：测试与浏览器的兼容性，测试应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能，创建回归测试检验软件功能和用户需求。Selenium包含了Selenium IDE、Selenium RC（Selenium2.0以后已经webdriver替代了）、Selenium  Grid。

Selenium发展到今天已经经历4个版本：Selenium1.0，Selenium2.0，Selenium3.0，Selenium4.0

特点：

+ 开源（使用Apache License 2.0协议发布）、免费、简单易学、操作灵活、功能齐全。
+ 支持市面上基本所有的浏览器：**`Firefox`**、**`Chrome`**、IE（7, 8, 9, 10, 11）、**`Edge`**、Opera、**`Safari`**等等。
+ 跨平台：windows、linux、mac
+ 多语言支持：**`java`**、**`python`**、Ruby、C#、JavaScript、C++
+ 对web页面有良好的支撑。
+ 支持分布式执行测试用例。

官方文档：https://www.selenium.dev/documentation/



#### 安装步骤

1. 安装要测试的浏览器的webdriver插件
2. 安装对应编程语言的开发工具模块

下载地址：https://www.selenium.dev/downloads/

##### webdriver插件安装

| 浏览器类型              | 下载地址                                                     |
| ----------------------- | ------------------------------------------------------------ |
| Chrome                  | http://chromedriver.storage.googleapis.com/index.html        |
| Firefox                 | https://github.com/mozilla/geckodriver/releases              |
| IE                      | http://selenium-release.storage.googleapis.com/index.html    |
| Edge                    | https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/ |
| PhantomJS（无头浏览器） | https://phantomjs.org/                                       |

> 注意：UI自动测试依赖于浏览器环境，所以浏览器务必不要设置为自动更新！！！下载的浏览器webdriver驱动一定要对应当前测试的浏览器版本。

![image-20220618095924226](assets/image-20220618095924226.png)

选择点击同样版本的webdriver目录

![image-20220618095958759](assets/image-20220618095958759.png)

根据自己的操作系统下载对应的webdriver版本。

![image-20220618100028050](assets/image-20220618100028050.png)

#### 快速使用

python中安装selenium

```bash
pip install selenium
```



##### 打开浏览器

```python
import time

from selenium import webdriver
from selenium.webdriver.chrome.service import Service

# # 旧版本selenium指定webdriver.exe的路径，操作对应的浏览器
# driver = webdriver.Chrome(executable_path="./chromedriver.exe")
# print(driver)

# 旧版本selenium指定webdriver.exe的路径，初始化一个谷歌浏览器实例对象
service = Service(executable_path="./chromedriver.exe")

# driver浏览器驱动对象，是一个连接对象，提供了操作浏览器的具体的功能方法以及与浏览器相关的功能参数等等
driver = webdriver.Chrome(service=service)
print(driver)

# 浏览器最小化窗口
driver.minimize_window()

# 通过driver.get方法打开一个网址，相当于新建一个窗口
driver.get("https://www.luffycity.com")

time.sleep(5)

# 关闭浏览器
driver.quit()

```



##### 窗口操作

| 操作                               | 描述                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| driver.set_window_size(宽度, 高度) | 设置浏览器窗口大小，单位：px 像素                            |
| driver.get_window_size()           | 获取浏览器窗口大小，返回结果为字典格式                       |
| **`driver.get(url地址)`**          | 根据url地址打开一个新的浏览器窗口，或当前窗口跳转到地址url地址页面 |
| **`driver.current_url`**           | 获取当前浏览器窗口的url地址                                  |
| **`driver.title`**                 | 获取当前浏览器窗口的页面标题                                 |
| driver.forward()                   | 浏览器前进下一页                                             |
| driver.back()                      | 浏览器返回上一页                                             |
| driver.refresh()                   | 刷新当前浏览器                                               |
| driver.close()                     | 关闭当前浏览器窗口，如果浏览器只有一个标签页，则表示关闭浏览器 |
| **`driver.quit()`**                | 关闭浏览器                                                   |

```python
import time

from selenium import webdriver
from selenium.webdriver.chrome.service import Service

service = Service(executable_path="./chromedriver.exe")
driver = webdriver.Chrome(service=service)
# 设置浏览器的宽高
driver.set_window_size(1555, 768)
# 获取浏览器的宽高
ret = driver.get_window_size()
print(ret) # {'width': 1555, 'height': 770}
driver.get("https://www.luffycity.com")
print(f"网页标题：{driver.title}")
print(f"当前地址：{driver.current_url}")
time.sleep(3)
# 刷新浏览器当前页面
driver.refresh()
time.sleep(3)
# 刷新浏览器当前页面
driver.refresh()
time.sleep(3)

# 在当前窗口打开一个新页面
driver.get("https://www.baidu.com")
time.sleep(3)
# 返回上一步访问的url地址，相当于返回路飞
driver.back()
time.sleep(3)
# 前进到下一步访问的url地址，相当于前进到百度
driver.forward()

# 等待10秒退出，如果当前窗口只有一个浏览器页面，则表示退出当前浏览器
time.sleep(10)
driver.close()
```



##### 元素定位

我们通过webdriver打开一个网络页面，目的是为了操作当前页面已完成浏览器中的一些UI测试步骤，所以必然需要操作网页。而网页的内容组成是由HTML标签（element，也叫元素），所以基于selenium操作网页实际上本质就是操作元素。那么要操作元素就必须先获取元素对象。selenium中关于元素的获取也叫元素的定位，提供了8种元素定位操作可以让测试人员获取一个或多个HTML元素。

| 定位类型          | 低版本代码                                                   | 新版本代码                                                   | 描述                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **`xpath`**       | driver.find_element_by_xpath("xpath")<br>driver.find_element**s**_by_xpath("xpath") | driver.find_element(By.XPATH, "xpath")<br>driver.find_elements(By.XPATH, "xpath") | 基于**xpath路径表达式**对HTML元素进行提取操作                |
| **selector**      | driver.find_element_by_css_selector("css_selector")<br>driver.find_elements_by_css_selector("css_selector") | driver.find_element(By.CSS_SELECTOR, "css_selector")<br>driver.find_elements(By.CSS_SELECTOR, "css_selector") | 基于**css选择器**对HTML元素进行提取操作                      |
| **id**            | driver.find_element_by_id("id")                              | driver.find_element(By.ID,"id")                              | 基于HTML元素的**id属性**对元素进行提取操作                   |
| **class**         | driver.find_element_by_class_name(class_name")<br>driver.find_elements_by_class_name(class_name") | driver.find_element(By.CLASS_NAME, "class_name")<br>driver.find_elements(By.CLASS_NAME, "class_name") | 基于HTML元素的**class属性**对元素进行提取操作                |
| **tag**           | driver.find_element_by_tag_name("tag_name")<br>driver.find_elements_by_tag_name("tag_name") | driver.find_element(By.TAG_NAME, "tag_name")<br>driver.find_elements(By.TAG_NAME, "tag_name") | 基于HTML元素的**标签名**对元素进行提取操作                   |
| **link_text**     | driver.find_element_by_link_text("link_text")<br>driver.find_elements_by_link_text("link_text") | driver.find_element(By.LINK_TEXT,"link_text")<br>driver.find_elements(By.LINK_TEXT,"link_text") | 基于HTML元素的**超链接文本内容**对元素进行提取操作           |
| name              | driver.find_element_by_name("name")<br>driver.find_elements_by_name("name") | driver.find_element(By.NAME, "name")<br>driver.find_elements(By.NAME, "name") | 基于HTML元素的**name属性**对元素进行提取操作，常用于表单元素 |
| partial_link_text | driver.find_element_by_partial_link_text("partial_link_text")<br>driver.find_elements_by_partial_link_text("partial_link_text") | driver.find_element(By.PARTIAL_LINK_TEXT, "partial_link_text")<br>driver.find_elements(By.PARTIAL_LINK_TEXT, "partial_link_text") | 基于HTML元素的**部分超链接**对元素进行提取操作               |

###### 基于xpath、css selector与class属性值获取元素

```python
import time

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By

service = Service(executable_path="./chromedriver.exe")
driver = webdriver.Chrome(service=service)

# 打开一个页面
driver.get("https://www.luffycity.com")

# 基于xpath路径获取元素
element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div/img[1]')

# # 基于css选择符获取元素
# element = driver.find_element(By.CSS_SELECTOR, '#__layout > div > div.mbox > div > img.close')

# # 基于class属性值来获取元素
# element = driver.find_elements(By.CLASS_NAME, 'close')
# # 如果使用find_elements获取多个元素，返回结果是一个列表，需要通过下标来选择操作的是哪一个？
# element = element[0]


# 等待3秒以后点击(这个等待不是必须的，而是为了方便查看而已)
time.sleep(3)
print(element.click())

# 等待10秒退出，如果当前窗口只有一个浏览器页面，则表示退出当前浏览器
time.sleep(10)
driver.close()

```

###### 基于id，link_text获取元素

```python
import time

from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By

option = ChromeOptions()
option.add_experimental_option('excludeSwitches', ['enable-automation'])  # 规避网站监测
option.add_experimental_option('useAutomationExtension', False)  # 去掉开发者警告
service = Service("chromedriver.exe")
driver=webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument",{'source':'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'}) # 规避网站监测

# 打开一个页面
driver.get("https://www.baidu.com")

# 基于xpath路径获取元素
element = driver.find_element(By.ID, 'kw')
# 往输入框元素中通过键盘录入数据使用 send_keys()
element.send_keys("路飞学城")

# 找到提交按钮并点击
element = driver.find_element(By.ID, 'su')
element.click()

time.sleep(3)
# 从搜索结果找到有路飞学城的链接内容，并点击
element = driver.find_element(By.LINK_TEXT, '路飞学城')
element.click()
"""
错误提示：
NoSuchElementException: Message: no such element: Unable to locate element: {"method":"link text","selector":"路飞学城"}
异常，没有这样的一个元素：基于  {"method":"link text","selector":"路飞学城"} 查找不到元素（本地元素不可达）
原因是百度在用户搜索内容以后，采用了ajax进行异步刷新页面数据的，所以会导致selenium代码在元素时，百度服务器有可能没有返回数据结果，没有数据结果则没有该结果连接，因此报错
"""

# 等待10秒退出，如果当前窗口只有一个浏览器页面，则表示退出当前浏览器
time.sleep(10)
driver.close()
```

  基于tag获取元素，往往用于获取iframe内嵌框架页中的元素。

```python
import time

from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By

option = ChromeOptions()
option.add_experimental_option('excludeSwitches', ['enable-automation'])  # 规避网站监测
option.add_experimental_option('useAutomationExtension', False)  # 去掉开发者警告
service = Service("chromedriver.exe")
driver = webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument",{'source':'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'}) # 规避网站监测

# 打开一个页面
driver.get("https://mail.163.com")

iframe_list = driver.find_elements(By.TAG_NAME, 'iframe')
form_iframe = iframe_list[0]
# 切换窗口到指定iframe
driver.switch_to.frame(form_iframe)

driver.find_element(By.NAME, 'email').send_keys('moooluo2022')
time.sleep(3)
driver.find_element(By.NAME, 'email').clear()

# 等待10秒退出，如果当前窗口只有一个浏览器页面，则表示退出当前浏览器
time.sleep(10)
driver.close()

```

小练习：在上面的163邮箱登陆表单中，新增一段代码，实现自动输入密码操作。

```python
import time

from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By

option = ChromeOptions()
option.add_experimental_option('excludeSwitches', ['enable-automation'])  # 规避网站监测
option.add_experimental_option('useAutomationExtension', False)  # 去掉开发者警告
service = Service("chromedriver.exe")
driver = webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument",{'source':'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'}) # 规避网站监测

# 打开一个页面
driver.get("https://mail.163.com")

iframe_list = driver.find_elements(By.TAG_NAME, 'iframe')
form_iframe = iframe_list[0]
# 切换窗口到指定iframe
driver.switch_to.frame(form_iframe)

driver.find_element(By.NAME, 'email').send_keys('moooluo2022')
# time.sleep(3)
# driver.find_element(By.NAME, 'email').clear()

driver.find_element(By.NAME, 'password').send_keys('123456')

driver.find_element(By.ID, 'dologin').click()

# 等待10秒退出，如果当前窗口只有一个浏览器页面，则表示退出当前浏览器
time.sleep(10)
driver.close()

```



##### 元素操作

| 操作                    | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| **click()**             | 点击当前元素                                                 |
| **send_keys()**         | 给当前表单元素输入文本内容                                   |
| **clear()**             | 给当前表单元素清空内容                                       |
| **submit()**            | 点击提交按钮，提交表单，要使用submit提交表单则按钮必须有form表单才行，如果ajax提交的不行。 |
| get_attribute()         | 获取元素的指定属性值                                         |
| value_of_css_property() | 获取元素的CSS样式的指定属性的属性值，不准确.                 |
| **is_displayed()**      | 查看元素是否显示可见                                         |
| is_enabled()            | 查看表单元素是否启用                                         |
| **is_selected()**       | 查看元素是否被选择，一般判断表单元素，如radio单选框或checkbox多选框 |
| size                    | 获取元素的尺寸大小                                           |
| text                    | 获取元素的文本内容                                           |



###### 模拟登陆操作

代码：

```python
import time
from getpass import getpass
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By


def get_driver():
    # 初始化一个谷歌浏览器实例对象
    service = Service("chromedriver.exe")
    driver = webdriver.Chrome(service=service)
    return driver


def task(username, password):
    # 打开一个网址
    driver.get("https://www.luffycity.com")
    time.sleep(3)  # 可以不用，这句代码的作用主要是便于观察

    # 关闭广告
    driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div/img[1]').click()

    # 点击登陆
    driver.find_element(By.CLASS_NAME, 'signin').click()
    time.sleep(3)

    # 往账号输入框输入账号
    element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div/div[2]/div[1]/div[1]/input')
    element.send_keys(username)

    # 往密码输入框输入密码
    element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div/div[2]/div[1]/div[2]/input')
    element.send_keys(password)

    element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div/div[2]/button')
    element.click()

    time.sleep(5)
    driver.quit()


if __name__ == '__main__':
    username = input("账号: ")
    # python的getpass会与pycharm内置的run终端形成阻塞，
    # 所以使用了getpass，则需要改成cmd或pycharm的Terminal终端来运行python脚本
    password = getpass("密码：")
    driver = get_driver()
    task(username, password)

```



###### 查看操作元素的相关属性

```python
import time
from getpass import getpass
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By


# 初始化一个谷歌浏览器实例对象
service = Service("chromedriver.exe")
driver = webdriver.Chrome(service=service)

# 打开一个网址
driver.get("http://localhost:63342/code/7.html?_ijt=gom325r5bev2q5u5q3uelkchje")

# # 查看元素的显示模式，是否是可见
# element = driver.find_element(By.NAME, 'access_token')
# display = element.is_displayed()
# print(display)
#
# # 查看元素的属性值
# print(element.get_attribute("value"))
# outline = element.value_of_css_property('border')
# print(outline)

# element = driver.find_element(By.XPATH, '/html/body/form/input[4]')
# enabled = element.is_enabled()
# print(enabled)

# # 提交表单
# element = driver.find_element(By.XPATH, '/html/body/form/input[5]')
# element.submit()


element = driver.find_element(By.XPATH, '/html/body/h1')
print(element.text)

time.sleep(5)
driver.quit()

```



##### 规避监测

现在不少网站有对selenium采取了监测机制。这些监测机制会导致我们使用selenium访问网站时出现各种拦截机制，如出现验证码等。

```python
import time
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service

service = Service("chromedriver.exe")
driver=webdriver.Chrome(service=service)

driver.get("https://www.baidu.com")

driver.find_element(By.ID, "kw").send_keys("路飞学城")
driver.find_element(By.ID, "su").click()

time.sleep(3)
driver.quit()

```

解决方案：

```python
import time
from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service


option = ChromeOptions()
option.add_experimental_option('excludeSwitches', ['enable-automation'])  # 规避网站监测
option.add_experimental_option('useAutomationExtension', False)  # 去掉开发者警告

service = Service("chromedriver.exe")
driver = webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", {'source':'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'}) # 规避网站监测


driver.get("https://www.baidu.com")

driver.find_element(By.ID, "kw").send_keys("路飞学城")
driver.find_element(By.ID, "su").click()

time.sleep(5)
driver.quit()

```



##### 鼠标事件

在上面的selenium操作中，我们获取元素可以直接调用click方法实现鼠标点击效果。但是，如果要进行更加复杂多样的鼠标操作，如鼠标右键、鼠标移动、拖动等等，则需要依赖于 ActionChains (动作链) 模块提供的鼠标操作来完成。

```python
from selenium.webdriver.common.action_chains import ActionChains
```

基本使用

```python
import time
from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.action_chains import ActionChains

# 初始化一个谷歌浏览器实例对象
option=ChromeOptions()
option.add_experimental_option('excludeSwitches',['enable-automation'])
option.add_experimental_option('useAutomationExtension', False)
service = Service("chromedriver.exe")
driver=webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument",{'source':'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'})


# 打开一个网址
driver.get("https://www.luffycity.com")

# 关闭广告
element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div/img[1]')
element.click()

time.sleep(5)
# 定位元素，定位到顶部导航菜单的"题库"上面
element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/header/div/div/nav/a[6]')
# move_to_element 把鼠标悬停在指定元素上面
# context_click 执行鼠标右键
# 动作链在设置动作以后，不会自动执行，所以需要在动作链的末尾，调用perform执行整个动作链
ActionChains(driver).move_to_element(element).context_click().perform()

time.sleep(5)
driver.quit()

```

ActionChains动作链可以保存1个或多个连贯的鼠标操作，但是最终执行鼠标操作需要调用`perform()`方法。常用鼠标操作：

| 操作                                              | 描述                                       |
| ------------------------------------------------- | ------------------------------------------ |
| double_click(element)                             | 鼠标双击                                   |
| **context_click(element)**                        | 鼠标右击                                   |
| **drag_and_drop(source, target)**                 | 鼠标拖动（将一个元素移动到另一个元素位置） |
| drag_and_drop_by_offset(source, xoffset, yoffset) | 鼠标拖动（将一个元素移动到指定坐标位置）   |
| **move_to_element(element)**                      | 鼠标移动并悬放到指定元素的上方             |
| move_by_offset(xoffset, yoffset)                  | 将鼠标从当前位置移动到指定坐标处           |

测试页面：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
    .box{
        width: 100px;
        height: 100px;
        background: red;
    }
    .box:hover{
        background: blue;
    }
    </style>
</head>
<body>
    <div class="box"></div>
    <script>
    var box = document.querySelector(".box")
    box.ondblclick = function(){
        box.style.background = "yellow";
    }
    </script>
</body>
</html>
```

测试双击与鼠标选放

```python
import time

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.action_chains import ActionChains

service = Service("chromedriver.exe")
driver=webdriver.Chrome(service=service)

# 打开一个网址
driver.get("C:/Users/Administrator/Desktop/code/11-测试页面.html")

element = driver.find_element(By.CLASS_NAME, 'box')
ActionChains(driver).move_to_element(element).perform()
time.sleep(1)
ActionChains(driver).double_click().perform()
time.sleep(3)
driver.quit()
```

拖拽元素

```python
import time
from selenium import webdriver
from selenium.webdriver import ChromeOptions, ActionChains
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.keys import Keys


option=ChromeOptions()
option.add_experimental_option('excludeSwitches',['enable-automation'])
option.add_experimental_option('useAutomationExtension', False)
service = Service("chromedriver.exe")
driver=webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument",{'source':'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'})

# 设置浏览器窗口最大化
driver.maximize_window()

# 进入页面
driver.get('https://www.jq22.com/yanshi10850')

iframe = driver.find_element(By.TAG_NAME, "iframe")
driver.switch_to.frame(iframe)

element1 = driver.find_element(By.XPATH, '//*[@id="bar"]/li[1]')
element2 = driver.find_element(By.XPATH, '//*[@id="foo"]')
time.sleep(3)
ActionChains(driver).drag_and_drop(element1, element2).perform()

time.sleep(10)
driver.quit()
```



##### 键盘事件

前面我们在元素操作中使用了send_keys()方法来模拟键盘输入，而针对复杂的组合键盘操作，webdriver提供了键盘上几乎所有的按键方法，使用前导入Keys类即可。

```python
from selenium.webdriver.common.keys import Keys
```

| **方法名**                      | 描述            |
| ------------------------------- | --------------- |
| **send_keys(Keys.ENTER)**       | 回车键Enter     |
| **send_keys(Keys.BACK_SPACE)**  | 删除键BackSpace |
| **send_keys(Keys.SPACE)**       | 空格键(Space)   |
| **send_keys(Keys.TAB)**         | 制表键(Tab)     |
| **send_keys(Keys.ESCAPE)**      | 复位键Esc       |
| **send_keys(Keys.CONTROL,'a')** | 全选Ctrl+A      |
| **send_keys(Keys.CONTROL,'c')** | 复制Ctrl+C      |
| **send_keys(Keys.CONTROL,'x')** | 剪切Ctrl+X      |
| **send_keys(Keys.CONTROL,'v')** | 粘贴Ctrl+V      |
| **send_keys(Keys.F1)**          | 键盘F1          |
| **……**                          | ……              |
| **send_keys(Keys.F12)**         | 键盘F12         |
|                                 |                 |

###### 基本使用

页面：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>

    </style>
</head>
<body>
<textarea name="content" id="" cols="30" rows="10">hello!EveryBody!</textarea>
</body>
</html>
```



代码：

```python
import time
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.keys import Keys

service = Service("chromedriver.exe")
driver = webdriver.Chrome(service=service)
driver.get("C:/Users/Administrator/Desktop/code/12-测试页面.html")
time.sleep(3)
element = driver.find_element(By.TAG_NAME, "textarea")
element.send_keys(Keys.CONTROL, 'a')
element.send_keys(Keys.BACK_SPACE)

time.sleep(3)
element.send_keys("2012年9月25日，辽宁舰正式交付中国海军；2019年12月17日，山东舰入列，中国海军进入双航母时代；2022年6月17日，福建舰来了，我们有三艘航母了。")

time.sleep(5)
driver.quit()

```

回车键等操作

```python
import time
from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.keys import Keys


option=ChromeOptions()
option.add_experimental_option('excludeSwitches',['enable-automation'])
option.add_experimental_option('useAutomationExtension', False)
service = Service("chromedriver.exe")
driver=webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument",{'source':'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'})

# 设置浏览器窗口最大化
driver.maximize_window()
# driver.minimize_window()  # 最小化
# 进入页面
driver.get('https://www.baidu.com/')
# 定位输入框
element = driver.find_element(By.ID, "kw")
# 向输入框中输入内容
element.send_keys("路飞学城")
time.sleep(2)
# 删除上一步中多输入的文字
element.send_keys(*[Keys.BACK_SPACE for i in range(2)])
element.send_keys("在线教育")

time.sleep(2)
# 使用回车代替点击按钮
element.send_keys(Keys.ENTER)
time.sleep(2)

```



##### 屏幕截图

在selenium中，截取网页的图片有多种方式，一般常用的有2种方式：截取可见区域和截取指定区域。

###### 截取可见区域

主要是通过`driver.save_screenshot`来完成。

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver import ChromeOptions
from selenium.webdriver.chrome.service import Service

# 初始化一个谷歌浏览器实例对象

option = ChromeOptions()
option.add_experimental_option('excludeSwitches', ['enable-automation'])
option.add_experimental_option('useAutomationExtension', False)
service = Service("chromedriver.exe")
driver = webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument",
                       {'source': 'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'})

driver.get('https://www.luffycity.com')

# 关闭广告
element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div/img[1]')
element.click()

# 调用浏览器驱动对象的save_screenshot方法就可以实现截图
driver.save_screenshot('./luffycity.png')  # 图片必须保存为 png 格式
driver.quit()

```

save_screenshot使用过程中，需要注意2点：

1. save_screenshot方法保存的图片格式必须是png格式，否则不行。
2. save_screenshot保存图片的目录，必须是已经存在的，否则无法保存图片。



###### 截取指定区域

通过先获取HTML文档中的元素对象，再通过元素对象调用`screenshot` 来进行截取。

```python
import time
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver import ChromeOptions
from selenium.webdriver.chrome.service import Service


# 初始化一个谷歌浏览器实例对象
option = ChromeOptions()
option.add_experimental_option('excludeSwitches', ['enable-automation'])
option.add_experimental_option('useAutomationExtension', False)
service = Service("chromedriver.exe")
driver = webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument",
                       {'source': 'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'})

driver.get('https://www.luffycity.com')

# 关闭广告
element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div/img[1]')
element.click()

# 点击登陆
driver.find_element(By.CLASS_NAME, 'signin').click()
time.sleep(3)

# 往账号输入框输入账号
element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div/div[2]/div[1]/div[1]/input')
element.send_keys("13928835901")

# 往密码输入框输入密码
element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div/div[2]/div[1]/div[2]/input')
element.send_keys("123")

element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div/div[2]/button')
element.click()

time.sleep(2)
element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div')
# 通过元素的 screenshot 方法直接保存图片
element.screenshot('./login_result.png')
time.sleep(3)
driver.quit()

```



##### 等待机制

针对一些通过ajax局部刷新或延时显示的数据，在selenium使用过程中如果没有等待数据显示就直接执行后续代码就会有问题。

```python
import time
from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service

option=ChromeOptions()
option.add_experimental_option('excludeSwitches',['enable-automation'])
option.add_experimental_option('useAutomationExtension', False)
service = Service("C:/Users/Administrator/Desktop/test/测试自动化-day04/素材/chromedriver.exe")
driver=webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument",{'source':'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'})

driver.get("http://www.baidu.com")

driver.find_element(By.ID, "kw").send_keys("路飞学城")
driver.find_element(By.ID, "su").click()
# time.sleep(3)
driver.find_element(By.PARTIAL_LINK_TEXT, "路飞学城").click()
time.sleep(3)
driver.quit()

```

上面虽然使用了`time.sleep(3)`让selenium**强制等待**了3秒，但是这种操作不够灵活，因为数据加载有时候不需要3秒就显示出来了，而程序并没有办法知道而导致最终呆呆的等待了3秒才继续执行。当然，也有可能3秒后数据还没有出来，那么程序则依然报错。所以开发中针对上述问题，我们是不能使用`time.sleep`来草草了事的，而是要使用selenium提供的另外两种等待机制。

###### 显式等待

```python
import time
from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions


option=ChromeOptions()
option.add_experimental_option('excludeSwitches',['enable-automation'])
option.add_experimental_option('useAutomationExtension', False)
service = Service("chromedriver.exe")
driver=webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument",{'source':'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'})

driver.get("http://www.baidu.com")

driver.find_element(By.ID, "kw").send_keys("路飞学城")
driver.find_element(By.ID, "su").click()
# 使用time.sleep这种机械化的强制等待，实际上是有可能出问题的。即便没有问题，也会存在着让测试代码浪费等待时间的情况。
# time.sleep(3)
# driver.find_element(By.PARTIAL_LINK_TEXT, "路飞学城").click()

# 显式等待
WebDriverWait(driver=driver, timeout=60, poll_frequency=0.5, ignored_exceptions=None).until(expected_conditions.presence_of_element_located((By.PARTIAL_LINK_TEXT, '路飞学城'))).click()

time.sleep(3)
driver.quit()

```

`selenium`提供了 `WebDriverWait`类实现显式等待机制，`WebDriverWait`类接收4个参数来指定等待机制。

- driver，浏览器驱动对象
- timeout，最长超时等待时间，单位（秒）
- poll_frequency，轮询检测等待条件的时间，也就是每隔多长时间检测一次条件，默认是0.5秒
- ignored_exceptions，timeout超时后的异常信息，默认抛出`NoSuchElementException`。

基本使用：

```python
WebDriverWait(driver=driver, timeout=10, poll_frequency=0.5, ignored_exceptions=None)
```

`WebDriverWait`类提供了两个方法来完成等待条件的检测实现：

+ **until(self, method, message='')**，method为等待检测条件的判断方法，until表示直到返回True，用的较多。
+ until_not(self, method, message='')，method为等待检测条件的判断方法，until_not表示直到返回False。

上面代码用到的method指定为`expected_conditions`模块并调用其`presence_of_element_located`方法判断指定元素是否存在。

`expected_conditions`模块提供了各种判断：

- `presence_of_element_located`判断某个元素是否存在于HTML文档中。
- `presence_of_elements_located` 判断是否至少有1个元素存在HTML中。只要有1个元素存在，则该方法就返回True。

显式等待的另一种写法，首先实例化一个显式等待对象，这样可以在各个地方灵活的调用：

```python
import time
from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions


option=ChromeOptions()
option.add_experimental_option('excludeSwitches',['enable-automation'])
option.add_experimental_option('useAutomationExtension', False)
service = Service("chromedriver.exe")
driver=webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument",{'source':'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'})

# 1. 先创建一个显式等待对象
wait = WebDriverWait(driver=driver, timeout=60, poll_frequency=0.5, ignored_exceptions=None)

driver.get("http://www.baidu.com")

driver.find_element(By.ID, "kw").send_keys("路飞学城")
driver.find_element(By.ID, "su").click()
# 使用time.sleep这种机械化的强制等待，实际上是有可能出问题的。即便没有问题，也会存在着让测试代码浪费等待时间的情况。
# time.sleep(3)
# driver.find_element(By.PARTIAL_LINK_TEXT, "路飞学城").click()

# 2. 显式等待对象调用判断等待方法
wait.until(expected_conditions.presence_of_element_located((By.PARTIAL_LINK_TEXT, '路飞学城'))).click()

time.sleep(3)
driver.quit()

```



###### 隐式等待

也叫全局等待。我们可以直接通过浏览器驱动对象driver调用隐式等待，并且用法也相对简单：

```python
import time
from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions


option=ChromeOptions()
option.add_experimental_option('excludeSwitches',['enable-automation'])
option.add_experimental_option('useAutomationExtension', False)
service = Service("chromedriver.exe")
driver=webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument",{'source':'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'})
# 设置隐式等待
driver.implicitly_wait(time_to_wait=10)  # 只需要一个等待超时时间参数

driver.get("https://www.baidu.com")

driver.find_element(By.ID, "kw").send_keys("路飞学城")
driver.find_element(By.ID, "su").click()

driver.find_element(By.PARTIAL_LINK_TEXT, "路飞学城").click()

time.sleep(3)
driver.quit()

```

`implicitly_wait`等待时间单位为秒，如上例所示，我们指定了10秒。需要注意的是，隐式与显式等待有明显的区别，隐式等待应用于全局，每当使用`driver`驱动找某个元素时，隐式等待机制就会被触发（导致测试代码的运行速度变慢），如果元素存在，则继续执行，否则，它将以轮询的方式判断元素是否定位成功，直至等待超时，抛出错误`NoSuchElementException`。而显式等待则只是指定某（些）个元素是否存在时执行。

在等待机制的选择上，我们可以在三种等待机制中灵活选择：

- 普通（静态页面较多）网页，强制等待和显式等待可以相互搭配，提高效率。适用于前后端不分离的UI场景测试。
- 动态页面较多的时候，则可以全局设置隐式等待。适用于前后端分离的UI场景测试



##### 窗口切换

在测试客户端时，往往存在有些功能流程需要点击打开并操作多个窗口页面的情况。此时就需要使用selenium在多个窗口中相互切换操作了。selenium中提供了三个方法给测试开发人员完成窗口切换操作。

| 方法名                           | 描述               |
| -------------------------------- | ------------------ |
| driver.switch_to.window          | 切换普通窗口       |
| driver.switch_to.frame           | 切换进入iframe窗口 |
| driver.switch_to.default_content | 切换退出iframe窗口 |
| driver.window_handles            | 窗口数组           |

###### 切换普通窗口

```python
import time
from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.support.wait import WebDriverWait  # 等待页面加载某些元素
from selenium.webdriver.support import expected_conditions

option = ChromeOptions()
option.add_experimental_option('excludeSwitches', ['enable-automation'])
option.add_experimental_option('useAutomationExtension', False)
service = Service("chromedriver.exe")
driver = webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument",
                       {'source': 'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'})

wait = WebDriverWait(driver, 10)

try:
    driver.get("https://www.baidu.com")

    driver.find_element(By.ID, "kw").send_keys("路飞学城")
    driver.find_element(By.ID, "su").click()
    wait.until(expected_conditions.presence_of_element_located((By.LINK_TEXT, '路飞学城'))).click()
    # 查看当前浏览器中打开的窗口列表
    print(driver.window_handles)
    time.sleep(3)
    # 根据数组下标索引切换窗口
    driver.switch_to.window(driver.window_handles[0])
    time.sleep(3)
    driver.find_element(By.LINK_TEXT, '百度百科').click()
    print(driver.window_handles)  # 此时应该有3个窗口了
    time.sleep(3)
    driver.switch_to.window(driver.window_handles[1]) # 切换到路飞窗口
finally:
    time.sleep(3)
    driver.quit()

```



###### 切换iframe窗口

两个方法：

- switch_to.frame(iframe)，进入窗口
- switch_to.default_content()，退出窗口

```python
import time
import getpass
from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service


def get_driver():
    """获取浏览器驱动对象"""
    option = ChromeOptions()
    option.add_experimental_option('excludeSwitches', ['enable-automation'])
    option.add_experimental_option('useAutomationExtension', False)
    service = Service("chromedriver.exe")
    driver = webdriver.Chrome(service=service, options=option)
    driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument",
                           {'source': 'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'})
    # 设置隐式等待
    driver.implicitly_wait(10)
    return driver

def task(url, username, password, to, theme):
    """
    发送邮件
    :param url  打开站点地址
    :param username 登陆账号
    :param password 登陆密码
    :param to 收件人邮箱账号
    :param theme 邮件的主体
    """
    driver.get(url)
    iframe = driver.find_elements(By.TAG_NAME, 'iframe')
    driver.switch_to.frame(iframe[0])
    driver.find_element(By.CLASS_NAME, 'dlemail').send_keys(username)
    driver.find_element(By.CLASS_NAME, 'dlpwd').send_keys(password)
    driver.find_element(By.ID, 'dologin').click()
    # 登陆以后刷新了页面了，所以需要重新获取driver浏览器驱动对象，否则无法进行后续操作
    driver.switch_to.window(driver.window_handles[0])
    driver.find_element(By.ID, '_mail_component_149_149').click()
    driver.find_element(By.CLASS_NAME, 'nui-editableAddr-ipt').send_keys(to)
    driver.find_elements(By.CLASS_NAME, 'nui-ipt-input')[2].send_keys(theme)

    content_iframe = driver.find_element(By.CLASS_NAME, 'APP-editor-iframe')
    driver.switch_to.frame(content_iframe)
    driver.find_element(By.TAG_NAME, "p").send_keys("这是通过selenium添加的邮件内容！！！")
    driver.switch_to.default_content()
    # 发送邮件
    driver.find_elements(By.CLASS_NAME, 'nui-btn-text')[2].click()

if __name__ == '__main__':
    url = 'https://mail.163.com'
    theme = '一份测试邮件'
    to = '649641514@qq.com'
    content = '测试邮件内容.................................'
    # username = input('用户名: ').strip()
    username = "moooluo2022"
    # pycharm中直接运行python脚本会导致getpass进入阻塞，所以需要使用终端命令行运行python脚本
    password = getpass.getpass(prompt="密码: ")
    driver = get_driver()
    try:
        task(url, username, password, to, content)
    except Exception as e:
        print(f"发送邮件出错：{e}")
    finally:
        time.sleep(20)
        driver.quit()

```



##### 执行js代码

实际上，我们之前有提到关于selenium实际上操作浏览器都是通过webdriver完成对应的功能操作的，而webdriver实际上是通过js代码来控制浏览器的。因此针对如果selenium本身如果没有提供的操作，则我们可以使用js代码来完成一些窗口操作。例如：滚动条。

```python
import time
from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service


option = ChromeOptions()
option.add_experimental_option('excludeSwitches', ['enable-automation'])  # 规避网站监测
option.add_experimental_option('useAutomationExtension', False)  # 去掉开发者警告

service = Service("chromedriver.exe")
driver = webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", {'source':'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'}) # 规避网站监测

driver.get("https://www.baidu.com")

# # 执行没有返回的值的js代码
# driver.execute_script('confirm("hello, luffycity!")')
#
# # 关闭alert弹窗
# time.sleep(3)
# # 让driver浏览器驱动对象，切换焦点（切换上下文）到弹窗
# alert = driver.switch_to.alert
# # 点击确定，以达到关闭弹窗的效果
# # alert.accept()
# alert.dismiss()   # 关闭弹窗，相当于点击了取消

"""让浏览器执行js代码并获取代码的返回值"""

"""例如：获取cookie"""
# result = driver.execute_script('return document.cookie')
# cookies = result.split(";")
# cookies_dict = {i[0]:i[1] for i in [item.split("=") for item in cookies]}
# print(cookies_dict.get("BIDUPSID"))
# 有了cookie以后，以后就可以跳过登陆测试其他的功能操作了。

"""例如：获取本地存储中的token"""
result = driver.execute_script("return localStorage")
print(result) #
time.sleep(5)
driver.quit()

```

操作滚动条

```python
import time
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service

service = Service("chromedriver.exe")
driver = webdriver.Chrome(service=service)

driver.get("https://www.luffycity.com")

# 关闭广告
element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div/img[1]')
element.click()

num = 0
while num <= driver.execute_script("""return parseInt(getComputedStyle(document.querySelector('.main'))["height"])"""):
    num += 1
    driver.execute_script(f"window.scrollTo(0, {20*num})")
    time.sleep(0.01)

time.sleep(3)
driver.quit()

```



##### 无头浏览器

所谓的无头浏览器（Headless），实际上就是不需要打开浏览器去操作浏览器完成对应UI效果。

```python
import time
from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By

option = ChromeOptions()
option.add_experimental_option('excludeSwitches',['enable-automation'])  # 规避网站监测
option.add_experimental_option('useAutomationExtension', False)  # 去掉开发者警告

# 开启浏览器的无头模式
option.add_argument('--headless')
option.add_argument('--disable-gpu')  # 允许在无GPU的环境下运行，可选
option.add_argument('--window-size=1920x1080')  # 建议设置

service = Service("chromedriver.exe")
driver = webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", {'source':'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'}) # 规避网站监测
# 设置隐式等待
driver.implicitly_wait(time_to_wait=10)  # 只需要一个等待超时时间参数

# 打开网页
driver.get("https://www.baidu.com")
# 搜索内容
driver.find_element(By.ID, "kw").send_keys("路飞学城")
driver.find_element(By.ID, "su").click()

# 点击搜索结果
driver.find_element(By.PARTIAL_LINK_TEXT, "路飞学城").click()

# 调用浏览器驱动对象的save_screenshot方法就可以实现截图
driver.save_screenshot('./baidu_search_result.png')  # 图片必须保存为 png 格式

driver.quit()

```

使用无头浏览器，在运行一些经过验证的测试脚本时，可以达到节约系统资源的优点，而且少了浏览器的UI效果，UI测试脚本的运行速度会加快。



##### selenium集成到pytest实现UI测试自动化

selenium初始化，`utils/seleniumer.py`代码：

```python
from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By

option = ChromeOptions()
option.add_experimental_option('excludeSwitches',['enable-automation'])  # 规避网站监测
option.add_experimental_option('useAutomationExtension', False)  # 去掉开发者警告

# 开启浏览器的无头模式
option.add_argument('--headless')
option.add_argument('--disable-gpu')  # 允许在无GPU的环境下运行，可选
option.add_argument('--window-size=1920x1080')  # 建议设置

service = Service("chromedriver.exe")
driver = webdriver.Chrome(service=service, options=option)
driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", {'source':'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'}) # 规避网站监测

```

注意：把chromedriver.exe保存到站点根目录下。

![image-20220620151300062](assets/image-20220620151300062.png)

单元测试代码，`users/test_login.py`，代码：

```python
    def test_luffycity_login(self):
        """selenium结合pytest实现自动化UI测试"""
        from seleniumer import driver, By
        import time
        request = Request()
        allure.dynamic.title("测试路飞登陆")
        request.logger.info(f"开始请求测试接口：测试路飞登陆")
        url = 'https://www.luffycity.com'
        request.logger.info(f"打开登陆地址：{url}")
        driver.get(url)
        # 关闭广告
        element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div/img[1]')
        element.click()

        # 点击登陆
        driver.find_element(By.CLASS_NAME, 'signin').click()

        # 往账号输入框输入账号
        element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div/div[2]/div[1]/div[1]/input')
        username = "13928835901"
        request.logger.info(f"填写登陆账号：{username}")
        element.send_keys(username)

        # 往密码输入框输入密码
        password = "123"
        element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div/div[2]/div[1]/div[2]/input')
        request.logger.info(f"填写登陆密码：{password}")
        element.send_keys(password)

        element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div/div[2]/button')
        element.click()

        # 通过元素的 screenshot 方法直接保存图片
        time.sleep(2)
        element = driver.find_element(By.XPATH, '//*[@id="__layout"]/div/div[2]/div')
        element.screenshot('./login_result.png')
        # 采用附件记录
        allure.attach.file('./login_result.png')

        driver.quit()

```

提交代码版本，代码：

```bash
git add .
git commit -m "feature: selenium集成到pytest实现UI测试自动化"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



##### 小笔记

```py
import time
import pyautogui
from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.common.keys import Keys


def get_driver():
    option = ChromeOptions()
    option.add_experimental_option('excludeSwitches', ['enable-automation'])  # 规避网站监测
    option.add_experimental_option('useAutomationExtension', False)  # 去掉开发者警告
    # 旧版本selenium指定webdriver.exe的路径，初始化一个谷歌浏览器实例对象
    service = Service(executable_path="/Users/kanghua/Downloads/chromedriver")

    # driver浏览器驱动对象，是一个连接对象，提供了操作浏览器的具体的功能方法以及与浏览器相关的功能参数等等
    driver = webdriver.Chrome(service=service, options=option)
    driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument",
                           {'source': 'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'})  # 规避网站监测
    # print(driver)
    return driver


def task():
    # 1. 先创建一个显式等待对象
    wait = WebDriverWait(driver=driver, timeout=60, poll_frequency=0.5, ignored_exceptions=None)
    driver.maximize_window()
    # 通过driver.get方法打开一个网址，相当于新建一个窗口
    driver.get("https://www.luffycity.com")
    wait.until(expected_conditions.presence_of_element_located((By.CLASS_NAME, 'close'))).click()  # 关闭广告
    # time.sleep(5)
    # driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div[2]/div/img[1]').click() #关闭广告
    # driver.find_element(By.XPATH, '/html/body/div[3]/div/div/header/div/div/div[2]/div[2]/span').click() #点击登录
    driver.find_element(By.CLASS_NAME, 'signin').click()  # 点击登录
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div[2]/div/div[2]/div[1]/div[1]/input').send_keys(
        "18679816495")
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div[2]/div/div[2]/div[1]/div[2]/input').send_keys(
        "ckh123456")
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div[2]/div/div[2]/button').click()  # 登录成功

    time.sleep(1)
    driver.get("https://www.luffycity.com/study/degree")

    time.sleep(1)
    driver.find_element(By.XPATH,
                        '/html/body/div[3]/div/div/div[1]/main/div[2]/div/div/div[2]/section[1]/p[5]/button/span').click()  # go
    # # 开始录制
    # pyautogui.hotkey('shift', 'f1')
    # time.sleep(60*30)
    # #结束录制
    # pyautogui.hotkey('shift', 'f2')
    # driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[1]/ul/li[2]/div').click() #2
    #
    # pyautogui.hotkey('shift', 'f1')
    # time.sleep(60*17)
    # pyautogui.hotkey('shift', 'f2')
    # driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[1]/ul/li[7]/div').click() #7
    # pyautogui.hotkey('shift', 'f1')
    # time.sleep(60*23)
    # pyautogui.hotkey('shift', 'f2')
    time.sleep(1)
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[1]/ul/li[8]/div').click()  # 7
    start_video(60 * 26)
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[1]/ul/li[9]/div').click()  # 7
    start_video(60 * 18)
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[1]/ul/li[10]/div').click()  # 7
    start_video(60 * 30)
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[1]/ul/li[11]/div').click()  # 7
    start_video(60 * 10)
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[1]/ul/li[12]/div').click()  # 7
    start_video(60 * 18)
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[1]/ul/li[13]/div').click()  # 7
    start_video(60 * 17)
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[1]/ul/li[14]/div').click()  # 7
    start_video(60 * 10)
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[1]/ul/li[15]/div').click()  # 7
    start_video(60 * 19)
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[1]/ul/li[16]/div').click()  # 7
    start_video(60 * 15)
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[1]/ul/li[17]/div').click()  # 7
    start_video(60 * 25)
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[1]/ul/li[18]/div').click()  # 7
    start_video(60 * 26)



    # time.sleep(15)
    # 关闭浏览器
    # driver.quit()


def start_video(num):
    pyautogui.hotkey('shift', 'f1')
    time.sleep(num)
    pyautogui.hotkey('shift', 'f2')
    time.sleep(1)


if __name__ == '__main__':
    driver = get_driver()
    task()

```

第二版

```py
import time
import pyautogui,pyperclip
from selenium import webdriver
from selenium.webdriver import ChromeOptions
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.common.keys import Keys


def get_driver():
    option = ChromeOptions()
    option.add_experimental_option('excludeSwitches', ['enable-automation'])  # 规避网站监测
    option.add_experimental_option('useAutomationExtension', False)  # 去掉开发者警告
    # 旧版本selenium指定webdriver.exe的路径，初始化一个谷歌浏览器实例对象
    service = Service(executable_path="/Users/kanghua/Downloads/chromedriver")

    # driver浏览器驱动对象，是一个连接对象，提供了操作浏览器的具体的功能方法以及与浏览器相关的功能参数等等
    driver = webdriver.Chrome(service=service, options=option)
    driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument",
                           {'source': 'Object.defineProperty(navigator,"webdriver",{get:()=>undefind})'})  # 规避网站监测
    # print(driver)
    return driver


def task():
    # 1. 先创建一个显式等待对象
    wait = WebDriverWait(driver=driver, timeout=60, poll_frequency=0.5, ignored_exceptions=None)
    driver.maximize_window()
    # 通过driver.get方法打开一个网址，相当于新建一个窗口
    driver.get("https://www.luffycity.com")
    wait.until(expected_conditions.presence_of_element_located((By.CLASS_NAME, 'close'))).click()  # 关闭广告
    driver.find_element(By.CLASS_NAME, 'signin').click()  # 点击登录
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div[2]/div/div[2]/div[1]/div[1]/input').send_keys(
        "18679816495")
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div[2]/div/div[2]/div[1]/div[2]/input').send_keys(
        "ckh123456")
    driver.find_element(By.XPATH, '/html/body/div[3]/div/div/div[2]/div/div[2]/button').click()  # 登录成功

    time.sleep(1)
    driver.get("https://www.luffycity.com/study/degree")

    time.sleep(1)
    driver.find_element(By.XPATH,
                        '/html/body/div[3]/div/div/div[1]/main/div[2]/div/div/div[2]/section[1]/p[5]/button/span').click()  # go

    data_list = [
        {"xpath":'/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[2]/ul/li[1]/div',"Time":60 * 38},
        {"xpath":'/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[2]/ul/li[2]/div',"Time":60 * 19},
        {"xpath":'/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[2]/ul/li[3]/div',"Time":60 * 38},
        {"xpath":'/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[2]/ul/li[4]/div',"Time":60 * 35},
        {"xpath":'/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[2]/ul/li[5]/div',"Time":60 * 16},
        {"xpath":'/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[2]/ul/li[6]/div',"Time":60 * 13},
        {"xpath":'/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[2]/ul/li[7]/div',"Time":60 * 27},
        {"xpath":'/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[2]/ul/li[8]/div',"Time":60 * 20},
        {"xpath":'/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[2]/ul/li[9]/div',"Time":60 * 20},
        {"xpath":'/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[2]/ul/li[10]/div',"Time":60 * 15},
        {"xpath":'/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[2]/ul/li[11]/div',"Time":60 * 26},
        {"xpath":'/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[2]/ul/li[12]/div',"Time":60 * 9},
        {"xpath":'/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[2]/ul/li[13]/div',"Time":60 * 17},
        {"xpath":'/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[2]/ul/li[14]/div',"Time":60 * 20},
        {"xpath":'/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[2]/ul/li[15]/div',"Time":60 * 23},
        {"xpath":'/html/body/div[3]/div/div/div/div[2]/div/div[2]/ul/li[2]/ul/li[16]/div',"Time":60 * 15},
    ]
    for item in data_list:
        xpath = item.get("xpath")
        Time = item.get("Time")
        time.sleep(0.5)
        driver.find_element(By.XPATH, xpath).click()
        time.sleep(0.5)
        text_name = driver.find_element(By.XPATH, xpath).text.splitlines()[0].replace(' ','-')
        pyautogui.hotkey('shift', 'f1')
        time.sleep(Time)
        pyautogui.hotkey('shift', 'f2')
        print(text_name)
        time.sleep(1)

        #粘贴文件名
        # pyautogui.typewrite(text_name,0.5) #无法写中文
        pyperclip.copy(text_name)
        pyperclip.paste()  #粘贴不了
        pyautogui.hotkey('ctrl', 'v')
        # pyautogui.press('enter')
        time.sleep(1)



if __name__ == '__main__':
    driver = get_driver()
    task()

```





##### python代码编译成win exe文件

```bash
pip install pywin32 -i https://pypi.douban.com/simple
pip install pyinstaller -i https://pypi.douban.com/simple

pyinstaller -F test.py -w
```



## APP自动化测试

APP移动端测试是指对移动端应用进行的测试，测试应用功能是否满足特定的需求。移动端测试一般分3类：APP功能测试、APP自动化测试、APP安全测试。其中常用的APP自动化测试工具有：Robtium、macaca、**Appium**、UiAutomator、Monkey、MonkeyRunner、Instrumentation、Athrun等等。

| 工具     | 支持语言                                   | 跨平台           | 跨应用 |                            |
| -------- | ------------------------------------------ | ---------------- | ------ | -------------------------- |
| Robotium | Java                                       | Android          | 不支持 |                            |
| Macaca   | Java、Python、node.js                      | Android、IOS     | 支持   | 可以作为简洁版的Appium工具 |
| Appium   | Java、c#、Python、PHP、Perl、Ruby、node.js | Android、IOS、H5 | 支持   |                            |

### Appium

#### 基本介绍

Appium由Sauce labs公司（是美国的一家提供自动化的软件测试服务公司）基于`node.js`的`express`框架开发`http server`，是一个开源、跨平台的移动端自动化测试框架，可以用来测试原生及混合的移动端应用。Appium支持IOS、Android及H5等移动端应用。Appium使用WebDriver的json wire协议来驱动Apple系统的UIAutomation库（由苹果官方提供的自动化测试库）、Android系统的UIAutomator框架（由Android官方提供的自动化测试库）。

![img](assets/1168165-20191008184525098-1434479632.png)

##### 与selenium的关系

appium继承了selenium的webdriver，也就是selenium2.0，所以appium在调试中实际上也调用了selenium的某些功能。

appium起到了一个电脑连接移动端的桥梁，然后我们可以在电脑上调用selenium工具来调试移动端应用。



##### appium原理

appium本质上就是一个使用node.js编写的http server（Http服务器），它对外暴露了一系列REST API接口提供给测试开发人员进行调用。

这个http server的功能其实很简单：监听一个端口，然后接收由client发送来的command。翻译这些command，把这些command转成移动设备可以理解的形式发送给移动设备，然后移动设备执行完这些command后把执行结果返回给httpserver，http server再把执行结果返回给client。

在这里client其实就是发起command的设备，一般来说就是我们编写代码执行的机器，执行appium测试代码的机器。狭义点理解，可以把client理解成是代码，当然这些代码可以是java/ruby/python/js的，只要它实现了webdriver标准协议就可以。

这样的设计思想带来了一些好处：

- 可以带来多语言的支持；
- 可以把server放在任意机器上，哪怕是云服务器都可以；（是的，appium和webdriver天生适合云测试）

![img](assets/1168165-20191008184540877-2014515585.bmp)



#### 安装步骤

##### 安装java环境

目前，java环境普遍来说使用的都是java8，所以我们直接下载安装1.8版本的sdk即可（jdk是Java语言的软件开发工具包，是整个java开发的核心，它包含了JAVA的运行环境，JAVA工具和JAVA基础的类库）。

下载地址：https://www.oracle.com/java/technologies/downloads/

鼠标右键安装（注意，不要把它安装到有中文的路径下，所以最好默认路径即可），一路点击确定下一步即可完成安装。



注意：javasdk环境是依赖于`JAVA_HOME`的，依次打开`控制面板`▷`系统与安全`▷`系统`▷`高级系统设置`▷`环境变量`▷`系统变量`▷`新建`。变量名中输入`JAVA_HOME`，变量值中填写刚才获取到的路径`C:\tool\Java\jdk1.8.0_201`(注意，此处根据自己的实际路径填写，别瞎复制)。

![image-20220618135144208](assets/image-20220618135144208.png)

保存了JAVA_HOME环境变量，点击下方的Path环境变量，里面把java sdk安装目录下bin目录加入到环境变量中。

![image-20220618135206230](assets/image-20220618135206230.png)

cmd终端输入`java -version`，出现如下内容表示安装完成。

![image-20220618182351919](assets/image-20220618182351919.png)

##### 安装Android SDK

[Android SDK](https://baike.baidu.com/item/Android SDK)（software development kit，译作：软件开发工具包），是用于为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件的开发工具的集合。Android SDK 指的是Android专属的软件开发工具包。

下载地址：https://www.androiddevtools.cn/#sdk-tools

![image-20220618044813946](assets/image-20220618044813946.png)

把下载下来的sdk压缩包解压到一个没有中文路径的目录下。例如：我的是 C:/tool/

![image-20220618182733621](assets/image-20220618182733621.png)

解压完成以后，进入sdk目录下，点击 SDK Manager.exe（sdk开发工具管理器，提供了类似pip的功能）。

按下面图中所示，勾选安卓开发最基本的7个模块到本地。

![image-20220618045458786](assets/image-20220618045458786.png)

![image-20220618045447895](assets/image-20220618045447895.png)

![image-20220618045436474](assets/image-20220618045436474.png)

安装完成以后，Android SDK Tools会在安装成功以后，从上面隐藏掉，不用在意。

接下来，需要把以下三个路径加入到环境变量中，让系统能识别 android sdk（注意根据自己实际的解压路径填写，不要瞎复制）。

```bash
C:\tool\android-sdk-windows\tools
C:\tool\android-sdk-windows\platform-tools
C:\tool\android-sdk-windows\build-tools\29.0.3
```

![image-20220618183513128](assets/image-20220618183513128.png)

cmd终端下输入命令`adb`，出现如下效果则安装正确。

![image-20220618050152136](assets/image-20220618050152136.png)

+ adb.exe（ Android Debug Bridge，安卓调试桥），调试app用的命令行工具，借助这个工具，我们可以直接在PC端就可以通过USB或者wifi就可以管理设备或模拟器的状态。保存在`android-sdk-windows\platform-tools`。
+ aapt.exe（Android Asset Packaging Tool），安卓开发使用的一个自动资源打包工具，可以用来检测apk的包名和activity名称。保存在`android-sdk-windows\build-tools\<安卓sdk版本>`



##### 安装模拟器

appium既支持使用真机测试，也支持模拟器测试。不过我们测试过程中实际上也并非一定要使用真机，因为我们测试的并非是移动端的操作系统而是app本身，所以很多时候测试开发过程中使用模拟器会更加方便，最关键的是模拟器可以轻松切换不同版本。这里推荐使用夜神模拟器（它不仅有windows版本，也有ios版本，而像其他的雷神模拟器，则仅支持windows版本，没有ios版本）。

下载地址：https://www.yeshen.com/

提示：如果windows下同时安装了安卓模拟器和docker-desktop的同学，如果无法顺利启动模拟器，可能需要执行以下命令，切换模拟器与docker-desktop的虚拟化服务。

```bash
# 使用模拟器
bcdedit /set hypervisorlaunchtype off
# 使用docker-desktop
bcdedit /set hypervisorlaunchtype auto
```

模拟器默认在安装以后会在bin目录下提供一个adb.exe安卓调试桥接工具（夜神模拟器叫nox_adb.exe），但是这个工具的版本有可能与我们安装的android sdk的abd.exe版本不一样，这样会导致无法使用appium调试模拟器中的移动端应用，所以需要把android sdk的abd.exe复制并改名替换掉模拟器bin目录下的adb.exe。**真机测试则没有这个问题**。

找到android sdk安装目录下platform-tools目录下的adb.exe。

![image-20220618092459525](assets/image-20220618092459525.png)

找到夜神安装目录的bin目录下的nox_adb.exe，并备份，然后替换成上面的。

同时打开模拟器中的配置，修改为手机版面，并开启开发者模式，并勾选开启USB调试功能。

![image-20220618092931642](assets/image-20220618092931642.png)

![image-20220618093136287](assets/image-20220618093136287.png)

![image-20220618093145540](assets/image-20220618093145540.png)

![image-20220618093200471](assets/image-20220618093200471.png)

点击7下召唤神龙~。。。。说错了，重来，点击7点是打开当前设备的开发者选项。

![image-20220618093218482](assets/image-20220618093218482.png)

返回上一步，就可以看到多了一个开发者选项了，接下来，开启USB调试选项。

![image-20220618135425171](assets/image-20220618135425171.png)

![image-20220618135529642](assets/image-20220618135529642.png)



##### 安装appium

因为版本更新的原因，实际上appium是存在着2个分支版本的，分别是appium Server 与 appium Desktop。其中，appium Server的安装比较复杂需要先安装node.js，所以目前来说官方已经不再更新与维护appium Server分支了，而是推荐测试开发者安装 appium Desktop版本。所以此处，我们直接通过以下链接到github下根据自己当前使用的操作系统安装appium Desktop即可。

下载地址：https://github.com/appium/appium-desktop/releases

![image-20220618034957823](assets/image-20220618034957823.png)

下载到本地以后双击exe文件，一路默认安装即可。

完成上面操作以后，打开终端输入`adb devices `，看到如下效果，则表示安装环境全部完成。

![image-20220618132439830](assets/image-20220618132439830.png)

> adb devices的结果是当前连接到PC端的所有的移动端设备列表。左侧参数是设备ID，右侧参数是设备的连接状态。
>
> 如果使用模拟器则显示效果如下：
> 127.0.0.1:5555  device   # 表示雷电模拟器
> 127.0.0.1:62001 device   # 表示夜神模拟器
>
> 如果使用真机则显示效果如下：
> UJN0221722001562  device 

注意：鸿蒙手机实际上虽然不是安卓系统，但是鸿蒙手机为了兼容安卓，实际上也提供了adb调试，但是很遗憾的是，我们不能直接使用USB调试，只能改用wifi调试才可以测试鸿蒙系统下的app。

###### adb命令

以下是开发中比较常用的adb命令：

| 命令                                 | 描述                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| **`adb devices`**                    | 查询连接到系统的所有移动端设备状态，常见状态：<br>device：连接正常<br/>offline：已断开<br/>unauthorized：未授权（手机端弹出的调试框没有允许） |
| adb -s 设备ID                        | 指定设备使用adb，设置ID通过上面adb devices可以获取           |
| adb -s 设备ID shell [命令]           | 使用Android Linux内核的命令                                  |
| adb -s 设备ID install -r 包名+路径   | 安装apk包，-r表示覆盖安装，可以使用`aapt d badging apk文件路径`查看app包名。 |
| adb -s 设备ID uninstall 包名         | 卸载apk                                                      |
| adb -s 设备ID push 电脑路径 手机路径 | 电脑文件上传至手机                                           |
| adb -s 设备ID pull 手机路径 电脑路径 | 手机文件下载至电脑                                           |
| adb -s 设备ID shell pm list packages | 列出手机中装的所有APP的包名                                  |
| adb -s 设备ID shell pm clear apk包名 | 清除应用数据及缓存                                           |

安装：

```bash
# 通过自动打包工具aapt，查看下载回来的apk的包名，并把源apk文件名改成包名。
aapt d badging C:\Users\Administrator\Desktop\test\jd.apk

# 通过adb指定设备，进行安装
adb -s 127.0.0.1:62001 install C:\Users\Administrator\Desktop\test\com.jingdong.app.mall.apk

# 卸载apk包
adb -s 127.0.0.1:62001 uninstall com.jingdong.app.mall
```



##### 安装Appium-Python-Client

Python想要操作appium，就要有专门的的连接工具模块-appium-python-client。直接安装即可。

```bash
pip install appium-python-client
```

OK。经过上面的步骤以后，appium的安装步骤就全部完成了。
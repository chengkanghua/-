# 基本概念

自动化测试，也叫软件测试自动化。要学习软件测试自动化，首先就需要清楚什么是软件测试。

## 软件测试

因为当局者迷，旁观者清的道理，软件开发是个复杂而周期性的过程，期间很容易产生或遗留下错误，而对于开发人员自己所编写与开发的应用程序（软件），往往有很多问题是他们自己发现不了，所以如果直接把存在不足的、有错误、有漏洞的应用程序直接运营上线提供给用户使用，那么很可能会给企业带来商业风险或影响企业受益，所以就需要软件测试人员进行软件测试了。

而软件测试（Software Testing）就是为了尽快尽早地发现软件的各种软件缺陷而展开的贯穿整个软件生命周期、对软件（包括阶段性产品）进行验证和确认的活动过程。这个过程是在规定的条件下对程序进行测试操作并对其是否能满足设计要求进行评估，以达到发现、纠正程序错误，衡量和提升软件质量的目的。通俗点说，软件测试就是通过各种各样的手段或工具来尽可能的找到软件的不足和错误。

软件测试只能查找出软件中的错误或不足，但不能证明程序中没有错误，而且软件测试不能完全消灭软件的错误，只能尽早尽量多的发现软件中的错误与不足。

```
软件生命周期是指从软件产品的可行性分析到软件不再使用而结束的时间。如果把软件看成是有生命的事物，那么软件的生命周期可分为6个阶段：需求分析、计划、设计、编码开发、测试、运行维护
```



### 测试分类

软件测试从不同的角度有着不同的分类方式。

![image-20220513075004943](assets/image-20220513075004943.png)

在实际开发中，往往我们都是根据实际情况采用多种不同的测试手段、测试方式来对软件测试测试的。



### 软件缺陷

软件缺陷，通常又被叫做bug或者defect，即为软件或程序中存在的某种破坏正常运行能力的问题、错误，其存在的最终表现为用户所需要的功能没有完全实现，不能满足或不能全部满足用户的需求。

+   从**产品内部**来说，软件缺陷是软件产品开发或维护过程中所存在的错误、误差等各种问题。

+   从**产品外部**来说，软件缺陷是系统所需要实现的某种功能的没有或不足。

#### 出现原因

bug出现的原因一般有如下几种情况，也就是说符合以下情况的问题都属于bug：

| 原因     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 功能遗漏 | 软件未实现用户或产品需求要求的或应有的功能。                 |
| 异常错误 | 软件出现了不应该出现的错误。                                 |
| 功能冗余 | 软件出现了用户或产品需求没有要求的功能。                     |
| 体验度低 | 软件的使用过程过于复杂或难以理解、软件运行缓慢导致用户体验不好。 |



#### 缺陷管理

缺陷管理也叫bug管理，一般会集成到项目管理工具中，常用的项目管理工具：[Teambition](https://www.teambition.com/)、[禅道](https://demo.zentao.net/)、[pingcode](https://pingcode.com/)、飞书、钉钉等。大部分的项目管理工具内置的缺陷管理功能都会对缺陷划分成不同类型、严重等级、优先级别，以及不同的状态。

##### 缺陷类型

| bug类型    | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 功能缺陷   | 软件中的功能没有实现或不完善而导致<br>使用过程出现异常错误、逻辑错误等问题。 |
| 界面缺陷   | 用户界面外观缺失或不足，影响了用户正常使用的问题。<br>如：名称过长时被遮挡、文字部分被遮挡、图片只展示部分等。 |
| 需求缺陷   | 需求规格说明书未明确或存在遗留需求的问题。                   |
| 性能问题   | 不满足系统可测量的属性值，如执行时间、处理速度等。<br>如：一个功能被用户使用时没有响应，或需要用户等待时间过久等。 |
| 接口缺陷   | 与其他组件、模块或程序、调用参数或参数列表等不匹配、出现冲突问题。<br>如传参个数与接口不匹配、传参类型与接口不匹配等。 |
| 兼容性缺陷 | 软件运行环境不匹配的问题<br>如操作系统、浏览器、网络环境等不匹配 |
| 易用性缺陷 | 新用户对软件难以快速熟悉或难以快速上手使用的问题。           |
| 代码错误   | 不满足需求、功能实现错误；对产品或项目质量有影响的bug        |
| 配置相关   | 由于提供的配置不当或者配置不能够满足实际要求而出现的问题     |
| 安装部署   | 由于部署安装引起的问题                                       |
| 安全相关   | 出现安全隐患问题，如存在SQL注入，xss攻击等。                 |
| 标准规范   | 不符合相关的国际、国家标准规范或业界规范等                   |



##### 严重等级

| 等级           | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 致命缺陷（S1） | 软件任何一个主要功能完全丧失，用户数据受到破坏，软件崩溃、<br>悬挂或者危及用户人身安全。如软件崩溃造成硬件设备漏电等 |
| 严重缺陷（S2） | 软件的主要功能部分丧失，数据不能保存，软件的次要功能完全丧失，<br>系统所提供的功能或服务受到明显的影响。如软件的某个菜单不起作用 |
| 一般缺陷（S3） | 软件的次要功能没有完全实现，但不影响用户的正常使用。<br>如软件内的某些内容输入有误或无法输入。 |
| 较小缺陷（S4） | 用户体验不好或操作不方便，但不影响功能使用和运行。<br>如软件内出现错别字或排版有问题等。 |

##### 优先级别

| 优先级         | 描述                                                   |
| -------------- | ------------------------------------------------------ |
| 立即解决（P1） | 针对软件的致命缺陷，往往需要立即修复。                 |
| 优先解决（P2） | 针对软件的严重缺陷，影响了测试，需要优先修复。         |
| 等候解决（P3） | 针对软件的一般缺陷，需要正常排队等待修复。             |
| 建议解决（P4） | 针对软件的较小缺陷，可以在开发人员有时间时再进行修复。 |



##### 生命周期

从发现bug到关闭bug的这个时间段，我们称之为缺陷（bug）的生命周期。

![image-20220513060547806](assets/image-20220513060547806.png)

在整个bug处理的流程上，一般会把bug划分成多个不同状态。

| 状态                        | 描述                                                         |
| --------------------------- | ------------------------------------------------------------ |
| 新建（New）                 | 当bug首次被发现时，测试人员会确认并记录下来，并将bug的状态为New |
| 已指派（Assigned）          | 当bug被指认为New之后，将其传递给开发组，开发组将确认这是否是bug，如果是则开发组的leader会将bug指派给某位开发人员处理，并将bug的状态<br>设定为“Assigned”。 |
| 重新指派（Reassigned）      | bug被重新指派给某位开发人员处理处理。                        |
| 已打开（Open）              | 一旦开发人员开始处理bug，就将bug的状态设为“Open”。           |
| 已修复（Fixed）             | 当开发人员进行处理（并认为已经解决）之后，就可以将bug的状态设置为“Fixed”并将其提交给开发组leader，然后leader将bug返还给测试组。 |
| 等待再测试（Pending Reset） | 当bug被返还到测试组后，会将bug的状态设置为“Pending Reset”    |
| 再测试(Reset)               | 测试组的leader将bug指定给某位测试人员进行再测试，并将bug的状态设置为“Reset”。 |
| 已关闭的（Closed）          | 如测试人员经过再次测试之后确认bug已被解决，会将bug的状态设置为 “Closed”。 |
| 再次打开的（Reopen）        | 如果经过再次测试发现bug仍然存在的话，测试人员将bug再次传递给开发组，并将bug的状态设置为“Reopen” |
| 拒绝中（Pending Reject）    | 如果测试人员传递到开发组的bug被开发组认为不是bug时，这种情况下开发组可以拒绝，将bug的状态设置为“Pending Reject”并返还给测试组。 |
| 被拒绝的(Rejected)          | 测试组的负责人接到拒绝的bug时，如果发现并不能算作bug时，测试组负责人将bug的状态设置为“Rejected”。当然，无法重现，bug信息不足或重复的bug，有时候也会被拒绝。 |
| 延期（Postponed）           | 对于一些特殊的bug的测试需要搁置一段时间，这种情况下，bug的状态就被设置为“Postponed“。 |



#### 缺陷报告

缺陷报告，也叫bug报告，是软件测试人员重要的产出物之一，也是主要工作之一。一份高质量的缺陷报告可以帮助开发人员快速定位问题，修复Bug；也便于测试人员对缺陷进行统计、分析和跟踪管理，是测试人员和开发人员重要的沟通工具。开发中针对需求，测试bug，最怕的就是口口相传。

缺陷报告的基本组成：**缺陷ID**，**缺陷标题**，发现者，前置条件，是否可重现，操作系统，发现时间，所属项目，所属模块，所属版本，缺陷状态，**严重等级**，**优先级别**，**附件描述**，**重现步骤**，预期效果，实际效果等。注意：加粗部分为BUG六要素。

参考模板：

![img](assets/e2a4213e-757c-4e2b-b185-6c67a1887e961.gif)

缺陷报告就是软件测试的结果产出物，而如何验证和测试缺陷？那就要继续往下学习更多内容了。



### 测试原则

| 原则                         | 描述                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 测试显示软件存在缺陷         | 测试只能证明软件中存在缺陷，但并不能证明软件中不存在缺陷，即零缺陷是不可能的。<br>软件测试是为了降低存在缺陷的可能性，即便是没有找到缺陷，也不能证明软件是完美的。 |
| 穷尽测试是不可能的           | 现在软件的规模越来越大，复杂度越来越高，想做到完全性的测试是不可能的。<br>测试人员可以根据严重等级、优先级、场景、目的来分类别进行集中和高强度的测试，从而保证软件的质量。 |
| 测试尽早介入                 | 测试人员越早介入软件开发流程越好，最好在需求阶段就开始介入，使缺陷在需求或设计阶段就被发现，<br>缺陷发现越早，修复的成本就越小，反之，越晚发现修复成本就越高。 |
| 缺陷存在集群现象（二八定律） | 80%的缺陷往往存在于20%的模块中。一般项目复杂功能往往会占据所有功能的20%左右，而这20%的复杂功能往往有可能会包含大部分的缺陷。一个功能模块发现的缺陷频率越高，那存在的未被发现的缺陷出现频率也越高，故发现的缺陷与未发现的缺陷成正比。**开发团队里面最菜的人写的代码bug最多，开发团队里面负责开发功能最复杂难度最高的人bug最多**。 |
| 杀虫剂悖论                   | 反复使用相同的杀虫剂会导致害虫对杀虫剂产生免疫而无法杀死害虫，软件测试也一样。如果一直使用相同的测试方法或手段，可能无法发现新的bug。为了解决这个问题，测试用例应当定期修订和评审，增加新的或不同的测试用例帮助发现更多的缺陷。 |
| 测试依赖于环境               | 测试在不同环境（操作系统，浏览器，解释器）下是不同的。所以不应该以完全相同的⽅法去测试两个不同的系统。 |
| 不存在缺陷的谬论             | 与第一条类似，期望仅仅发现并修复⼤量缺陷就能确保系统的成功，这是⼀个谬论。 |



## 测试自动化

著名的敏捷开发布道师 Mike Cohn（迈克·科恩） 在他的着作《Succeeding with Agile》(中文名：《Scrum敏捷软件开发》)一书中提出了测试金字塔的概念。

![测试金字塔.jpg](assets/测试金字塔.jpg)

根据 Mike Cohn 的测试金字塔，测试的组合应该至少由以下三层组成 (自下往上分别是)：

-   单元测试（Unit Tests）
-   服务测试（Services Tests）
-   用户界面测试（UI Tests）

意思是，应该把测试不同粒度的测试分布到整个软件不同层次中，而随着层次越高，编写的测试内容应该越少，也就是写许多小而快的低层次单元测试，适当写一些更粗粒度的中层次接口测试或集成测试，写很少的高层次UI测试、系统测试或验收测试。

所以，根据测试金字塔理论，接下来我们按部就班对测试自动化的内容进行学习。



# 单元测试自动化

所谓的单元测试(Unit Test)是根据特定的输入数据，针对程序代码中的最小实体单元的输入输出的正确性进行验证测试的过程。所谓的最小实体单元就是组织项目代码的最基本代码结构：**函数，类，模块**等。在Python中比较知名的单元测试模块：

-   **unittest**
-   **pytest**
-   nose
-   doctest

```
php phpunit
java javaunit
```



## 测试用例

所谓的测试用例(Test Case)，就是执行测试的依据和记录，把测试应用程序的操作步骤**用文档的形式描述**出来的一份文档。文档的格式可以是Excel、markdown、html、xmind网页。

一份合格的测试用例有利于测试人员理清测试思路，确保需要测试的功能周全没有遗漏，方便测试工作的开展和评估测试工作量，同时还可以便于测试人员记录测试数据和测试工作进度，为后续的回归测试提供样本参考，提升测试效率以及后续测试工作的交接。

那么一份合格的测试用例长什么样子或有什么内容呢？

一份合格的测试用例，应该包含测试时间、测试人员、**测试模块名**、**功能点名称**、**用例ID**、**用例说明（测试目的）**、**前置条件**、**输入数据**、**预期结果**、**测试结果（输出结果、实际结果）**等。注意：加粗内容为必备的测试用例八要素。

参考文档：

![image-20220515072055298](assets/image-20220515072055298.png)

在实际工作中，因为缺陷报告与测试用例作用相似，因此有时候会合并一起或只选择其中一种。

### 设计方法

那么在工作中，我们一般都应该编写测试用例或者应该怎么设计测试用例来完成我们的测试工作呢？实际上在工作中，测试人员都是基于测试用例的7种基本设计方法来设计与编写测试用例的：

+   **等价类划分法**：根据输入数据的有效性与无效性设计测试用例。
+   边界值分析法：对等价类划分法的一个补充，从等价类的边缘值（临界点）去寻找错误，基于这些错误来设计测试用例。
+   **判定表法**：把输入数据的各种可能情况进行组合罗列成一个判断表，以判断表来设计测试用例。
+   因果图法：用图解的方式表示输入数据的各种组合关系，以此写出判定表，从而设计相应的测试用例。
+   正交表法：基于[正交表](http://support.sas.com/techsup/technote/ts723_Designs.txt)来设计测试用例。
+   场景法：基于流程图展示业务流程或功能的调用流程，对流程图的走向路径设计测试用例。
+   错误推测法：基于经验和直觉，找出程序中认为可能出现的错误来设计测试用例。

一般在工作中，我们比较常用的是等价类划分法与判定表法。

#### 等价类划分法

等价类划分法就是按照测试要求，把具有共同特征的测试数据划分为2类：有效等价类和无效等价类，把测试数据进行分类以后设计测试用例。

+   有效等价类，就是符合程序使用要求或调用代码要求的，能正确使用程序或调用代码的一类数据。
+   无效等价类，就是不符合程序使用要求或调用代码要求的，会导致程序出现异常或结果不正确的一类数据。

使用等价类划分法，可以让我们设计的测试工作更加科学有依据，避免出现穷举测试的情况，减少测试用例的数量。

例如，注册功能中用户名的测试用例，如果功能需求中，要求用户名必须长度为3-11个长度的字符。

| 系统模块 | 功能点   | 用例ID | 测试目的   | 前置条件         | 输入              | 预期 | 结果 |
| -------- | -------- | ------ | ---------- | ---------------- | ----------------- | ---- | ---- |
| 会员模块 | 用户注册 | 01     | 验证用户名 | 打开用户注册页面 | "abc"             | 正确 |      |
| 会员模块 | 用户注册 | 02     | 验证用户名 | 打开用户注册页面 | "abdefgthssaaaaa" | 错误 |      |



#### 判定表法

判定表是分析和表达多逻辑条件下执行不同操作的情况的工具。而软件测试中的判定表法，就是把输入数据的各种可能情况进行组合罗列成一个判断表格，以判断表来设计测试用例。

判定表的表结构一般有如下2种：横向判断表与纵向判定表。

横向判断表：

| 条件桩 | 条件项 |
| ------ | ------ |
| 动作桩 | 动作项 |

纵向判定表：

| 条件桩 | 动作桩 |
| ------ | ------ |
| 条件项 | 动作项 |



例子，测试一个功能是否能修改文件。

| 如果使用纵向判定表： |                 |                 |                 |
| -------------------- | --------------- | --------------- | --------------- |
| 条件1：是否有权限    | 条件2：是否存在 | 结果1：可以修改 | 结果2：不能修改 |
| √                    | √               | √               | ✖               |
| √                    | ✖               | ✖               | √               |
| ✖                    | √               | ✖               | √               |
| ✖                    | ✖               | ✖               | √               |



| 如果使用横向判断表： |      |      |      |      |
| -------------------- | ---- | ---- | ---- | ---- |
| 条件桩：是否有权限   | ✔    | ✔    | ✖    | ✖    |
| 条件桩：是否存在     | ✔    | ✖    | ✔    | ✖    |
| 动作桩：可以修改     | ✔    | ✖    | ✖    | ✖    |
| 动作桩：不能修改     | ✖    | ✔    | ✔    | ✔    |



## 单元测试框架-Unittest

Unittest是Python开发中常用于单元测试的内置框架，免安装使用简单方便，其设计的灵感来源于Java的单元测试框架-Junit。

Unittest具备完整的测试结构，支持自动化测试的执行，对测试用例进行组织，并且提供了丰富的断言方法，还提供生成测试报告。

官方文档：https://docs.python.org/zh-cn/3/library/unittest.html

```
import unittest
print(dir(unittest))
```

上面的代码中，我们就引入了Unittest模块， 同时可以通过打印发现Unittest框架中内置了大量的工具成员。这些工具成员中除了以下5个以外，其他的都不怎么常用。

+   TestCase（测试用例）

    是unittest中最重要的一个类，用于编写测试用例类，是所有测试用例类的父类，实现了测试用例的基本代码。

    

+   TestSuite（测试套件、测试集）

    可以把多个TestCase组织、打包集成到一个测试集中一起执行，TestSuite可以实现多个测试用例的执行。

    

+   TextTestRunner（测试运行器）

    TestSuite本身不具备执行的功能，所以使用TextTestRunner执行测试套件和输出测试结果。

    

+   TestLoader（测试加载器）

    用于加载测试用例TestCase，并生成测试套件TestSuite，实现自动从代码中加载**大量**测试用例到测试套件中。

    

+   TestFixture（测试脚手架）

    所谓的测试脚手架就是为了开展一项或多项测试所需要进行的准备工作，以及所有相关的清理操作。测试脚手架实际上会在执行一些测试代码之前与之后，让我们编写一些初始化和销毁的代码。



### 快速入门

#### 测试用例-TestCase

前面讲到TestCase就是提供给我们编写测试用例的测试代码的，那么怎么编写一个测试用例？需要4个步骤即可。

1.  导入unittest模块

    ```python
    import unittest
    ```

2.  定义测试用例类

    ```python
    import unittest
    class 测试用例类名(unittest.TestCase): # 所有的测试用例类都必须直接或者间接继承unittest.TestCase.
        """测试用例"""
        pass
    ```

3.  定义测试用例方法（此处的测试用例方法，就是上面所说的测试用例设计方法中的一行信息的测试代码）

    ```python
    import unittest
    class 测试用例类名(unittest.TestCase):
        """测试用例"""
        # ....
        def test_测试方法名(参数):  # 测试方法必须以test开头或test_开头
            pass
        # ....
    ```

4.  执行测试用例

    ```python
    unittest.main()
    ```

在实际工作中，我们肯定是在项目中进行测试代码的编写或单独编写一个测试项目，但是我们现在刚开始学习，所以我们可以先编写一个例子代码，对其进行测试，以达到学习的目的。

unittest_01_测试用例的编写.py，代码：

```python
import unittest

# 被测试的代码单元
def add(x,y):
    return x+y

class FuncTest(unittest.TestCase):
    """测试用例"""
    def test_01(self):
        print(add(10, 20))

    def test_02(self):
        print(add("hello", "world"))

    # def test_03(self):
    #     print(add("hello", 20))


# 因为pycharm本身内置了执行unittest的功能，所以不适用以下代码也能执行，但是终端下或者使用其他的代码编辑器时，则需要加上。
if __name__ == '__main__':
    unittest.main()
```



#### 测试套件-TestSuite

前面我们将到测试套件，主要用于把多个测试用例类打包集成到一个测试集中一起执行。工作中，一个项目往往需要编写非常多的测试用例，而那么多的测试用例也不可能只编写在一个文件中，此时就需要使用测试套件了。2个步骤：

1.  通过unittest.TestSuite实例化测试套件对象

    ```
    suite = unittest.TestSuite()
    ```

    

2.  通过addTest方法添加测试用例

    +   添加测试用例方法

        ```python
        # 添加测试用例方法
        suite.addtest(测试用例类名("测试用例方法名"))
        
        # 批量添加测试用例方法
        test_data = (测试用例类名("测试用例方法名1"), 测试用例类名("测试用例方法名2"))
        suite.addtests(test_data)
        ```

    +   添加测试用例类(一次性添加测试用例的所有test_方法)

        ```python
        # 添加测试用例类
        suite.addtest(unittest.makeSuite(测试用例类名))
        
        # 批量添加测试用例类
        test_data = (unittest.makeSuite(测试用例类名1),  unittest.makeSuite(测试用例类名2))
        suite.addTests(test_data)
        ```

unittest_02_测试套件的基本使用.py，代码：

```python
import unittest

import unittest_01_测试用例的编写 as unittest_01

suite = unittest.TestSuite()

# # 1. 添加测试用例方法
# suite.addTest(unittest_01.FuncTest("test_01"))
# suite.addTest(unittest_01.FuncTest("test_02"))

# # 2. 批量添加测试用例方法
# test_data = (unittest_01.FuncTest("test_01"), unittest_01.FuncTest("test_02"))
# suite.addTests(test_data)


# # 3. 添加测试用例类
# suite.addTest(unittest.makeSuite(unittest_01.FuncTest))


# 4. 批量添加测试用例类
test_data = (unittest.makeSuite(unittest_01.FuncTest),  unittest.makeSuite(unittest_01.FuncTest))
suite.addTests(test_data)
```

TestSuite的作用仅仅是把多个测试用例打包集成到一块，但是并没有提供批量执行测试用例的方法，所以我们需要使用TextTestRunner了。



#### 测试运行器-TextTestRunner

前面说过，TextTestRunner是用于执行测试用例、测试套件和输出测试结果的。2个步骤：

+   实例化运行器对象

+   通过run方法执行测试



unittest_03_测试运行器基本使用.py，代码：

```python
import unittest

import unittest_01_测试用例的编写 as unittest_01

suite = unittest.TestSuite()

# # 添加测试用例方法
# suite.addTest(unittest_01.FuncTest("test_01"))
# suite.addTest(unittest_01.FuncTest("test_02"))

# # 批量添加测试用例方法
# test_data = (unittest_01.FuncTest("test_01"), unittest_01.FuncTest("test_02"))
# suite.addTests(test_data)


# # 添加测试用例类
# suite.addTest(unittest.makeSuite(unittest_01.FuncTest))


# 批量添加测试用例类
test_data = (unittest.makeSuite(unittest_01.FuncTest),  unittest.makeSuite(unittest_01.FuncTest))
suite.addTests(test_data)

if __name__ == '__main__':
    runner = unittest.TextTestRunner()
    runner.run(suite)
```



####  测试加载器-TestLoader

前面说过，用于加载测试用例TestCase，并生成测试套件TestSuite，实现自动从代码中加载**大量**测试用例到测试套件中。2个步骤：

+   实例化unittest.TestLoader对象

    ```python
    loader = unittest.TestLoader()
    ```

+   使用discover方法自动搜索指定目录下指定文件格式的python模块，并把查找到的测试用例组装打包集成到测试组件作为返回值。

    ```python
    loader.discover(目录路径, pattern="文件名格式")
    ```

    注意：pattern支持`*`号表示0到多个字符。

unittest_04_测试加载器基本使用.py，代码：

```python
import unittest
loader = unittest.TestLoader()
# 在当前目录下，搜索以unittest开头作为文件名的所有python文件，并把文件中的测试用例类打包集成到测试套件中
suite =loader.discover("./", pattern="unittest*.py")

if __name__ == '__main__':
    runner = unittest.TextTestRunner()
    runner.run(suite)
```



#### 测试脚手架-TestFixture

前面提到，测试脚手架会在执行一些测试代码之前与之后，让我们编写一些初始化和销毁的代码，主要分三个级别：

+   方法级别：在方法执行前与执行后都提供自动调用的实例方法

    setUp和tearDown

+   类级别：在类执行前与执行后都提供自动调用的类方法，不管类中有多少方法，只执行一次。

    setUpClass和tearDownClass

+   模块级别：在模块执行前与执行后都提供自动调用的函数，不管模块中有多少类或方法，只执行一次。

    setUpModule和tearDownModule



##### 方法级别的脚手架

在测试用例类中提供了2个固定名字的实例方法（setUp与tearDown），用于完成方法执行前与执行后的操作。

unittest_05_测试脚手架_方法级别的脚手架.py，代码：

```python
import unittest

# 被测试的代码单元
def add(x,y):
    return x+y

class AddTest(unittest.TestCase):
    """测试用例"""
    def setUp(self):
        print("每个方法执行前都会执行一遍setUp实例方法，用于完成通用的前置操作或初始化工作")

    def tearDown(self):
        print("每个方法执行后都会执行一遍tearDown实例方法，用于完成通用的后置操作或销毁工作")

    def test_01(self):
        print(add(10, 20))

    def test_03(self):
        print(add("hello", 20))


# 因为pycharm本身内置了执行unittest的功能，所以不适用以下代码也能执行，但是终端下或者使用其他的代码编辑器时，则需要加上。
if __name__ == '__main__':
    unittest.main()
```



##### 类级别的脚手架

在测试用例类中提供了2个固定名字的类方法（setUpClass与tearDownClass），用于完成类执行前与执行后的操作。

unittest_06_测试脚手架_类级别的脚手架.py，代码：

```python
import unittest

# 被测试的代码单元
def add(x,y):
    return x+y

class AddTest(unittest.TestCase):
    """测试用例"""
    @classmethod
    def setUpClass(cls):
        print("当前类执行前都会执行一遍setUpClass类方法，用于完成通用的前置操作或初始化工作")

    @classmethod
    def tearDownClass(cls):
        print("当前类执行后都会执行一遍tearDownClass类方法，用于完成通用的后置操作或销毁工作")

    def test_01(self):
        print(add(10, 20))

    def test_03(self):
        print(add("hello", 20))


# 因为pycharm本身内置了执行unittest的功能，所以不适用以下代码也能执行，但是终端下或者使用其他的代码编辑器时，则需要加上。
if __name__ == '__main__':
    unittest.main()
```



##### 模块级别的脚手架

在测试用例类中提供了2个固定名字的函数（setUpModule与tearDownModule），用于完成类执行前与执行后的操作。

unittest_07_测试脚手架_模块级别的脚手架.py，代码：

```python
import unittest


def setUpModule():
    print("当前模块执行前都会执行一遍setUpModule函数，用于完成通用的前置操作或初始化工作")


def tearDownModule():
    print("当前模块执行后都会执行一遍tearDownModule函数，用于完成通用的前置操作或初始化工作")


# 被测试的代码单元
def add(x, y):
    return x + y


class AddTest1(unittest.TestCase):
    """测试用例"""

    @classmethod
    def setUpClass(cls):
        print("当前类执行前都会执行一遍setUpClass类方法，用于完成通用的前置操作或初始化工作")

    @classmethod
    def tearDownClass(cls):
        print("当前类执行后都会执行一遍tearDownClass类方法，用于完成通用的后置操作或销毁工作")

    def test_01(self):
        print(add(10, 20))


class AddTest2(unittest.TestCase):
    """测试用例"""

    @classmethod
    def setUpClass(cls):
        print("当前类执行前都会执行一遍setUp方法，用于完成通用的前置操作或初始化工作")

    @classmethod
    def tearDownClass(cls):
        print("当前类执行后都会执行一遍tearDown方法，用于完成通用的后置操作或销毁工作")

    def test_03(self):
        print(add("hello", "20"))


# 因为pycharm本身内置了执行unittest的功能，所以不适用以下代码也能执行，但是终端下或者使用其他的代码编辑器时，则需要加上。
if __name__ == '__main__':
    unittest.main()
```



#### 生成HTML格式测试报告(很少使用，基本不使用)

使用HTMLTestRunner模块可以直接生成HTML格式的报告。HTMLTestRunner是一个不再维护的第三方的模块，通过pip工具安装不了，只能下载后手动导入。

HTMLTestRunner官网：http://tungwaiyip.info/software/HTMLTestRunner.html

HTMLTestRunner下载：http://tungwaiyip.info/software/HTMLTestRunner_0_8_2/HTMLTestRunner.py

因为HTMLTestRunner是python2模块的，所以在python3.x以后需要做些修改才可以使用，修改后版本代码如下：

```python
"""
A TestRunner for use with the Python unit testing framework. It
generates a HTML report to show the result at a glance.

The simplest way to use this is to invoke its main method. E.g.

    import unittest
    import HTMLTestRunner

    ... define your tests ...

    if __name__ == '__main__':
        HTMLTestRunner.main()


For more customization options, instantiates a HTMLTestRunner object.
HTMLTestRunner is a counterpart to unittest's TextTestRunner. E.g.

    # output to a file
    fp = file('my_report.html', 'wb')
    runner = HTMLTestRunner.HTMLTestRunner(
                stream=fp,
                title='My unit test',
                description='This demonstrates the report output by HTMLTestRunner.'
                )

    # Use an external stylesheet.
    # See the Template_mixin class for more customizable options
    runner.STYLESHEET_TMPL = '<link rel="stylesheet" href="my_stylesheet.css" type="text/css">'

    # run the test
    runner.run(my_test_suite)


------------------------------------------------------------------------
Copyright (c) 2004-2007, Wai Yip Tung
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name Wai Yip Tung nor the names of its contributors may be
  used to endorse or promote products derived from this software without
  specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

# URL: http://tungwaiyip.info/software/HTMLTestRunner.html

__author__ = "Wai Yip Tung"
__version__ = "0.8.2"


"""
Change History

Version 0.8.2
* Show output inline instead of popup window (Viorel Lupu).

Version in 0.8.1
* Validated XHTML (Wolfgang Borgert).
* Added description of test classes and test cases.

Version in 0.8.0
* Define Template_mixin class for customization.
* Workaround a IE 6 bug that it does not treat <script> block as CDATA.

Version in 0.7.1
* Back port to Python 2.3 (Frank Horowitz).
* Fix missing scroll bars in detail log (Podi).
"""

# TODO: color stderr
# TODO: simplify javascript using ,ore than 1 class in the class attribute?

import datetime
import io
import sys
import time
import unittest
from xml.sax import saxutils


# ------------------------------------------------------------------------
# The redirectors below are used to capture output during testing. Output
# sent to sys.stdout and sys.stderr are automatically captured. However
# in some cases sys.stdout is already cached before HTMLTestRunner is
# invoked (e.g. calling logging.basicConfig). In order to capture those
# output, use the redirectors for the cached stream.
#
# e.g.
#   >>> logging.basicConfig(stream=HTMLTestRunner.stdout_redirector)
#   >>>

class OutputRedirector(object):
    """ Wrapper to redirect stdout or stderr """
    def __init__(self, fp):
        self.fp = fp

    def write(self, s):
        self.fp.write(s)

    def writelines(self, lines):
        self.fp.writelines(lines)

    def flush(self):
        self.fp.flush()

stdout_redirector = OutputRedirector(sys.stdout)
stderr_redirector = OutputRedirector(sys.stderr)



# ----------------------------------------------------------------------
# Template

class Template_mixin(object):
    """
    Define a HTML template for report customerization and generation.

    Overall structure of an HTML report

    HTML
    +------------------------+
    |<html>                  |
    |  <head>                |
    |                        |
    |   STYLESHEET           |
    |   +----------------+   |
    |   |                |   |
    |   +----------------+   |
    |                        |
    |  </head>               |
    |                        |
    |  <body>                |
    |                        |
    |   HEADING              |
    |   +----------------+   |
    |   |                |   |
    |   +----------------+   |
    |                        |
    |   REPORT               |
    |   +----------------+   |
    |   |                |   |
    |   +----------------+   |
    |                        |
    |   ENDING               |
    |   +----------------+   |
    |   |                |   |
    |   +----------------+   |
    |                        |
    |  </body>               |
    |</html>                 |
    +------------------------+
    """

    STATUS = {
    0: 'pass',
    1: 'fail',
    2: 'error',
    }

    DEFAULT_TITLE = 'Unit Test Report'
    DEFAULT_TESTER = 'Unit Test'
    DEFAULT_DESCRIPTION = ''

    # ------------------------------------------------------------------------
    # HTML Template

    HTML_TMPL = r"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>%(title)s</title>
    <meta name="generator" content="%(generator)s"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    %(stylesheet)s
</head>
<body>
<script language="javascript" type="text/javascript"><!--
output_list = Array();

/* level - 0:Summary; 1:Failed; 2:All */
function showCase(level) {
    trs = document.getElementsByTagName("tr");
    for (var i = 0; i < trs.length; i++) {
        tr = trs[i];
        id = tr.id;
        if (id.substr(0,2) == 'ft') {
            if (level < 1) {
                tr.className = 'hiddenRow';
            }
            else {
                tr.className = '';
            }
        }
        if (id.substr(0,2) == 'pt') {
            if (level > 1) {
                tr.className = '';
            }
            else {
                tr.className = 'hiddenRow';
            }
        }
    }
}


function showClassDetail(cid, count) {
    var id_list = Array(count);
    var toHide = 1;
    for (var i = 0; i < count; i++) {
        tid0 = 't' + cid.substr(1) + '.' + (i+1);
        tid = 'f' + tid0;
        tr = document.getElementById(tid);
        if (!tr) {
            tid = 'p' + tid0;
            tr = document.getElementById(tid);
        }
        id_list[i] = tid;
        if (tr.className) {
            toHide = 0;
        }
    }
    for (var i = 0; i < count; i++) {
        tid = id_list[i];
        if (toHide) {
            document.getElementById('div_'+tid).style.display = 'none'
            document.getElementById(tid).className = 'hiddenRow';
        }
        else {
            document.getElementById(tid).className = '';
        }
    }
}


function showTestDetail(div_id){
    var details_div = document.getElementById(div_id)
    var displayState = details_div.style.display
    // alert(displayState)
    if (displayState != 'block' ) {
        displayState = 'block'
        details_div.style.display = 'block'
    }
    else {
        details_div.style.display = 'none'
    }
}


function html_escape(s) {
    s = s.replace(/&/g,'&amp;');
    s = s.replace(/</g,'&lt;');
    s = s.replace(/>/g,'&gt;');
    return s;
}

/* obsoleted by detail in <div>
function showOutput(id, name) {
    var w = window.open("", //url
                    name,
                    "resizable,scrollbars,status,width=800,height=450");
    d = w.document;
    d.write("<pre>");
    d.write(html_escape(output_list[id]));
    d.write("\n");
    d.write("<a href='javascript:window.close()'>close</a>\n");
    d.write("</pre>\n");
    d.close();
}
*/
--></script>

%(heading)s
%(report)s
%(ending)s

</body>
</html>
"""
    # variables: (title, generator, stylesheet, heading, report, ending)


    # ------------------------------------------------------------------------
    # Stylesheet
    #
    # alternatively use a <link> for external style sheet, e.g.
    #   <link rel="stylesheet" href="$url" type="text/css">

    STYLESHEET_TMPL = """
<style type="text/css" media="screen">
body        { font-family: verdana, arial, helvetica, sans-serif; font-size: 80%; }
table       { font-size: 100%; }
pre         { }

/* -- heading ---------------------------------------------------------------------- */
h1 {
  font-size: 16pt;
  color: gray;
}
.heading {
    margin-top: 0ex;
    margin-bottom: 1ex;
}

.heading .attribute {
    margin-top: 1ex;
    margin-bottom: 0;
}

.heading .description {
    margin-top: 4ex;
    margin-bottom: 6ex;
}

/* -- css div popup ------------------------------------------------------------------------ */
a.popup_link {
}

a.popup_link:hover {
    color: red;
}

.popup_window {
    display: none;
    position: relative;
    left: 0px;
    top: 0px;
    /*border: solid #627173 1px; */
    padding: 10px;
    background-color: #E6E6D6;
    font-family: "Lucida Console", "Courier New", Courier, monospace;
    text-align: left;
    font-size: 8pt;
    width: 500px;
}

}
/* -- report ------------------------------------------------------------------------ */
#show_detail_line {
    margin-top: 3ex;
    margin-bottom: 1ex;
}
#result_table {
    width: 80%;
    border-collapse: collapse;
    border: 1px solid #777;
}
#header_row {
    font-weight: bold;
    color: white;
    background-color: #777;
}
#result_table td {
    border: 1px solid #777;
    padding: 2px;
}
#total_row  { font-weight: bold; }
.passClass  { background-color: #6c6; }
.failClass  { background-color: #c60; }
.errorClass { background-color: #c00; }
.passCase   { color: #6c6; }
.failCase   { color: #c60; font-weight: bold; }
.errorCase  { color: #c00; font-weight: bold; }
.hiddenRow  { display: none; }
.testcase   { margin-left: 2em; }


/* -- ending ---------------------------------------------------------------------- */
#ending {
}

</style>
"""



    # ------------------------------------------------------------------------
    # Heading
    #

    HEADING_TMPL = """<div class='heading'>
<h1>%(title)s</h1>
%(parameters)s
<p class='description'>%(description)s</p>
</div>

""" # variables: (title, parameters, description)

    HEADING_ATTRIBUTE_TMPL = """<p class='attribute'><strong>%(name)s:</strong> %(value)s</p>
""" # variables: (name, value)



    # ------------------------------------------------------------------------
    # Report
    #

    REPORT_TMPL = """
<p id='show_detail_line'>Show
<a href='javascript:showCase(0)'>Summary</a>
<a href='javascript:showCase(1)'>Failed</a>
<a href='javascript:showCase(2)'>All</a>
</p>
<table id='result_table'>
<colgroup>
<col align='left' />
<col align='right' />
<col align='right' />
<col align='right' />
<col align='right' />
<col align='right' />
</colgroup>
<tr id='header_row'>
    <td>Test Group/Test case</td>
    <td>Count</td>
    <td>Pass</td>
    <td>Fail</td>
    <td>Error</td>
    <td>View</td>
</tr>
%(test_list)s
<tr id='total_row'>
    <td>Total</td>
    <td>%(count)s</td>
    <td>%(Pass)s</td>
    <td>%(fail)s</td>
    <td>%(error)s</td>
    <td>&nbsp;</td>
</tr>
</table>
""" # variables: (test_list, count, Pass, fail, error)

    REPORT_CLASS_TMPL = r"""
<tr class='%(style)s'>
    <td>%(desc)s</td>
    <td>%(count)s</td>
    <td>%(Pass)s</td>
    <td>%(fail)s</td>
    <td>%(error)s</td>
    <td><a href="javascript:showClassDetail('%(cid)s',%(count)s)">Detail</a></td>
</tr>
""" # variables: (style, desc, count, Pass, fail, error, cid)


    REPORT_TEST_WITH_OUTPUT_TMPL = r"""
<tr id='%(tid)s' class='%(Class)s'>
    <td class='%(style)s'><div class='testcase'>%(desc)s</div></td>
    <td colspan='5' align='center'>

    <!--css div popup start-->
    <a class="popup_link" onfocus='this.blur();' href="javascript:showTestDetail('div_%(tid)s')" >
        %(status)s</a>

    <div id='div_%(tid)s' class="popup_window">
        <div style='text-align: right; color:red;cursor:pointer'>
        <a onfocus='this.blur();' onclick="document.getElementById('div_%(tid)s').style.display = 'none' " >
           [x]</a>
        </div>
        <pre>
        %(script)s
        </pre>
    </div>
    <!--css div popup end-->

    </td>
</tr>
""" # variables: (tid, Class, style, desc, status)


    REPORT_TEST_NO_OUTPUT_TMPL = r"""
<tr id='%(tid)s' class='%(Class)s'>
    <td class='%(style)s'><div class='testcase'>%(desc)s</div></td>
    <td colspan='5' align='center'>%(status)s</td>
</tr>
""" # variables: (tid, Class, style, desc, status)


    REPORT_TEST_OUTPUT_TMPL = r"""
%(id)s: %(output)s
""" # variables: (id, output)



    # ------------------------------------------------------------------------
    # ENDING
    #

    ENDING_TMPL = """<div id='ending'>&nbsp;</div>"""

# -------------------- The end of the Template class -------------------


TestResult = unittest.TestResult

class _TestResult(TestResult):
    # note: _TestResult is a pure representation of results.
    # It lacks the output and reporting ability compares to unittest._TextTestResult.

    def __init__(self, verbosity=1):
        TestResult.__init__(self)
        self.stdout0 = None
        self.stderr0 = None
        self.success_count = 0
        self.failure_count = 0
        self.error_count = 0
        self.verbosity = verbosity

        # result is a list of result in 4 tuple
        # (
        #   result code (0: success; 1: fail; 2: error),
        #   TestCase object,
        #   Test output (byte string),
        #   stack trace,
        # )
        self.result = []


    def startTest(self, test):
        TestResult.startTest(self, test)
        # just one buffer for both stdout and stderr
        self.outputBuffer = io.StringIO()
        stdout_redirector.fp = self.outputBuffer
        stderr_redirector.fp = self.outputBuffer
        self.stdout0 = sys.stdout
        self.stderr0 = sys.stderr
        sys.stdout = stdout_redirector
        sys.stderr = stderr_redirector


    def complete_output(self):
        """
        Disconnect output redirection and return buffer.
        Safe to call multiple times.
        """
        if self.stdout0:
            sys.stdout = self.stdout0
            sys.stderr = self.stderr0
            self.stdout0 = None
            self.stderr0 = None
        return self.outputBuffer.getvalue()


    def stopTest(self, test):
        # Usually one of addSuccess, addError or addFailure would have been called.
        # But there are some path in unittest that would bypass this.
        # We must disconnect stdout in stopTest(), which is guaranteed to be called.
        self.complete_output()


    def addSuccess(self, test):
        self.success_count += 1
        TestResult.addSuccess(self, test)
        output = self.complete_output()
        self.result.append((0, test, output, ''))
        if self.verbosity > 1:
            sys.stderr.write('ok ')
            sys.stderr.write(str(test))
            sys.stderr.write('\n')
        else:
            sys.stderr.write('.')

    def addError(self, test, err):
        self.error_count += 1
        TestResult.addError(self, test, err)
        _, _exc_str = self.errors[-1]
        output = self.complete_output()
        self.result.append((2, test, output, _exc_str))
        if self.verbosity > 1:
            sys.stderr.write('E  ')
            sys.stderr.write(str(test))
            sys.stderr.write('\n')
        else:
            sys.stderr.write('E')

    def addFailure(self, test, err):
        self.failure_count += 1
        TestResult.addFailure(self, test, err)
        _, _exc_str = self.failures[-1]
        output = self.complete_output()
        self.result.append((1, test, output, _exc_str))
        if self.verbosity > 1:
            sys.stderr.write('F  ')
            sys.stderr.write(str(test))
            sys.stderr.write('\n')
        else:
            sys.stderr.write('F')


class HTMLTestRunner(Template_mixin):
    """
    """
    def __init__(self, stream=sys.stdout, verbosity=1, title=None, description=None, tester=None):
        self.stream = stream
        self.verbosity = verbosity
        if title is None:
            self.title = self.DEFAULT_TITLE
        else:
            self.title = title
        if description is None:
            self.description = self.DEFAULT_DESCRIPTION
        else:
            self.description = description

        self.startTime = datetime.datetime.now()
        if tester is None:
            self.tester = self.DEFAULT_TITLE
        else:
            self.tester = tester

    def run(self, test):
        "Run the given test case or test suite."
        result = _TestResult(self.verbosity)
        test(result)
        self.stopTime = datetime.datetime.now()
        self.generateReport(test, result)
        print (sys.stderr, "\nTime Elapsed: %s" %(self.stopTime-self.startTime))
        return result


    def sortResult(self, result_list):
        # unittest does not seems to run in any particular order.
        # Here at least we want to group them together by class.
        rmap = {}
        classes = []
        for n,t,o,e in result_list:
            cls = t.__class__
            if not cls in rmap:
                rmap[cls] = []
                classes.append(cls)
            rmap[cls].append((n,t,o,e))
        r = [(cls, rmap[cls]) for cls in classes]
        return r


    def getReportAttributes(self, result):
        """
        Return report attributes as a list of (name, value).
        Override this to add custom attributes.
        """
        startTime = str(self.startTime)[:19]
        duration = str(self.stopTime - self.startTime)
        status = []
        if result.success_count: status.append('Pass %s'    % result.success_count)
        if result.failure_count: status.append('Failure %s' % result.failure_count)
        if result.error_count:   status.append('Error %s'   % result.error_count  )
        if status:
            status = ' '.join(status)
        else:
            status = 'none'
        return [
            ('Start Time', startTime),
            ('Duration', duration),
            ('Status', status),
            ('Tester', self.tester),
        ]


    def generateReport(self, test, result):
        report_attrs = self.getReportAttributes(result)
        generator = 'HTMLTestRunner %s' % __version__
        stylesheet = self._generate_stylesheet()
        heading = self._generate_heading(report_attrs)
        report = self._generate_report(result)
        ending = self._generate_ending()
        output = self.HTML_TMPL % dict(
            title = saxutils.escape(self.title),
            generator = generator,
            stylesheet = stylesheet,
            heading = heading,
            report = report,
            ending = ending,
        )
        self.stream.write(output.encode('utf8'))


    def _generate_stylesheet(self):
        return self.STYLESHEET_TMPL


    def _generate_heading(self, report_attrs):
        a_lines = []
        for name, value in report_attrs:
            line = self.HEADING_ATTRIBUTE_TMPL % dict(
                    name = saxutils.escape(name),
                    value = saxutils.escape(value),
                )
            a_lines.append(line)
        heading = self.HEADING_TMPL % dict(
            title = saxutils.escape(self.title),
            parameters = ''.join(a_lines),
            description = saxutils.escape(self.description),
        )
        return heading


    def _generate_report(self, result):
        rows = []
        sortedResult = self.sortResult(result.result)
        for cid, (cls, cls_results) in enumerate(sortedResult):
            # subtotal for a class
            np = nf = ne = 0
            for n,t,o,e in cls_results:
                if n == 0: np += 1
                elif n == 1: nf += 1
                else: ne += 1

            # format class description
            if cls.__module__ == "__main__":
                name = cls.__name__
            else:
                name = "%s.%s" % (cls.__module__, cls.__name__)
            doc = cls.__doc__ and cls.__doc__.split("\n")[0] or ""
            desc = doc and '%s: %s' % (name, doc) or name

            row = self.REPORT_CLASS_TMPL % dict(
                style = ne > 0 and 'errorClass' or nf > 0 and 'failClass' or 'passClass',
                desc = desc,
                count = np+nf+ne,
                Pass = np,
                fail = nf,
                error = ne,
                cid = 'c%s' % (cid+1),
            )
            rows.append(row)

            for tid, (n,t,o,e) in enumerate(cls_results):
                self._generate_report_test(rows, cid, tid, n, t, o, e)

        report = self.REPORT_TMPL % dict(
            test_list = ''.join(rows),
            count = str(result.success_count+result.failure_count+result.error_count),
            Pass = str(result.success_count),
            fail = str(result.failure_count),
            error = str(result.error_count),
        )
        return report


    def _generate_report_test(self, rows, cid, tid, n, t, o, e):
        # e.g. 'pt1.1', 'ft1.1', etc
        has_output = bool(o or e)
        tid = (n == 0 and 'p' or 'f') + 't%s.%s' % (cid+1,tid+1)
        name = t.id().split('.')[-1]
        doc = t.shortDescription() or ""
        desc = doc and ('%s: %s' % (name, doc)) or name
        tmpl = has_output and self.REPORT_TEST_WITH_OUTPUT_TMPL or self.REPORT_TEST_NO_OUTPUT_TMPL

        # o and e should be byte string because they are collected from stdout and stderr?
        if isinstance(o,str):
            # TODO: some problem with 'string_escape': it escape \n and mess up formating
            # uo = unicode(o.encode('string_escape'))
            uo=o
        else:
            uo = o

        ue = e

        script = self.REPORT_TEST_OUTPUT_TMPL % dict(
            id = tid,
            output = saxutils.escape(uo+ue),
        )

        row = tmpl % dict(
            tid = tid,
            Class = (n == 0 and 'hiddenRow' or 'none'),
            style = n == 2 and 'errorCase' or (n == 1 and 'failCase' or 'none'),
            desc = desc,
            script = script,
            status = self.STATUS[n],
        )
        rows.append(row)
        if not has_output:
            return

    def _generate_ending(self):
        return self.ENDING_TMPL


##############################################################################
# Facilities for running tests from the command line
##############################################################################

# Note: Reuse unittest.TestProgram to launch test. In the future we may
# build our own launcher to support more specific command line
# parameters like test title, CSS, etc.
class TestProgram(unittest.TestProgram):
    """
    A variation of the unittest.TestProgram. Please refer to the base
    class for command line parameters.
    """
    def runTests(self):
        # Pick HTMLTestRunner as the default test runner.
        # base class's testRunner parameter is not useful because it means
        # we have to instantiate HTMLTestRunner before we know self.verbosity.
        if self.testRunner is None:
            self.testRunner = HTMLTestRunner(verbosity=self.verbosity)
        unittest.TestProgram.runTests(self)

main = TestProgram

##############################################################################
# Executing this module from the command line
##############################################################################

if __name__ == "__main__":
    main(module=None)
```



打印HTML格式的测试报告，unittest_08_打印HTML格式的测试报告.py，代码：

```python
import unittest
from HTMLTestRunner import HTMLTestRunner
import unittest_01_测试用例的编写 as unittest_01

suite = unittest.TestSuite()

test_data = (unittest.makeSuite(unittest_01.FuncTest),  unittest.makeSuite(unittest_01.FuncTest))
suite.addTests(test_data)

if __name__ == '__main__':
    # 生成html报告
    with open("test_report.html", "wb") as file:
        runner = HTMLTestRunner(
            stream=file,
            title="单元测试的HTML格式报告",
            description="python单元测试报告",
            tester="墨落"
        )
        runner.run(suite)
```



#### 断言

断言(assertion)是一种在程序中的判断测试用例执行结果是否符合预期结果的方式，所以断言也被称之为“期望”。当程序执行到断言的位置时，对应的断言应该为真。若断言不为真时，程序会中止执行，并给出错误信息。

unittest中常用的断言方法（加粗为重要方法）：

| 断言方法                                 | 断言描述                               |
| :--------------------------------------- | :------------------------------------- |
| **assertEqual(arg1, arg2, msg=None)**    | 验证arg1=arg2，不等则fail              |
| **assertNotEqual(arg1, arg2, msg=None)** | 验证arg1 != arg2, 相等则fail           |
| **assertTrue(expr, msg=None)**           | 验证expr是true，如果为false，则fail    |
| **assertFalse(expr,msg=None)**           | 验证expr是false，如果为true，则fail    |
| **assertIs(arg1, arg2, msg=None)**       | 验证arg1、arg2是同一个对象，不是则fail |
| **assertIsNot(arg1, arg2, msg=None)**    | 验证arg1、arg2不是同一个对象，是则fail |
| **assertIsNone(expr, msg=None)**         | 验证expr是None，不是则fail             |
| **assertIsNotNone(expr, msg=None)**      | 验证expr不是None，是则fail             |
| **assertIn(arg1, arg2, msg=None)**       | 验证arg1是arg2的子串，不是则fail       |
| **assertNotIn(arg1, arg2, msg=None)**    | 验证arg1不是arg2的子串，是则fail       |
| assertIsInstance(obj, cls, msg=None)     | 验证obj是cls的实例，不是则fail         |
| assertNotIsInstance(obj, cls, msg=None)  | 验证obj不是cls的实例，是则fail         |



unittest_09_断言.py，代码：

```python
import unittest

def add(x ,y):
    return x + y


class AddTest(unittest.TestCase):
    def test_01(self):
        res = add(1,2)
        # 断言结果是否与预期内容相同
        # self.assertEqual(res, 3, msg="断言失败！一般会错误的结果与原因")
        # self.assertEqual(res, 2, msg="断言失败！一般会错误的结果与原因")
        self.assertIn(res, [1, 2], msg="断言失败！一般会错误的结果与原因")

if __name__ == '__main__':
    unittest.main()

```



#### 跳过

针对开发中有时候针对不同环境或者不同的时间段，不同的代码版本，有时候部分测试用例不希望被执行，则可以使用跳过。

```python
@unittest.skipIf(判断条件表达式, 跳过原因)
```

unittest_10_跳过.py，代码：

```python
import unittest


def add(x, y):
    return x + y


version = (2, 7, 0)

class AddTest(unittest.TestCase):
    def setUp(self):
        print("setUP执行....")

    @unittest.skipIf(version <= (3, 5, 0), "版本低于3.5，所以不测试test_01")
    def test_01(self):
        res = add(1, 2)
        self.assertIn(res, [1, 3], msg="断言失败！一般会错误的结果与原因")

    def test_02(self):
        res = add("a", "B")
        self.assertEqual(res, "aB", msg="断言失败！一般会错误的结果与原因")


if __name__ == '__main__':
    unittest.main()

```





#### 参数化

当需要使用多组不同的测试数据测试同一个方法时，可以使用unittest参数化来解决。常用的参数化方法有ddt、parameterized

```python
pip install parameerized
```

unittest_11_参数化.py，代码：

```python
import unittest
from parameterized import parameterized

def add(x, y):
    return x + y


version = (2, 7, 0)

class AddTest(unittest.TestCase):
    def setUp(self):
        print("setUP执行....")

    @parameterized.expand([(10,20), ("a","B"), (50, 20)])
    def test_00(self, x, y):
        res = add(x, y)
        self.assertIn(res, [1, 30, "aB", 70], msg="断言失败！一般会错误的结果与原因")


    # def test_01(self):
    #     res = add(1, 2)
    #     self.assertIn(res, [1, 3], msg="断言失败！一般会错误的结果与原因")
    #
    # def test_02(self):
    #     res = add("a", "B")
    #     self.assertEqual(res, "aB", msg="断言失败！一般会错误的结果与原因")
    #
    # def test_03(self):
    #     print(add("a", 20))

if __name__ == '__main__':
    unittest.main()
```



### 数据驱动测试

Data-Driven Tests（DDT）即数据驱动测试，可以实现多个数据对同一个方法进行测试，达到数据和测试代码分离，目的是为了减少测试用例的数量。

基本安装

```python
pip install ddt
```

直接传递单个数据

unittest_12_参数化_基于ddt直接传递数据.py，代码：

```python
import unittest
from ddt import ddt, data

def add(a,b):
    return a+b

@ddt
class AddTest(unittest.TestCase):
    # # 单次传递一个数据到测试用例方法中
    # @data(100)
    # @data([1,2,3,4])
    # @data({"a":1,"b":2})
    # @data((1,2,3))

    # # 多次传递一个数据到测试用例方法中
    # @data(*["a","b","c"]) # 字符串
    # @data(*[{"a":1}, {"a":2}, {"a":3}]) # 字典
    # @data(*[[1, 1, 1], [1, 1, 2], [1, 1, 3]])
    @data([1, 1, 1], [1, 1, 2], [1, 1, 3])
    def test_01(self, a):
        print(a)


if __name__ == '__main__':
    unittest.main()
    
-------------------------------------------------------自己的
import unittest
from ddt import ddt,data

def add(a,b):
    return a+b

@ddt
class AddTest(unittest.TestCase):
    # # 单次传递一个数据到测试用例方法中
    @data([1, 1], [1, 2], [1, 3])
    def test_01(self, a):
        print(a)
        ret = add(*a)
        print(ret)


if __name__ == '__main__':
    unittest.main()
```

unittest_13_参数化-基于ddt解包传递多个数据.py，使用unpack装饰器解包数据

```python
import unittest
from ddt import ddt, data, unpack

def add(a, b, c):
    return a + b + c

@ddt
class AddTest(unittest.TestCase):
    @data((1,2,3),(1,2,1),(1,3,1),(1,1,3))
    @unpack
    def test_01(self,a,b,c):
        add(a,b,c)

if __name__ == '__main__':
    unittest.main()
```





## 单元测试框架-Pytest

Pytest是基于Python语言的单元测试框架，也是一个命令行的工具，比 unittest 测试框架更灵活。具有以下特点：

1.  入门简单，易上手，官方文档丰富而且使用广泛，有大量的参数例子。
2.  unittest有的，它都有，而且支持更为复杂的功能测试
3.  支持大量第三方插件，如：失败重试、控制用例执行顺序等。
4.  基于配置文件可以很简单的集成CI（持续集成）工具中。

安装

```python
pip install pytest
```



### 快速入门

#### 基本格式

pytest_01_基本格式.py，代码：

```python
def add(x, y):
    return x + y

class TestAddFunc(object):  # 测试用例类名必须用Test开头
    def test_01(self):   # 方法名与函数名必须要用test_开头
        print(add(10, 20))

    def test_02(self):
        print(add("a", "B"))

    def test_03(self):
        print(add("a", 20))
```

#### 测试运行

pytest提供了三种方式给测试人员执行测试用例：

+ **命令行运行**

  ```python
  pytest -s 文件名
  pytest -s -v 文件名
  # -s 输出测试用例的print语句打印的信息
  # -v 输出执行的测试用用例的类名以及方法名
  # -x 一旦发现失败用例，立即停止继续运行
  # -maxfail=2 当测试遇到2条失败用例，立即停止继续运行
  ```

  

+   Pycharm运行

    file -> settings，打开配置窗口。

    ![image-20220515134914741](assets/image-20220515134914741.png)

+   main函数运行（基本不用）

    ```python
    pytest.main(["模块文件名::类名::方法名", "参数"])
    pytest.main(["pytest_01_基本格式.py::TEstAddFunc::test_01", "-sv"])
    ```



#### 测试脚手架

方法级别：setup与teardown

类级别：setup_class与teardown_class，注意：这是实例方法，不是类方法

模块级别：setup_module与teardown_module

pytest_02_测试脚手架.py，代码：

```python
def add(x, y):
    return x + y


def setup_module():
    print("模块执行初始化操作")

def teardown_module():
    print("模块执行初始化putest")

class TestAddFunc(object):  # 测试用例类名必须用Test开头
    def setup(self):
        print('setup执行初始化操作')
    def teardown(self):
        print('teardown执销毁操作')

    def setup_class(self):    # 注意：此处方法类型是实例方法。
        print('类级别：setup_class执行初始化操作')

    def teardown_class(self):  # 注意：此处方法类型是实例方法。
        print('类级别：teardown_class执行初始化操作')



    def test_01(self):   # 方法名与函数名必须要用test_开头
        print(add(10, 20))

    def test_02(self):
        print(add("a", "B"))

    def test_03(self):
        print(add(20, 20))

```



#### 基于配置文件运行pytest

在pytest提供的终端运行测试用例的方式的基础上，pytest还支持使用配置文件来简化运行参数。

可以通过pytest --help 查看pytest配置文件的名：**pytest.ini**、tox.ini、**setup.cfg**。

配置文件一般保存在项目根目录下。

pytest.ini，配置文件格式：

```ini
; 命名空间，表示以下选项属于pytest配置
[pytest]
; 运行参数
addopts = -s -v
; 匹配搜索的测试文件的目录路径
testpaths = ./
; 匹配搜索的测试文件名格式
python_files = test_*.py
; 匹配搜索的测试类格式
python_classes = Test*
; 匹配搜索的测试方法名格式
python_functions = test_*
; markers
markers = "测试标记-一般就是本轮测试的项目名或者模块"
```

上面的注释，必须清除否则报错。有了配置文件以后，使用pytest命令即可运行测试用例。

```bash
pytest
```



#### 断言

Pytest的断言比unittest提供的断言更加简单易用，仅仅只需要使用assert关键字，后续跟上python原生的表达式即可。

```python
assert "m" in "moluo"
assert "m" not in "moluo"
assert 1 == 2
assert 1 != 1
assert 1 > 2
assert not True
assert type(1) is int
assert type(1) not is int  # 提示语法错误 改成 is not
```

方法	描述
assert a==b	a、b是否相等
assert a！=b	a、b是否不相等
assert a<=b	a是否小于等于b
assert a>=b	a是否大于等于b
assert a in b	b是否包含a
assert a not in b	b是否不包含a
assert a	       判断a是否为True
assert a is True	判断a是否为True
assert not a	判断a是否不为True
assert a is not True	判断是否不为True
assert a is Flase	判断是否为Flase
————————————————

pytest_03_断言.py，代码：

```python
def add(x, y):
    return x + y


class TestAddFunc(object):  # 测试用例类名必须用Test开头
    def test_01(self):   # 方法名与函数名必须要用test_开头
        res = add(10, 20)
        assert res == 30

    def test_02(self):
        res = add("a", "B")
        assert type(res) is int

    def test_03(self):
        res = add(20, 20)
        assert res != 20
```



#### 跳过

根据特定的条件，不执行标识的测试函数。

```python
@pytest.mark.skipif(判断条件, reason="跳过原因")
```

pytest_04_跳过.py，代码：

```python
import pytest


def add(x, y):
    return x + y

version = (2, 7, 12)

class TestAddFunc(object):  # 测试用例类名必须用Test开头
    def test_01(self):   # 方法名与函数名必须要用test_开头
        res = add(10, 20)
        assert res == 30

    @pytest.mark.skipif(version <= (2, 7, 12), reason="高于2.7.12，不测试test_02")
    def test_02(self):
        res = add("a", "B")
        assert type(res) is int

    def test_03(self):
        res = add(20, 20)
        assert res != 20
```



#### 参数化

pytest也支持参数化操作，而且不需要安装任何第三方模块即可使用，也不再需要ddt。

```python
import pytest


def add(x, y):
    return x + y


class TestAddFunc(object):  # 测试用例类名必须用Test开头
    @pytest.mark.parametrize("x,y", [(10, 20), {"x":10, "y":20}, ("a", "b"), ("a", 20)])
    def test_01(self, x, y):   # 方法名与函数名必须要用test_开头
        res = add(x, y)
        assert res == 30
```



### 进阶使用

#### fixture-脚手架

在Unittest中我们经常需要针对不同的测试用例使用脚手架完成一些测试的前置与后置操作，但是很多测试用例的前置与后置操作基本一样，所以pytest提供的fixture脚手架相比Unittest提供的脚手架进行了显著改进：

1. 有独立的命名，并通过声明它们从测试函数、模块、类或整个项目中的使用来激活脚手架。
2. 也可以按模块化的方式实现，每个fixture脚手架都可以在各个测试用例之间互相调用。
3. fixture的范围从简单的单元测试到复杂的功能测试，可以对fixture配置参数，或者跨函数function，类class，模块module或整个测试项目范围session。

pytest的fixture有个scope参数可以控制fixture的作用范围（从大到小）：session>module>class>function。

```
session：是多个文件调用一次，可以跨.py文件调用，每个.py文件就是module
module：每一个.py文件调用一次，该文件内又有多个function和class
class：每一个类调用一次，一个类中可以有多个方法
function：每一个函数或方法都会调用
```

##### 实现参数化效果

```python
import pytest


# 类级别的脚手架
@pytest.fixture(scope="class")
def fixture_01_data():  # 建议脚手架的函数名以fixture开头.
    a = 10
    b = 20
    print("脚手架运行了!")
    return a, b  # 脚手架的函数可以有返回值，也可以没有返回值


# 被测试的代码单元
def add(x, y):
    return x + y


class TestAddFunc(object):
    def test_01(self, fixture_01_data):  # 此处的参数名，就是上面的脚手架名称，注意：参数名要与上面的脚手架函数保持一致
        print(f"fixture_01_data={fixture_01_data}")
        res = add(fixture_01_data[0], fixture_01_data[1])
        assert res == 30

```



##### 使用装饰器修饰用例实现参数化效果

```python
import pytest


@pytest.fixture(scope="class")
def fixture_01_data():
    print("fixture_01_data")
    a = 10
    b = 20
    return a, b

@pytest.fixture(scope="class")
def fixture_02_data():
    print("fixture_02_data")
    a = "10"
    b = "20"
    return a, b


def add(x, y):
    return x + y


@pytest.mark.usefixtures("fixture_01_data")  #  此处参数为脚手架函数名
@pytest.mark.usefixtures("fixture_02_data")  #  
class TestAddFunc(object):
    def test_01(self, fixture_01_data):
        res = add(fixture_01_data[0], fixture_01_data[1])
        assert res == 30

    def test_02(self, fixture_02_data):
        res = add(fixture_02_data[0], fixture_02_data[1])
        assert res == 30

```



##### fixture自动执行

fixture提供了autouse=True的参数选项，让我们可以不需要装饰，就可以直接自动执行。

代码：

```python
import pytest


@pytest.fixture(scope="class", autouse=True)
def fixture_01_data():
    print("fixture_01_data")
    a = 10
    b = 20
    return a, b


@pytest.fixture(scope="class", autouse=True)
def fixture_02_data():
    print("fixture_02_data")
    a = "10"
    b = "20"
    return a, b


def add(x, y):
    return x + y

@pytest.mark.usefixtures("fixture_01_data")  #  这两个装饰器可以省略
@pytest.mark.usefixtures("fixture_02_data")
class TestAddFunc(object):
    def test_01(self, fixture_01_data):
        res = add(fixture_01_data[0], fixture_01_data[1])
        assert res == 30

    def test_02(self, fixture_02_data):
        res = add(fixture_02_data[0], fixture_02_data[1])
        assert res == 30
```



##### 使用yield实现setup/teardown效果

pytest的fixture不仅可以在单元测试、集成测试中被广泛使用，甚至在UI测试或系统测试中也会经常用到，针对UI测试或系统测试中的功能测流或流程测试，总是经常需要打开相关环境，例如：web项目进行UI测试，每次都会需要打开浏览器或关闭浏览器等前置或后置的操作的。

代码：

```python
import pytest


@pytest.fixture(scope="class", autouse=True)
def fixture_open_browser():
    print("打开浏览器")  # 相当于setup
    yield "xiaoming", "123456"
    # 生成器函数中的暂停关键字，作用是当代码运行到yield时，把yield右边的数据作为返回值提供给调用处，把代码执行权交出去。
    print("关闭浏览器")  # 相当于teardown


class TestUser(object): # object是一个基类，python中所有的类都是默认继承于object的。
    def test_01(self, fixture_open_browser):
        print(f"fixture_open_browser={fixture_open_browser}")
        print("注册流程，测试用户是否能注册成功")

    def test_02(self, fixture_open_browser):
        print(f"fixture_open_browser={fixture_open_browser}")
        print("登陆流程，测试用户是否能登陆成功")

```



##### 单独存放fixture代码

我们还可以基于fixture脚手架把代码提前写好，放在在一个pytest能自动识别的conftest.py文件中，这样可以有效避免出现重复的fixture代码。注意：conftest.py的文件名必须固定，而且里面只存放fixture代码，并保证该文件与被测试代码文件在同一目录即可。

conftest.py，代码：

```python
import pytest


@pytest.fixture(scope="class", autouse=True)
def fixture_open_browser():
    print("打开浏览器")  # 相当于setup
    yield "xiaoming", "123456"
    # 生成器函数中的暂停关键字，作用是当代码运行到yield时，把yield右边的数据作为返回值提供给调用处，把代码执行权交出去。
    print("关闭浏览器")  # 相当于teardown

```

5-单独存放fixture代码.py，代码：

```python
class TestUser(object):
    def test_01(self, fixture_open_browser):
        print(f"fixture_open_browser={fixture_open_browser}")
        print("注册流程，测试用户是否能注册成功")

    def test_02(self, fixture_open_browser):
        print(f"fixture_open_browser={fixture_open_browser}")
        print("登陆流程，测试用户是否能登陆成功")
```



#### 第三方常用组件

##### 控制测试用例执行顺序

unittest执行测试用例的默认顺序是根据测试用例方法名的ASCII码排序[0-9A-Za-z]而定的，值越小，越靠前执行。

pytest执行测试用例的默认顺序是根据测试方法的源代码上下顺序来排序的。

而如果在完成接口测试或集成测试时，我们要控制测试用例的执行顺序，可以通过pytest的第三方模块pytest-ordering来实现。

安装

```python
pip install pytest-ordering
```

使用

```python
class TestAdd(object):
    @pytest.mark.run(order=n)  # n表示执行顺序，可以是正负整数。
    def test_测试方法名(self):
        pass
# 执行顺序为优先执行正数排序的方法，接着到没有排序的方法，最后是负数排序的方法。
# 如果多个方法都是正数，则先执行排序值小的，同理如果多个方法都是负数，也是一样先执行排序值小的。
```

pytest-ordering.py组件的使用，代码：

```python
"""
前置步骤，安装插件：
pip install pytest-ordering
"""
import pytest


class TestAdd(object):

    @pytest.mark.run(order=-1)
    def test_01(self):
        print(f"test_01执行了，order=-1")

    @pytest.mark.run(order=-10)
    def test_02(self):
        print(f"test_02执行了，order=-10")

    @pytest.mark.run(order=10)
    def test_03(self):
        print(f"test_03执行了，order=10")

    @pytest.mark.run(order=3)
    def test_04(self):
        print(f"test_04执行了，order=3")

    def test_05(self):
        print(f"test_05执行了，没有指定排序值")

    def test_06(self):
        print(f"test_06执行了，没有指定排序值")

"""
多个方法排序值为正整数的情况：以小为先
test_04
test_03
没有排序值的情况下，源代码中先写的先执行，后写的后执行：先写为先
test_05
test_06
多个方法排序值为负整数的情况：以小为先
test_02
test_01
"""
```

pytest-ordering用于解决测试开发中，UI测试、系统测试、接口测试等多个测试用例有先后流程的场景。

例如，系统测试的购物车流程：

1. 先访问商品详情页
2. 添加商品购物车
3. 点击购物车的结算
4. 填写或选择发货地址
5. 确定支付

注意：pytest-ordering组件如果和参数化fixtrue脚手架一起使用会导致参数解析错误，所以不能一起使用。因此pytest-ordering使用时，如果需要对测试用例实现参数化，则可以使用pytest.mark.parametrize，注意：不能使用ddt。



##### 失败用例重试

针对网络场景或服务端性能不稳定的情况下，进行测试时经常遇到用例运行失败的情况，特别在性能测试方面，此时我们可以让失败用例重试指定次数，以达到测试的更准确的结果。

安装

```python
pip install pytest-rerunfailures -i https://pypi.douban.com/simple/
    
# pip freeze | findstr rerunfailures # windows系统
# pip freeze | grep rerunfailures    # mac OS X 或 linux、Windows10以上
```

使用

```python
安装 pytest-rerunfailures 插件到本地以后，在pytest运行参数中会新增选项：
--reruns n (n为正整数，表示重试n次)
--reruns-delay m (m为正整数，表示重试的间隔时间为m秒)
```

###### 全局失败用例重试

全局失败用例重试.py，代码

```python
import random

def add(x, y):
    return x + y


class TestAdd(object):
    def test_01(self):
        res = add(10, 20)
        assert res is 30

    def test_02(self):
        ret = random.randint(1, 3)
        assert ret % 2 == 0

```

配置文件pytest.ini，代码：

```ini
[pytest]
addopts =--reruns 3 --reruns-delay 2 -s -v
testpaths = ./
python_files = test_*.py
python_classes = Test*
python_functions = test_*

```

###### 局部失败用例重试

局部失败用例重试.py，代码：

```python
import random
import pytest

def add(x, y):
    return x + y


class TestAdd(object):
    def test_01(self):
        res = add(10, 20)
        assert res is 30

    # 只设置当前测试用例方法失败重试
    @pytest.mark.flaky(reruns=3, reruns_delay=2)
    def test_02(self):
        ret = random.randint(1, 3)
        assert ret % 2 == 0
```

注意：

1. **局部重试参数会覆盖全局重试参数**，也就是说，当使用了局部用法，全局用法就失效了。
2. 与pytest.fixture脚手架也会存在参数解释冲突问题，所以使用了失败重试就不要使用pytest.fixture。



##### 并发运行测试用例

当测试用例非常多的时候，一条条按顺序执行测试用例，是很浪费测试时间的。此时如果测试用例之间没有先后运行的依赖关系，可以完全独立运行的情况下，我们也可以并发运行测试用例，让自动化测试用例可以分布式执行，从而大大节省测试时间。pytest-xdist 就可以完成我们上面希望的并发执行测试用例的效果，它是属于进程级别的并发。

安装

```bash
pip install pytest-xdist
```

使用

pytest-xdist安装以后，pytest会新增一个参数-n，可以让我们指定本次运行测试所开启的进程数量。

参数设置如下：

```python
pytest -s -v -n 4  # 使用4个进程运行，也可以改成auto
pytest -s -v -n auto  # 自动检测系统的CPU核数，并根据CPU核算创建对应数量的进程数量
```

pytest.ini，代码：

```ini
[pytest]
addopts =-s -v -n auto
testpaths = ./
python_files = test_*.py
python_classes = Test*
python_functions = test_*
```



代码：

```python
def add(x, y):
    return x + y


class TestAdd(object):
    def test_01(self):
        res = add(10, 20)
        assert res is 30

    def test_02(self):
        res = add("10", "20")
        assert res == "1020"

    def test_03(self):
        res = add("10", "20")
        assert res == "1020"

    def test_04(self):
        res = add("10", "20")
        assert res == "1020"

    def test_05(self):
        res = add("10", "20")
        assert res == "1020"

    def test_06(self):
        res = add("10", "20")
        assert res == "1020"
```



#### 生成HTML格式测试报告[了解下即可]

安装

```python
pip install pytest-html
```

使用

```python
安装插件到本地以后，在pytest运行参数中会新增选项：--html=report.html
```

生成HTML格式测试报告.py，代码

```python
import random
import pytest

def add(x, y):
    return x + y


class TestAdd(object):
    def test_01(self):
        res = add(10, 20)
        assert res is 30

    # 只设置当前测试用例方法失败重试
    @pytest.mark.flaky(reruns=3, reruns_delay=2)
    def test_02(self):
        ret = random.randint(1, 3)
        assert ret % 2 == 0
```

pytest.ini，代码：

```python
[pytest]
addopts =-s -v --html=report.html
testpaths = ./
python_files = test_*.py
python_classes = Test*
python_functions = test_*
```



## Allure

**Allure** 是一款轻量级的开源自动化测试报告生成框架，Java语言开发出来的。它支持绝大部分测试框架，比如 pytest、unittest 等。比起上面那些丑陋的测试报告生成，Allure是最漂亮的，而且还可以配合pytest与Jenkins实现CI持续集成。pytest+Allure+git+pycharm+Jenkins+gitlab/gitee/github= CI持续集成

官方文档：[Allure Framework (qameta.io)](https://docs.qameta.io/allure)

### 安装

#### 安装java环境

Allure的运行起来需要依赖于java环境，此处下载安装jdk1.8环境（Java 8）。

java的jdk1.8下载地址：https://www.java.com/zh-CN/download/

​										https://www.oracle.com/java/technologies/downloads/#java8   #官方下载需要登录账号

​				国内镜像下载 https://repo.huaweicloud.com/java/jdk/8u151-b12/

ubuntu java 安装步骤.  

```bash
cd Downloads/
sudo mkdir /usr/lib/jvm
sudo tar zxvf jdk-8u151-linux-x64.tar.gz -C /usr/lib/jvm
# vim ~/.bashrc 
cat >> ~/.bashrc << EOF
#set oracle jdk environment
export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_151
export JRE_HOME=\${JAVA_HOME}/jre
export CLASSPATH=.:\${JAVA_HOME}/lib:\${JRE_HOME}/lib
export PATH=\${JAVA_HOME}/bin:\$PATH
EOF
source ~/.bashrc
java -version

```



此处我们演示windows下的java环境安装。

鼠标右键点选下载到本地的java的jdk安装包，选择以"管理员身份运行"，窗口如下，勾选窗口左下角的"
更改目标文件夹"，点击"安装"，进入下一步。

![image-20220522145632492](assets/image-20220522145632492.png)

![image-20220522080945371](assets/image-20220522080945371.png)

默认情况下，java的jdk会选择在C盘的"Program Files"目录下安装，如果不想要在此目录安装，则可以点击更改，如果无所谓，则点击"下一步"即可。建议修改“Program Files”之前的路径，后半段保持原样。

![image-20220522081147770](assets/image-20220522081147770.png)

OK，接下来，喝杯茶，等待一会即可。

![image-20220522081302523](assets/image-20220522081302523.png)

效果如下，则没有问题。

![image-20220522081323515](assets/image-20220522081323515.png)

注意：如果是在windows以外的操作系统中安装java环境，则需要单独在终端下配置java环境变量。

#### 安装Allure命令行工具

```bash
# windows10系统打开powershell来安装，不能使用cmd
# 安装Allure可以借助第三方包管理器scoop，scoop用于提供给开发人员安装各种开发软件到windows系统的
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
y
iwr -useb https://gitee.com/RubyKids/scoop-cn/raw/master/install.ps1 | iex
scoop install allure

# # Ubuntu系统使用apt-get包管理器
# sudo apt install -y openjdk-8-jdk
# sudo apt-add-repository ppa:qameta/allure
# sudo apt-get update 
# sudo apt-get install allure

# # Mac OS X系统使用brew包管理器
# brew install openjdk
# brew install allure

---------------------------------------------ubuntu 安装实战
sudo apt install -y openjdk-8-jdk
# (luffycity) kanghua@ubuntu:~/Downloads$ java -version
#openjdk version "1.8.0_342"
#OpenJDK Runtime Environment (build 1.8.0_342-8u342-b07-0ubuntu1~18.04-b07)
#OpenJDK 64-Bit Server VM (build 25.342-b07, mixed mode)

# 安装allure
cd ~/Downloads
wget https://registry.npmjs.org/allure-commandline/-/allure-commandline-2.13.0.tgz
sudo tar zxvf allure-commandline-2.13.0.tgz 
sudo ln -s ~/Downloads/package/bin/allure /usr/bin/allure
ls -lh /usr/bin/allure
# allure --version
# 2.13.0


```

接下来，我们重新打开一个**新的命令行窗口**，输入"allure"，显示如下即表示allure命令行工具安装正确。

![image-20220522081917552](assets/image-20220522081917552.png)

#### 安装pytest-allure集成模块

接下来，只需要安装allure集成到pytest的pytest-allure集成模块即可。

```bash
pip install allure-pytest
```



### 基本使用

生成allure测试结果，结果以json文件格式保存在--alluredir选项指定的目录下。

pytest.ini，代码：

```bash
[pytest]
addopts =-s -v --alluredir=./results
testpaths = ./
python_files = test_*.py
python_classes = Test*
python_functions = test_*
```

基于json报告结果使用浏览器展示allure测试结果报告

```python
allure serve ./results
```

**生成HTML格式文档的测试报告**

HTML格式文档的测试报告也是要基于上面的json文件格式的测试结果才能生成的。

```bash
# 必须先生成json格式的测试报告，才能生成HTML格式的测试报告
allure generate ./results -o ./reports --clean

```

基于json格式的报告生成HTML报告，代码：

```python
import os
import random
import pytest
import shutil

def add(x, y):
    return x + y


class TestAdd(object):
    def test_01(self):
        res = add(10, 20)
        assert res is 30

    # 只设置当前测试用例方法失败重试
    @pytest.mark.flaky(reruns=3, reruns_delay=2)
    def test_02(self):
        ret = random.randint(1, 3)
        assert ret % 2 == 0

    def test_03(self):
        ret = random.randint(1, 3)
        assert ret % 2 == 0

if __name__ == '__main__':
    # 先删除旧的测试报告
    try:
        shutil.rmtree("./results")
        shutil.rmtree("./resports")
    except:
        pass
    # 运行pytest执行测试测试用例，并生成json测试报告
    pytest.main()
    # 基于os.system执行终端名，生成HTML格式文档的测试报告
    os.system("allure generate ./results -o ./reports --clean")
```

注意：生成的报告，只能通过http协议访问，不能直接在硬盘双击点击打开（这种方式是基于本地文件协议file访问文件）。



### 常用方法

| 方法                                                         | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **@allure.testcase(url, name=None)**                         | 设置测试用例的站点访问地址                                   |
| **@allure.issue(url, name=None)**                            | 设置测试用例的站点的缺陷管理地址                             |
| **@allure.feature(*features)**                               | 设置测试用例的模块名称                                       |
| **@allure.severity(severity_level)**                         | 设置测试用例的优先级，allure对测试用例的优先级划分成五个等级（allure.severity_level），值为：<br>CRITICAL（严重缺陷），NORMAL（普通缺陷），MINOR（较小缺陷），TRIVIAL（不重要缺陷），BLOCKER(阻塞缺陷)。 默认值为NORMAL。 |
| **@allure.title(test_title)**                                | 设置测试用例的标题名称                                       |
| @allure.description(test_description)                        | 设置测试用例的详细描述（纯文本）                             |
| **@allure.description_html(test_description_html)**          | 设置测试用例的详细描述（HTML文本）                           |
| **@allure.link(url, link_type=LinkType.LINK, name=None)**    | 设置指定测试用例的缺陷访问地址                               |
| **allure.step(title)**                                       | 设置测试用例执行过程中的步骤信息                             |
| allure.attach(body, name=None, attachment_type=None, extension=None) | 设置测试用例的文本附件信息，allure.attachment_type的常见文本附件类型支持：TEXT，SVG，HTML，JSON，YAML，CSV。<br>添加文本格式：allure.attach("HTML代码", "文件标题", allure.attachment_type.HTML) |
| allure.attach.file(source, name=None, attachment_type=None, extension=None) | 设置测试用例的文件附件信息，支持的类型参考上方使用。<br>allure.attachment_type的常见文本附件类型支持：PNG，GIF，JPG，PDF。添加二进制格式：allure.attach.file("文件路径", "文件名", attachment_type=allure.attachment_type.PNG) |

代码：

```python
import os
import random
import pytest
import shutil
import allure
from allure_commons.types import LinkType


def add(x, y):
    return x + y


@allure.testcase("http://www.luffycity.com", "测试地址站点的首页地址")
@allure.issue("http://www.luffycity.com", "软件缺陷的管理站点的首页地址")
class TestAdd(object):
    @allure.feature("测试用例模块的描述: 购物车模块，用户模块")
    @allure.story("测试用例的分类描述")
    @allure.title("测试用例test_01的标题描述")
    @allure.description("测试用例test_01的详细描述")
    @allure.severity(allure.severity_level.MINOR)  # 较小缺陷等级的用例，如果不设置这个，默认是NORMAL普通缺陷等级的用例
    def test_01(self):
        res = add(10, 20)
        assert res == 30

    @allure.feature("测试用例模块的描述: 购物车模块，用户模块")
    @allure.story("测试用例的分类描述")
    @allure.title("测试用例test_02的标题描述")
    # @allure.description("测试用例test_02的详细描述")    # 纯文本描述
    @allure.description_html("<b style='color: red;'>测试用例test_02的详细描述</b>")  # HTML文本描述
    @allure.severity(allure.severity_level.BLOCKER)  # 阻塞缺陷等级的用例
    @allure.link("http://test.luffycity.com/test_02", link_type=LinkType.LINK, name="测试用例：02")

    # 只设置当前测试用例方法失败重试
    @pytest.mark.flaky(reruns=3, reruns_delay=2)
    def test_02(self):
        # 注意是使用with上下文管理器语句
        with allure.step("步骤1：内容描述"):
            result = 1+1

        with allure.step("步骤2：内容描述"):
            result +=1

        print(f"测试结果是：{result}")
        assert result == 3

    @allure.feature("测试用例模块的描述: 购物车模块，用户模块")
    @allure.story("测试用例的分类2描述")
    @allure.title("测试用例test_03的标题描述")
    @allure.description("测试用例test_03的详细描述")
    @allure.severity(allure.severity_level.CRITICAL)  # 致命缺陷等级的用例
    def test_03(self):
        # 图片附件
        allure.attach.file("./images/demo.jpg", 'demo.jpg', allure.attachment_type.JPG)
        # 文本附件
        allure.attach("""<h1>Test with some complicated html description</h1>
<table style="width:100%">
  <tr>
    <th>Firstname</th>
    <th>Lastname</th>
    <th>Age</th>
  </tr>
  <tr align="center">
    <td>William</td>
    <td>Smith</td>
    <td>50</td>
  </tr>
  <tr align="center">
    <td>Vasya</td>
    <td>Jackson</td>
    <td>94</td>
  </tr>
</table>""", "Test with some complicated html attachment", allure.attachment_type.HTML)

        ret = random.randint(1, 3)
        assert ret % 2 == 0

# __name__ 是一个魔术变量，在当前文本被python解释器作为主程序运行是，值固定就是 "__main__"，
# 如果当前文件作为模块被其他文件导包使用，则__name__的值，则为当前文件名或者其他的自定义名称，总之不是 "__main__"了。
if __name__ == '__main__':
    try:
        # 删除之前的测试结果与测试文件目录内容
        shutil.rmtree("reports")
        shutil.rmtree("results")
    except:
        pass
    pytest.main(["-sv", "main.py", "--alluredir", "./results"])
    # 生成报告html文件
    os.system('allure generate ./results -o ./reports --clean')
    # 基于http协议打开HTML测试报告
    os.system('allure open ./reports')
```

测试运行，使用终端

```bash
python main.py
```

# 接口自动化测试

基于pytest和allure构建接口自动化测试框架构与项目。

## 框架目录结构

我们要构建一个自动化测试框架，就要以项目的概念来对项目中所有的代码文件进行划分目录和文件结构，不同的代码功能不一样，所以我们需要设计一个合理的目录结构，以方便与测试开发团队的其他人员进行测试功能的开发与测试，也方便将来的项目代码维护。

```bash
根目录/
 ├─ config.py    # 项目代码配置文件
 ├─ pytest.ini    # pytest模块配置文件
 ├─ main.py      # 主程序，执行入口
 ├─ api/         # 封装被测试项目的api接口存放目录[用于mock测试、冒烟测试]
 ├─ data/        # 测试数据/测试用例的存放目录
 ├─ results/     # 测试报告结果生成目录
 ├─ reports/     # HTML测试报告生成目录
 ├─ tests/       # 测试用例脚本存放目录
 ├─ libs/         # 第三方工具类的存放目录[开源模块，不是当前项目封装的模块]
 └─ utils/        # 自定义工具类的存放目录[当前项目自己封装的模块]
```

配置文件，config.py，代码：

```python
import pathlib  # 路径操作模块，替代 os.path模块，os.path采用字符串来操作路径，pathlib采用面向对象来操作路径

# 项目目录的主目录路径[字符串路徑]
BASE_DIR_STR = pathlib.Path(__file__).parent.resolve().as_posix()  # 基本操作系统转换路径的分隔符 as_posix
# 項目目录的主目录路径[路径对象]
BASE_DIR = pathlib.Path(BASE_DIR_STR)

# 项目名
WEB_NAME = "路飞自动化接口测试框架"

# 测试自动化项目的运行端口与IP地址
HOST = "127.0.0.1"
PORT = 8088

```

入口文件，main.py，代码：

```python
import pytest
import os
import sys

import config

if __name__ == '__main__':
    os.system(f"rd /s /q results")
    os.system(f"rd /s /q reports")

    # 让python解释器，追加3个项目中的核心目录为导包路径
    sys.path.insert(0, str(config.BASE_DIR / "api"))
    sys.path.insert(0, str(config.BASE_DIR / "tests"))
    sys.path.insert(0, str(config.BASE_DIR / "utils"))

    # 启动pytest框架
    pytest.main()

    # 生成报告html文件
    os.system('allure generate ./results -o ./reports')

    # 基于http协议打开HTML测试报告
    os.system(f'allure open ./reports -h {config.HOST} -p {config.PORT}')

```

在根目录下创建pytest配置文件pytest.ini，内容如下：

```ini
[pytest]
addopts =-s -v --alluredir=./results
testpaths = ./
python_files = test_*.py
python_classes = Test*
python_functions = test_*
```

OK，完成了上面操作以后，我们就可以写一个测试用例来测试下现在我们的基本框架是否能正常运行了。

`tests/users/test_login.py`，代码：

```python
import allure
import config


@allure.epic(config.WEB_NAME)
@allure.feature("用户模块")
@allure.story("登录")
class TestLogin(object):
    @allure.severity(allure.severity_level.CRITICAL)
    def test_username_by_empty(self,):
        allure.dynamic.title("用户名为空，登陆失败")
        allure.dynamic.description("测试用户名为空的登陆结果")
        allure.attach('附件内容', '附件名字')

    def test_password_by_empty(self,):
        allure.dynamic.title("密码为空，登陆失败")
        allure.dynamic.description("测试密码为空的登陆结果")
        allure.attach('附件内容', '附件名字')
```

运行框架，效果：

![image-20220611101450834](assets/image-20220611101450834.png)

当然自动化接口框架的构建开发过程肯定不是一夜之间就能完成的，所以我们需要长期构建，不断完善的准备。所以需要使用git代码版本管理工具把代码推送到git仓库中进行代码版本的管理（在企业中一般我们会使用公司内部构建的gitlab平台来管理内部项目，但现在我们处于学习阶段，所以可以先把代码提交到[gitee码云](https://gitee.com/)上）。

## 代码托管

注意：公司内部的代码不要私自自己往gitee（码云），github去推。

gitee官网地址：https://gitee.com/

### 准备工作

需要提前在当前开发机子上安装git代码版本管理工具。

windows下载地址：https://git-scm.com/



### 创建仓库

![image-20220529061911628](assets/image-20220529061911628.png)

我们是学习，所以我这创建项目库名luffytest。项目库名建议是英文的。

![image-20220529062141957](assets/image-20220529062141957.png)

选择git-flow自定义分支模型。

![image-20220327031446181](assets/image-20220327031446181.png)

所谓的分支，其实就是一个项目的代码的不同流程版本。

![image-20220327035313097](assets/image-20220327035313097.png)

git-flow分支命名规范：

| 分支前缀 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| master   | 生产环境分支，将来可以部署到生产环境（公司的外网服务器）的代码 |
| release  | 预发布环境分支，将来可以部署到预发布环境的代码，也可以是rel  |
| develop  | 开发环境分支，也可以是dev                                    |
| feature  | 新功能，新增业务分支，也可以是feat                           |
| hotfix   | 修复bug问题、漏洞分支，也可以是fix                           |
| test     | 测试相关分支                                                 |

补充说明：

```bash
release/feature/xxx   # 表示待发布分支下的xxx业务功能相关代码
develop/feature/xxx   # 表示开发分支下的xxx业务的新功能代码
develop/test/xxx      # 表示开发分支下的正在测试的xxx业务功能的代码
develop/hotfix/xxx    # 表示开发分支下的修复xxx业务相关功能的bug

# 当然，分支名称并不是固定的，只要能让开发人员一目了然，名字都可以换，所以也可以这样：
release/xxx   # 表示待发布的xxx业务新功能代码
feature/xxx   # 表示正在开发的xxx业务功能代码
test/xxx      # 表示正在测试的xxx业务功能代码
hotfix/user   # 表示正在修复bug的xxx业务功能的代码
```

创建私有空仓库以后的界面：

![image-20220529062535656](assets/image-20220529062535656.png)



#### 免密提交代码

接下来，我们可以使用ssh连接远程的git仓库，需要先在本地电脑下生成ssh秘钥对。

```python
# 例如我的码云账号是 649641514@qq.com，那么该账号生成ssh秘钥对（基于rsa加密算法生成的秘钥对，公钥和私钥）
ssh-keygen -t rsa -C "649641514@qq.com"
```

![image-20220611103038268](assets/image-20220611103038268.png)

复制终端下出现的公钥信息，复制到码云上面。

```bash
# 查看生成的秘钥对中的公钥（私钥id_rsa保存在自己电脑不要乱动，公钥id_rsa.pub需要复制文件内容到码云平台）
cat C:\Users\Administrator/.ssh/id_rsa.pub
# 把公钥进行复制到码云平台上 https://gitee.com/profile/sshkeys
```

![image-20220611103112560](assets/image-20220611103112560.png)

在浏览器打开https://gitee.com/profile/sshkeys，保存公钥。

![image-20220327040326605](assets/image-20220327040326605.png)

切换项目的仓库地址，设置线上仓库

```bash
git config --global user.name "mooluo"
git config --global user.email "649641514@qq.com"

# 在项目根目录下初始化git仓库
cd luffytest/  # 具体的路径根据自己的设置而定
git init

# git remote remove origin # 删除仓库地址，origin可以理解是一个变量，因为当前时一个新仓库，所以不需要执行这段。
git remote add origin git@gitee.com:mooluo_admin/luffytest.git # 新仓库地址，等同于origin= git..../luffycity.git
```

分支管理，git提交代码版本并同步到远程服务器。

```bash
git branch    # 查看分支
# 刚执行git init 初始化时，会没有分支，因此我们需要进行第一次的代码提交。

git add .
git commit -m "feature: 项目初始化"
# 经过上面的命令操作，本地的git就会自动生成一个master分支

# git branch <分支名称>    # 新建分支
# git branch test         # 例如：创建一个test分支

# git checkout <分支名称>  # 切换分支
# git checkout test       # 例如：切换到test分支，检出分支代码

# git branch -d <分支名称>   # 删除分支
# git branch -d test

# git push <远程仓库别名> --delete <分支名称>    # 删除远程服务器分支
# git push origin --delete test  # 例如：删除远程仓库origin中的test

# 推送代码记录到远程服务器的代码仓库
git push origin master # 推送的过程中，如果本地有该分支，但是线上没有这个分支，则git会自动在远程中创建该分支，默认的空仓库是一个分支都没有的。
```

使用`.gitignore`可以在git上传或下载代码时，把一些不必要记录的垃圾文件/目录过滤掉。

注意：必须保证.git目录 和.gitignore在同一级目录下，才能生效。

![image-20220611104441754](assets/image-20220611104441754.png)

.gitignore编写参考地址：https://github.com/github/gitignore

.gitignore文件内容：

```.gitignore
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
.idea/

# vue https://github.com/vuejs/vue/blob/dev/.gitignore
.DS_Store
node_modules
*.log
explorations
TODOs.md
dist/*.gz
dist/*.map
dist/vue.common.min.js
test/e2e/reports
test/e2e/screenshots
coverage
RELEASE_NOTE*.md
dist/*.js
packages/vue-server-renderer/basic.js
packages/vue-server-renderer/build.js
packages/vue-server-renderer/server-plugin.js
packages/vue-server-renderer/client-plugin.js
packages/vue-template-compiler/build.js
.vscode

# luffytest
reports/*
results/*
logs/*
```

记录并保存.gitignore到git中

```bash
git add .
git commit -m "feature: 新建.gitignore忽略文件"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```

git commit 提交版本的描述信息，编写前缀规范：

| 描述前缀  | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| feature:  | 本次提交的代码用于开发新功能，新增业务                       |
| fix:      | 本次提交的代码用于修复bug问题、漏洞                          |
| docs:     | 本次提交的代码用于修改文档，注释等相关                       |
| style:    | 本次提交的代码用于修改代码格式，不影响代码逻辑，常见的代码规范：PEP8，PEP484 |
| refactor: | 本次提交的代码用于项目/代码重构，理论上不影响现有功能(针对代码的重写，改造原来的模块/类/函数/方法) |
| perf:     | 本次提交的代码用于提升性能，代码优化                         |
| test:     | 本次提交的代码用于增加或修改测试用例代码                     |
| deps:     | 本次提交的代码用于升级项目依赖（更新依赖模块）               |

最终，成功提交了代码版本到gitee平台。



## 新增日志功能

针对的项目开发，将来肯定需要把测试框架这个项目保存公司的服务器的，所以如果项目在公司服务器报错了，我们有可能不在场，或者其他同时去运作，那么我们针对当前这个项目在这个运行期间，有没有出现异常，那就需要记录整个项目的运行信息。

config.py，新增如下日志配置代码，代码：

```python
import pathlib  # 路径操作模块，替代 os.path模块，os.path采用字符串来操作路径，pathlib采用面向对象来操作路径

# 项目目录的主目录路径[字符串路徑]
BASE_DIR_STR = pathlib.Path(__file__).parent.resolve().as_posix()  # 基本操作系统转换路径的分隔符 as_posix
# 項目目录的主目录路径[路径对象]
BASE_DIR = pathlib.Path(BASE_DIR_STR)

# 项目名
WEB_NAME = "路飞自动化接口测试框架-master"

# 测试自动化项目的运行端口与IP地址
HOST = "127.0.0.1"
PORT = 8088

"""日志配置"""
LOGGING = {
    "name": "luffytest",  # 日志处理器的名称，一般使用当前项目名作为名称
    "filename": (BASE_DIR / "logs/luffytest.log").as_posix(),  # 日志文件存储路径，注意，一定要在项目根目录下手动创建logs目录
    "charset": "utf-8",  # 日志内容的编码格式
    "backup_count": 31,  # 日志文件的备份数量
    "when": "d",   # 日志文件的创建间隔事件,m 表示每分钟创建1个，h表示每小时创建1个，d表示每天创建1个，m0~m6表示每周星期日~星期六创建1个，midnight表示每日凌晨
}

```

在项目根目录下创建logs目录，并编写日志工具类，utils/logger.py，代码：

```python
import logging
import logging.handlers
import config


class LogHandle(object):
    """日志处理工具类"""

    def __init__(self, name=None, filename=None):
        self.name = config.LOGGING.get("name", "pytest")
        if name:
            self.name = name

        self.filename = config.LOGGING.get("filename", None)
        if filename:
            self.filename = filename

        self.charset = config.LOGGING.get("charset", "utf-8")
        self.log_backup_count = config.LOGGING.get("backup_count", 31)
        self.when = config.LOGGING.get("when", "d")

    def get_logger(self):
        # 创建logger，如果参数name表示日志器对象名，name为空则返回root logger
        logger = logging.getLogger(self.name)
        # 务必设置一个初始化的日志等级
        logger.setLevel(logging.DEBUG)
        # 这里进行判断，如果logger.handlers列表为空则添加，否则多次调用log日志函数会重复添加
        if not logger.handlers:
            # 创建handler
            fh = logging.handlers.TimedRotatingFileHandler(
                filename=self.filename,
                when=self.when,
                backupCount=self.log_backup_count,
                encoding=self.charset
            )
            sh = logging.StreamHandler()

            # 单独设置logger日志等级
            fh.setLevel(logging.INFO)
            # 设置输出日志格式
            simple_formatter = logging.Formatter(
                fmt="{levelname} {name} {module}:{lineno} {message}",
                style="{"
            )
            verbose_formatter = logging.Formatter(
                fmt="{levelname} {asctime} {name} {pathname}:{lineno} {message}",
                datefmt="%Y/%m/%d %H:%M:%S",
                style="{"
            )

            # 为handler指定输出格式
            fh.setFormatter(verbose_formatter)
            sh.setFormatter(simple_formatter)
            # 为logger添加的日志处理器
            logger.addHandler(fh)
            logger.addHandler(sh)

        return logger  # 直接返回logger

if __name__ == '__main__':
    from datetime import datetime

    log = LogHandle()
    log.filename = "../logs/pytest.log"
    logger = log.get_logger()
    logger.debug("日期测试")
    logger.info("普通日志")
    logger.warning("警告日志")
    logger.error("错误日志")
    logger.fatal("致命错误信息")

```

在测试用例中简单使用，`tests/users/test_login.py`，代码：

```python
import allure
from logger import LogHandle


@allure.epic(config.WEB_NAME)
@allure.feature("用户模块")
@allure.story("登录")
class TestLogin(object):
    def test_username_by_empty(self,):
        logger = LogHandle().get_logger()
        logger.debug("debug")
        logger.info("运行日志-info")
        logger.warning("warning")
        logger.error("error")
        logger.critical("critical")

        allure.attach('附件内容', '附件名字')

    def test_login(self,):
        allure.attach('附件内容', '附件名字')
```

提交代码版本，代码：

```bash
git add .
git commit -m "feature: 新增日志功能"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



## 实现接口自定义测试

#### 封装请求工具

接口测试肯定离不开http网络请求，在工作中python开发常用的http网络请求模块有：urllib，requests、httpx与aiohttp。

其中我们作为测试开发，比较常用的就是requests模块了。

Requests 是一个⽤Python编写，基于urllib的开源HTTP网络请求工具第三方库。它⽐python内置的urllib模块使用更加简单⽅便，可以节约我们⼤量的⼯作，完全满⾜HTTP测试需求。

##### requests快速使用

###### 安装

```bash
pip install requests
```

######  GET请求

发送无参数的GET请求

`demo/demo_requests.py`，代码：

```python
import requests

response = requests.get('http://httpbin.org/get')
print(response.content)  # 获取原生内容
print(response.text)   # 获取文本内容
```

发送有参数的GET请求

```python
import requests

params = {
    'name': 'moluo',
    'age': 18
}
response = requests.get("http://httpbin.org/get?sex=1", params=params)
print(response.text)

```



###### 接收数据

接收文本格式数据

```python
import requests
 
params = {
 'name': 'moluo',
 'age': 18
}
response = requests.get("http://httpbin.org/get", params=params)
print(response.text)
```

接受json格式数据

```python
import requests
import json

response = requests.get("http://httpbin.org/get")
# 方式I：
print(json.loads(response.text))
# 方式2：
print(response.json())
```

接受二进制格式数据

```python
import requests

response = requests.get("http://httpbin.org/image/png")
with open("1.png", "wb") as f:
    f.write(response.content)

```



###### POST请求

发送表单数据

```python
import requests

body = {'name': 'moluo', 'age': '22'}
response = requests.post("http://httpbin.org/post", data=body)
print(response.text)

```

发送json数据

```python
import requests

data = {'name': 'moluo', 'age': '22'}
response = requests.post("http://httpbin.org/post", json=data)
print(response.text)

```

文件上传

```python
import requests

# 支持上传一张或多张图片
files = {'avatar': open('1.png', 'rb')}
response = requests.post("http://httpbin.org/post", files=files)
print(response.text)
```



###### 发送请求头

```python
import requests

headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36'
}

response = requests.get("https://www.zhihu.com/explore", headers=headers)
print(response.text)

```



###### 代理IP

```python
import requests
# https://www.beesproxy.com/free
proxies = {
    # "http": "http://112.6.117.135:8085",
    "http": "http://223.68.190.136:9091",
}
req = requests.get('http://icanhazip.com/', proxies=proxies)
print(req.text)

```



###### 会话保持

提取Cookie

```python
import requests

r = requests.get('https://www.baidu.com')
print(r.cookies)
print(r.cookies['BDORZ'])
print(tuple(r.cookies))
```

发送Cookie

```python
import requests

url = 'http://httpbin.org/cookies'
cookies = {'testCookies_1': 'Hello_Python3', 'testCookies_2': 'Hello_Requests'}
# 在Cookie Version 0中规定空格、方括号、圆括号、等于号、逗号、双引号、斜杠、问号、@，冒号，分号等特殊符号都不能作为Cookie的内容。
r = requests.get(url, cookies=cookies)
print(r.json())

```

其他方法

```python
# 现在大部分的公司在开发项目都会会考虑多终端的问题，所以往往项目整体架构都是基于前后端分离的，那么实现前后端的分离的项目，往往服务端就是一个单独基于RestFul API接口的服务端。

import requests
# 只有args查询字符串参数，没有请求体
requests.get('http://httpbin.org/get')
requests.delete('http://httpbin.org/delete')
# 有请求体的
requests.post('http://httpbin.org/post')
requests.put('http://httpbin.org/put')
requests.patch('http://httpbin.org/patch')
```

自动化测试时，大家肯定都是希望自己写的代码越简洁越好，避免代码重复造成维护成本的提升，因此针对工作中常用的http网络请求模块requests，我们就需要在使用前对其进行简单的封装处理了。

`utils/requestor.py`，代码：

```python
import requests
from logger import LogHandle

class Request(object):
    """http请求工具类"""
    def __init__(self):
        # 实例化session管理器，维持会话, 跨请求的时候保存参数
        self.session = requests.session()
        self.logger = LogHandle().get_logger()

    def send(self, method, url, params=None, data=None, json=None, headers=None, **kwargs):
        """
        :param method: http请求方式
        :param url: 请求地址
        :param params: 字典或bytes，作为参数增加到url中
        :param data: data类型传参，字典、字节序列或文件对象，作为Request的内容
        :param json: json传参，作为Request的内容
        :param headers: 请求头，字典
        :param kwargs: 若还有其他的参数，使用可变参数字典形式进行传递
        :return:
        """
        # 对异常进行捕获
        try:
            self.logger.info(f"请求方法：{method}")
            self.logger.info(f"请求地址：{url}")
            self.logger.info(f"请求头：{headers}")
            if params: self.logger.info(f"查询参数：params={params}")
            if data: self.logger.info(f"请求体：data={data}")
            if json: self.logger.info(f"请求体：json={json}")
            if kwargs: self.logger.info(f"额外参数：kwargs={kwargs}")
            response = self.session.request(method, url, params=params, data=data, json=json, headers=headers, **kwargs)
            self.logger.info(f"状态码：{response.status_code}")
            self.logger.info(f"响应头：{response.headers}")
            self.logger.info(f"响应体[纯文本]：{response.text}")
            self.logger.info(f"响应体[二进制]：{response.content}")
            self.logger.info(f"响应体[json]：{response.json()}")
            # 返回响应结果
            return response

        except Exception as e:
            # 异常处理 报错在日志中打印具体信息
            self.logger.error(f"请求失败：{e}")

    def __call__(self, method, url, params=None, data=None, json=None, headers=None, **kwargs):
        """当把一个对象，当成函数来使用，那么就指定执行当前对象的__call__"""
        return self.send(method, url, params=params, data=data, json=json, headers=headers, **kwargs)

if __name__ == '__main__':
    """"基本使用"""
    # 实例化
    request = Request()

    """发送get请求"""
    # # response = request("GET", 'http://httpbin.org/get')
    # response = request(method="GET", url='http://httpbin.org/get')
    # # 打印响应结果
    # print(response.text)


    """发送post请求"""
    # 请求地址
    url = 'http://httpbin.org/post'
    # 请求参数
    json = {"usernam": "moluo", "password": "123456"}
    # 请求头
    headers = {"company": "luffytest"}
    response = request(method="POST", url=url, json=json, headers=headers)
    # 打印响应结果
    print(response.text)

```

提交代码版本，代码：

```bash
git add .
git commit -m "feature: 新增requtsts http网络请求工具类"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



#### 基于flask实现mockserver

在实际项目开发中，经常出现服务端与客户端分离的情况，那么我们在做测试开发时，有可能服务端的功能还没有实现，此时我们可以自己先模拟出服务器返回结果，直接对接口基本功能进行联调测试并编写自动化测试脚本，等服务器上线之后，切换server地址，直接可以简化调试时间，缩短项目测试周期。flask是一个轻量级的python web框架，非常适用于在测试开发中构建模拟api服务器。

##### 安装模块

```bash
pip install flask
pip install pymysql
pip install flask_sqlalchemy
```



##### 项目初始化

`api/__init__.py`，代码：

```python
import config
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

# SQLAlchemy初始化
db = SQLAlchemy()

app = Flask(__name__)

def init_app():
    # 加载配置
    app.config.from_object(config)

    # 加载mysql数据库配置
    db.init_app(app)

    # db创建数据表
    with app.app_context():
        db.create_all()

    return app
```

`config.py`，添加配置信息，代码：

```python
import pathlib  # 路径操作模块，替代 os.path模块，os.path采用字符串来操作路径，pathlib采用面向对象来操作路径

# 项目目录的主目录路径[字符串路徑]
BASE_DIR_STR = pathlib.Path(__file__).parent.resolve().as_posix()  # 基本操作系统转换路径的分隔符 as_posix
# 項目目录的主目录路径[路径对象]
BASE_DIR = pathlib.Path(BASE_DIR_STR)

# 项目名
WEB_NAME = "路飞自动化接口测试框架-master"

# 测试自动化项目的运行端口与IP地址
HOST = "127.0.0.1"
PORT = 8088

"""日志配置"""
LOGGING = {
    "name": "luffytest",  # 日志处理器的名称，一般使用当前项目名作为名称
    "filename": (BASE_DIR / "logs/luffytest.log").as_posix(),  # 日志文件存储路径，注意，一定要在项目根目录下手动创建logs目录
    "charset": "utf-8",  # 日志内容的编码格式
    "backup_count": 31,  # 日志文件的备份数量
    "when": "d",   # 日志文件的创建间隔事件,m 表示每分钟创建1个，h表示每小时创建1个，d表示每天创建1个，m0~m6表示每周星期日~星期六创建1个，midnight表示每日凌晨
}


"""mock server 的服务端配置"""
# 数据库连接
SQLALCHEMY_DATABASE_URI: str = "mysql+pymysql://root:123@127.0.0.1:3306/pytest?charset=utf8mb4"
# 查询时会显示原始SQL语句
SQLALCHEMY_ECHO: bool = True

# 调试模式
DEBUG = True
# 监听端口
API_PORT = 8000
# 监听地址
API_HOST = "0.0.0.0"

```



##### mock接口实现

`api/models.py`，代码：

```python
from datetime import datetime
from werkzeug.security import generate_password_hash, check_password_hash

from . import db


class BaseModel(db.Model):
    """公共模型"""
    __abstract__ = True  # 抽象模型
    id = db.Column(db.Integer, primary_key=True, comment="主键ID")
    name = db.Column(db.String(255), default="", comment="名称/标题")
    is_deleted = db.Column(db.Boolean, default=False, comment="逻辑删除")
    orders = db.Column(db.Integer, default=0, comment="排序")
    status = db.Column(db.Boolean, default=True, comment="状态(是否显示,是否激活)")
    created_time = db.Column(db.DateTime, default=datetime.now, comment="创建时间")
    updated_time = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now, comment="更新时间")

    def __repr__(self):
        return f"<{self.__class__.__name__}: {self.name}>"


class User(BaseModel):
    """用户基本信息表"""
    __tablename__ = "py_user"
    name = db.Column(db.String(255), index=True, comment="用户账户")
    nickname = db.Column(db.String(255), comment="用户昵称")
    _password = db.Column(db.String(255), comment="登录密码")
    intro = db.Column(db.String(500), default="", comment="个性签名")
    avatar = db.Column(db.String(255), default="", comment="头像url地址")
    sex = db.Column(db.SmallInteger, default=0, comment="性别")  # 0表示未设置,保密, 1表示男,2表示女
    email = db.Column(db.String(32), index=True, default="", nullable=False, comment="邮箱地址")
    mobile = db.Column(db.String(32), index=True, nullable=False, comment="手机号码")

    # 存取器
    @property
    def password(self):  # user.password
        return self._password

    @password.setter
    def password(self, rawpwd):  # user.password = '123456'
        """密码加密"""
        self._password = generate_password_hash(rawpwd)

    def check_password(self, rawpwd):
        """验证密码"""
        return check_password_hash(self.password, rawpwd)

```

`api/views.py`，代码：

```python
from flask import request
from sqlalchemy import or_

from . import app
from .models import User,db


@app.route("/user/register", methods=["POST"])
def register():
    """
    用户信息注册
    :return:
    """
    try:
        data = request.json
        # 创建用户数据
        user = User(**data)
        db.session.add(user)
        db.session.commit()
        return {"msg": "注册成功！", "data": {"id":user.id, "name": user.name}}, 200
    except Exception as e:
        return {"msg": "注册失败！", "data": {}}, 400


@app.route("/user/login", methods=["POST"])
def login():
    """
    用户登录
    :return:
    """
    user = User.query.filter(
        or_(
            User.mobile == request.json.get("username"),
            User.name == request.json.get("username"),
            User.email == request.json.get("username")
        )
    ).first()  # 实例化模型

    if not user:
        return {"msg": "登录失败！用户不存在！", "data": {}}, 400

    if not user.check_password(request.json.get("password")):
        return {"msg": "登录失败！密码错误！", "data": {}}, 400

    return {"msg": "登录成功", "data":{"id": user.id, "name": user.name}}, 200

```

进入数据库终端，创建一个数据库.

```sql
create database pytest;
```

项目根目录下，单独创建run.py文件，启动mock server，代码：

```python
import config
from api import init_app

# 注意，务必把模型models的内容以及 views 中的服务端接口引入当前文件，否则flask不识别。
from api import models
from api import views

app = init_app()

if __name__ == '__main__':
    app.run(host=config.API_HOST, port=config.API_PORT)

```



提交代码版本，代码：

```bash
git add .
git commit -m "feature: 基于flask实现mockserver"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



##### 编写测试用例测试mockserver

`tests/users/test_login.py`，代码：

```python
import allure
import config
from logger import LogHandle
from requestor import Request


logger = LogHandle().get_logger()
SERVER_URl = f"http://{config.API_HOST}:{config.API_PORT}"

@allure.epic(config.WEB_NAME)
@allure.feature("用户模块")
@allure.story("登录")
class TestLogin(object):
    @allure.severity(allure.severity_level.CRITICAL)
    def test_username_by_empty(self,):
        allure.dynamic.title("用户名为空，登陆失败")
        allure.dynamic.description("测试用户名为空的登陆结果")

        # 发送请求
        request = Request()
        request("POST", f"{SERVER_URl}/user/login", json={
            "username": "",
            "password": "123456"
        })

    def test_password_by_empty(self,):
        allure.dynamic.title("密码为空，登陆失败")
        allure.dynamic.description("测试密码为空的登陆结果")

        # 发送请求
        request = Request()
        request("POST", f"{SERVER_URl}/user/login", json={
            "username": "xiaoming",
            "password": ""
        })
 
```

提交代码版本，代码：

```bash
git add .
git commit -m "test: 编写测试用例测试mockserver"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



## 基于数据驱动生成用例代码

在实际测试开发中，我们一般使用参数化来自动生成测试用例，前面介绍过常用的有ddt与parametrize。那么在pytest中，因为本身提供了parametrize参数化，所以我们往往会在unittest中采用ddt来实现参数化，而在pytest中采用内置的parametrize即可。

而参数化所需要的测试用例，一般我们也是可以采用json，yaml或Excel文件来存储，如果用例数量太多，还可以改成数据库保存。

### YAML

YAML（递归缩写：YAML Ain't a Markup Language，译作：YAML 不是一种标记语言）是一种可读性高，用来表达数据序列化的数据格式，使用场景与xml、json类似，2001年首次发布，在最初开发YAML语言时YAML的意思其实是："Yet Another Markup Language"（仍是一种标记语言）。后面之所以改了名称，原因是为了强调YAML语言以数据为中心，而不是以标记语言为重点。

#### 语法特点

```bash
1. 大小写敏感
2. 使用缩进表示嵌套层级关系，且缩进不允许使用tab，只允许使用空格缩进（缩进的空格数不重要，只要相同层级的元素左对齐即可）
3. '#' 表示注释
4. '~' 表示 空(None, null)，也可以使用null表示None，但是尽量不要在属性中出现null或者~
5. yaml文件中，属性唯一不能重复，否则报错
6. 文件扩展名为yml或yaml，如：data.yaml 或者 data.yml
```

`test.yaml`，代码：

```python
username: 'xiaoming'
age: 16
```

#### 数据类型

| 类型名称        | 对应python的数据类型               | 描述                                                         |
| --------------- | ---------------------------------- | ------------------------------------------------------------ |
| 纯量（scalars） | 整型、浮点型、布尔型、字符串、None | 单个的、不可再分的值                                         |
| 数组（Array）   | 列表、元祖                         | 一组按次序排列的值，又称为序列（sequence） / 列表（list）    |
| 对象（object）  | 字典                               | 键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） |

##### 纯量

纯量是最基本的，不可再分的值。类似python中的字符串、布尔值、整型、浮点型、None等

```yaml
# 纯量
# 字符串
name: 小明
# 字符串内容太多可以换行，yaml中针对源码中的连续多个空格或换行，只会识别成一个空格
title: 如果内容太长，则可以换行
       换行后，两段字符串会被使用空格拼接
       但注意，缩进左对齐，否则报错
# yaml中的属性声明，建议采用python变量的命名规范
content_type: "*/*"  # 如果字符串内容中出现特殊符号，建议加上引号，否则有时候会报错

# 布尔值 False / True
sex: TRUE  # true,True 都可以

# 浮点型
score: 13.5
point: 6.8523015e+5   # 支持科学计数法，也可以6.8523015E+5

# 整型
age: 13
goods_id: 100_200_300  # 支持千分位

# 日期与时间
date: 2022-10-01
time: 12:30:00
datetime: 2018-02-17T15:02:31+08:00

# 空
data1: null
data2: ~
null: ~  # 避免这种情况，不能使用null作为属性名！
```

##### 数组

一组按次序排列的值，又称为序列（sequence） / 列表（list），类似python的列表。

```yaml
# 数组
# 数组的成员可以是任意的数据类型
# 方式1：使用中括号进行数组声明，中括号可以换行也可以不换行，无需左对齐
arr1: ["A", "B", True, 1, 1.3]  # 最终还是数组，属性名叫tuple，但并不代表他是元组。
arr2: [
  1,
  2,
  3
]

# 方式2：使用-标记成员进行数组声明，数组成员必须缩进左对齐，否则报错，并且-与成员值必须使用空格隔开
arr3:
  - 1
  - 2
  - 3

# 多层数组嵌套[类似python的多维列表]，这里只演示2层，还可以声明更多层嵌套
arr4: [
  [1,2,3,4,5],
  [6,7,8,9,10]
]

arr5:
  -
    - 1.a
    - 1.b
  -
    - 2.a
    - 2.b

```

##### 对象

键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary），类似python中的字典，但比字典灵活。

```yaml
# 对象
# 对象的成员是键值对格式数据，属性与属性之间必须使用英文冒号(:)来映射，同时每一个之间使用英文逗号(,)隔开
# 方式1：使用花括号声明，花括号可以换行，无需左对齐
dict: {name: xiaoming, age: 17}
map: {
  name: xiaohong,
  age: 16,
  sex: false
}

# 方式2：使用缩进键值对成员进行对象声明，对象成员必须缩进左对齐，不对齐则报错
data:
  name: xiaoming
  age: 16

# 多层嵌套对象[类似python的多维字典]
people:
  name: xiaoming
  age: 26
  love:
    - code
    - watching TV
    - shopping
  son:
    name: xiaohui
    age: 3

goods_list:
  -
    name: 立白洗衣粉
    price: 39.90
    num: 3
  -
    name: 黑猫神蚊香液
    price: 56.50
    num: 6
```



#### python操作YAML

安装yaml模块

```bash
pip install pyyaml
```

基本使用

```python
import yaml
"""读取yaml文件的数据"""
# with open("./data.yaml", "r",encoding="utf-8") as f:
#     content = f.read()
#     data = yaml.load(content, Loader=yaml.FullLoader)
#     print(data)
#     print(data["name"])


"""把数据写入yaml文件"""
from datetime import datetime


with open("./data2.yaml", "w", encoding="utf-8") as f:
    # yaml.dump(data, f, Dumper=yaml.SafeDumper) # 没有多字节内容的情况下
    data = {
        "name": "xiaoming",
        "age": 17,
        "datetime": datetime.now(),
        "point": 1.245464E10,
        "goods_list": [
            {"name": "xiaoming","age": 17, "sex": True},
            {"name": "xiaoming","age": 17, "sex": True},
            {"name": "xiaoming","age": 17, "sex": True},
            {"name": "xiaoming","age": 17, "sex": True},
        ],
        "author_list": ["小明", "小白", "小红"],
        "user_info": {"username":"小明", "password": "123456"}
    }
    yaml.dump(data, f, Dumper=yaml.SafeDumper, allow_unicode=True)  # 有多字节内容的情况下，中文就是多字节内容

```



封装yaml工具类，utils/yamler.py，代码：

```python
import yaml
from logger import LogHandle


class Yaml(object):
    """yaml操作工具类"""
    __instance = None

    def __new__(cls, *args, **kwargs):
        if not cls.__instance:
            print("创建Yaml的单例")
            cls.__instance = super(Yaml, cls).__new__(cls, *args, **kwargs)
        return cls.__instance

    def __init__(self):
        self.logger = LogHandle().get_logger()

    def read(self, path):
        """读取yaml文件"""
        with open(path, encoding="utf-8") as f:
            result = f.read()
            if result:
                result = yaml.load(result, Loader=yaml.FullLoader)
            return result

    def write(self, path, data):
        """写入yaml文件"""
        try:
            with open(path, "w", encoding="utf-8") as f:
                yaml.dump(data, f, Dumper=yaml.SafeDumper, allow_unicode=True)
            return True
        except Exception as e:
            self.logger(f"写入数据到yaml文件失败：{e}")
            return False


if __name__ == '__main__':
    ya = Yaml()
    data = ya.read("../demo/yaml_demo/data.yaml")
    print(data, type(data))

```

提交代码版本，代码：

```bash
git add .
git commit -m "feature: 封装yaml工具类"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



#### 基于yaml数据驱动生成测试用例

`data/user_login.yaml`，代码：

```yaml
-
  name: 用户登录-测试用户名与密码为空的情况
  request:
    method: post
    url: /user/login
    json:
      "username": ""
      "password": ""
  assert:
    - code == 400

-
  name: 用户登录-测试密码为空的情况
  request:
    method: post
    url: /user/login
    json:
      "username": "xiaoming"
      "password": ""
  assert:
    - code == 400


-
  name: 用户登录-测试有账号密码但是密码错误的情况
  request:
    method: post
    url: /user/login
    json:
      "username": "xiaoming"
      "password": "1234562222"
  assert:
    - code == 400


-
  name: 用户登录-测试有账号密码单而且正确的情况
  request:
    method: post
    url: /user/login
    json:
      "username": "xiaoming"
      "password": "123456"
  assert:
    - code == 200

```

`utils/assertor.py`，代码：

```python
from logger import LogHandle

logger = LogHandle().get_logger()


def assertor(assert_list, response):
    """断言函数"""
    if type(assert_list) is not list:
        assert_list = [assert_list]

    for expr in assert_list:
        logger.info(f"开始断言：assert {expr}")
        if expr:
            exec(f"assert {expr}", {
                "code": response.status_code,
                "json": response.json(),
                "text": response.text,
                "content": response.content,
                "headers": response.headers,
            })

        logger.info(f"断言通过：assert {expr}")

if __name__ == '__main__':
    # Response就是模拟requests HTTP请求工具的返回结果对象
    class Response(object):
        status_code = 400
        text = "对不起，登陆失败!"
        content = "对不起，登陆失败!"
        headers = []

        @classmethod
        def json(cls):
            return {"id": 1},

    assert_list = [
        "code == 400",
        "'失败'in text",
    ]

    assertor(assert_list, Response())

```



`tests/users/test_login.py`，代码：

```python
import allure
import config
import pytest
from logger import LogHandle
from requestor import Request
from yamler import  Yaml
from assertor import assertor

logger = LogHandle().get_logger()
SERVER_URl = f"http://{config.API_HOST}:{config.API_PORT}"
yaml = Yaml()


@allure.epic(config.WEB_NAME)
@allure.feature("用户模块")
@allure.story("登录")
class TestLogin(object):
    # @allure.severity(allure.severity_level.CRITICAL)
    # def test_username_by_empty(self,):
    #     allure.dynamic.title("用户名为空，登陆失败")
    #     allure.dynamic.description("测试用户名为空的登陆结果")
    #
    #     # 发送请求
    #     request = Request()
    #     request("POST", f"{SERVER_URl}/user/login", json={
    #         "username": "",
    #         "password": "123456"
    #     })
    #
    # def test_password_by_empty(self,):
    #     allure.dynamic.title("密码为空，登陆失败")
    #     allure.dynamic.description("测试密码为空的登陆结果")
    #
    #     # 发送请求
    #     request = Request()
    #     request("POST", f"{SERVER_URl}/user/login", json={
    #         "username": "xiaoming",
    #         "password": ""
    #     })

    @pytest.mark.parametrize("kwargs", yaml.read(config.BASE_DIR / "data/user_login.yaml"))
    def test_login(self, kwargs):
        request = Request()
        allure.dynamic.title(kwargs.get('name'))
        request.logger.info(f"开始请求测试接口：{kwargs.get('name')}")
        data = kwargs.get('request')
        response = request(data.get("method"), f'{SERVER_URl}{data.get("url")}', json=data.get("json"))
        assertor(kwargs.get("assert"), response)

```

提交代码版本，代码：

```bash
git add .
git commit -m "feature: 基于yaml数据驱动生成测试用例"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



### Excel

在测试开发中，如果测试用例数量太多，使用yaml也存在很大的维护成本，此时可以考虑使用Excel或者数据库保存更多的测试用例，python中操作Exeel文件的模块有很多，常用的有：xlrd+xlwt，pyexcel+openpyxl等等。

安装模块

```bash
pip install xlrd
pip install xlwt
```



#### 封装Excel工具类

`utils/excel.py`，代码：

```python
import xlrd, json

class Excel(object):
    """Excel文件操作工具类"""
    def __init__(self, filename):
        self.workbook = xlrd.open_workbook(filename, formatting_info=True)

    def get_sheet_names(self):
        """
        获取当前excel文件所有的工作表的表名
        :return:
        """
        return self.workbook.sheet_names()

    def __get_sheet(self, sheet_index_or_name):
        """
        根据sheet的索引或名称，获取sheet对象
        :param sheet_index_or_name: sheet的索引或名称
        :return:sheet对象
        """
        if isinstance(sheet_index_or_name, int):
            if len(self.workbook.sheet_names()) > sheet_index_or_name:
                return self.workbook.sheet_by_index(sheet_index_or_name)
            else:
                raise Exception("Invalid Sheet Index!")
        elif isinstance(sheet_index_or_name, str):
            if sheet_index_or_name in self.workbook.sheet_names():
                return self.workbook.sheet_by_name(sheet_index_or_name)
            else:
                raise Exception("Invalid Sheet Name!")

    def get_rows_num(self,sheet_index_or_name):
        """
        获取指定工作表的数据总行数
        :param sheet_index_or_name: 工作表名或索引
        :return:
        """
        return self.__get_sheet(sheet_index_or_name).nrows

    def get_cols_num(self,sheet_index_or_name):
        """
        获取指定工作表的数据总列数
        :param sheet_index_or_name: 工作表名或索引
        :return:
        """
        return self.__get_sheet(sheet_index_or_name).ncols

    def get_cell_value(self, sheet_index_or_name, row_index, col_index):
        """
        获取指定工作表的指定位置的数据值
        :param sheet_index_or_name: 工作表名或索引
        :param row_index: 行下标，从0开始
        :param col_index: 列下标，从0开始
        :return:
        """
        sheet = self.__get_sheet(sheet_index_or_name)
        if sheet.nrows and sheet.ncols:
            return sheet.cell_value(row_index, col_index)
        else:
            raise Exception("Index out of range!")

    def get_data(self, sheet_index_or_name, fields, first_line_is_header=True):
        """
        获取工作表的所有数据
        :param sheet_index_or_name: 工作表名或索引
        :param fields: 返回数据的字段名
        :param first_line_is_header: 工作表是否是否表头，也就是非数据
        :return:
        """
        rows = self.get_rows_num(sheet_index_or_name)
        cols = self.get_cols_num(sheet_index_or_name)
        data = []
        for row in range(int(first_line_is_header), rows):
            row_data = {}
            for col in range(cols):
                cell_data = self.get_cell_value(sheet_index_or_name, row, col)
                if type(cell_data) is str and ("{" in cell_data and "}" in cell_data or "[" in cell_data and "]" in cell_data):
                    """判断如果表格中填写的数据是json格式键值对，则采用json模块转换成字典"""
                    cell_data = json.loads(cell_data)
                row_data[fields[col]] = cell_data
            data.append(row_data)

        return data

if __name__ == '__main__':
    xls = Excel("../data/case_user.xls")
    fields = [
        "case_id",
        "module_name",
        "case_name",
        "method",
        "url",
        "headers",
        "params_desc",
        "params",
        "assert_result",
        "real_result",
        "remark",
    ]

    print(xls.get_data(0, fields))

"""
[
    {'case_id': 1.0, 'module_name': '用户模块', 'case_name': '用户登录-测试用户名为空的情况', 'method': 'post', 'url': 'http://127.0.0.1:8000/user/login', 'headers': '', 'params_desc': 'username: 用户名\npassword: 密码', 'params': {'username': '', 'password': '123456'}, 'assert_result': 'code==400', 'real_result': '', 'remark': ''}, 
    {'case_id': 2.0, 'module_name': '用户模块', 'case_name': '用户登录-测试密码为空的情况', 'method': 'post', 'url': 'http://127.0.0.1:8000/user/login', 'headers': '', 'params_desc': 'username: 用户名\npassword: 密码', 'params': {'username': 'xiaoming', 'password': ''}, 'assert_result': 'code==400', 'real_result': '', 'remark': ''}, 
    {'case_id': 3.0, 'module_name': '用户模块', 'case_name': '用户登录-测试账号密码正确的情况', 'method': 'post', 'url': 'http://127.0.0.1:8000/user/login', 'headers': '', 'params_desc': 'username: 用户名\npassword: 密码', 'params': {'username': 'xiaoming', 'password': '123456'}, 'assert_result': 'code==200', 'real_result': '', 'remark': ''}, 
    {'case_id': 4.0, 'module_name': '用户模块', 'case_name': '用户登录-测试使用手机号码登录', 'method': 'post', 'url': 'http://127.0.0.1:8000/user/login', 'headers': '', 'params_desc': 'username: 手机号\npassword: 密码', 'params': {'username': '13312345678', 'password': '123456'}, 'assert_result': 'code==200', 'real_result': '', 'remark': ''}]

"""

```

`config.py`，代码：

```python
import pathlib  # 路径操作模块，替代 os.path模块，os.path采用字符串来操作路径，pathlib采用面向对象来操作路径

# 项目目录的主目录路径[字符串路徑]
BASE_DIR_STR = pathlib.Path(__file__).parent.resolve().as_posix()  # 基本操作系统转换路径的分隔符 as_posix
# 項目目录的主目录路径[路径对象]
BASE_DIR = pathlib.Path(BASE_DIR_STR)

# 项目名
WEB_NAME = "路飞自动化接口测试框架-master"

# 测试自动化项目的运行端口与IP地址
HOST = "127.0.0.1"
PORT = 8088

"""日志配置"""
LOGGING = {
    "name": "luffytest",  # 日志处理器的名称，一般使用当前项目名作为名称
    "filename": (BASE_DIR / "logs/luffytest.log").as_posix(),  # 日志文件存储路径，注意，一定要在项目根目录下手动创建logs目录
    "charset": "utf-8",  # 日志内容的编码格式
    "backup_count": 31,  # 日志文件的备份数量
    "when": "d",   # 日志文件的创建间隔事件,m 表示每分钟创建1个，h表示每小时创建1个，d表示每天创建1个，m0~m6表示每周星期日~星期六创建1个，midnight表示每日凌晨
}


# excel测试用例字段格式
FIELD_LIST = [
    "case_id",        # 用例编号
    "module_name",    # 模块名称
    "case_name",      # 用例名称
    "method",         # 请求方式
    "url",            # 接口地址
    "headers",        # 请求头
    "params_desc",    # 参数说明
    "params",         # 请求参数
    "assert_result",  # 预期结果
    "real_result",    # 实际结果
    "remark",         # 备注
]


"""mock server 的服务端配置"""
# 数据库连接
# SQLALCHEMY_DATABASE_URI: str = "数据库类型://账户:密码@IP地址:端口/数据库名称?charset=utf8mb4"
SQLALCHEMY_DATABASE_URI: str = "mysql+pymysql://root:123@127.0.0.1:3306/pytest?charset=utf8mb4"
# 查询时会显示原始SQL语句
SQLALCHEMY_ECHO: bool = True

# 调试模式
DEBUG = True
# 监听端口
API_PORT = 8000
# 监听地址
API_HOST = "127.0.0.1"

```

提交代码版本，代码：

```bash
git add .
git commit -m "feature: 封装Excel工具类"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



#### 基于excel文件实现数据驱动生成测试用例

`tests/users/user_login.py`，代码：

```python
import allure
import config
import pytest
from logger import LogHandle
from requestor import Request
from yamler import  Yaml
from assertor import assertor
from utils.excel import Excel

logger = LogHandle().get_logger()
SERVER_URl = f"http://{config.API_HOST}:{config.API_PORT}"
yaml = Yaml()


@allure.epic(config.WEB_NAME)
@allure.feature("用户模块")
@allure.story("登录")
class TestLogin(object):
    # @allure.severity(allure.severity_level.CRITICAL)
    # def test_username_by_empty(self,):
    #     allure.dynamic.title("用户名为空，登陆失败")
    #     allure.dynamic.description("测试用户名为空的登陆结果")
    #
    #     # 发送请求
    #     request = Request()
    #     request("POST", f"{SERVER_URl}/user/login", json={
    #         "username": "",
    #         "password": "123456"
    #     })
    #
    # def test_password_by_empty(self,):
    #     allure.dynamic.title("密码为空，登陆失败")
    #     allure.dynamic.description("测试密码为空的登陆结果")
    #
    #     # 发送请求
    #     request = Request()
    #     request("POST", f"{SERVER_URl}/user/login", json={
    #         "username": "xiaoming",
    #         "password": ""
    #     })

    # @pytest.mark.parametrize("kwargs", yaml.read(config.BASE_DIR / "data/user_login.yaml"))
    # def test_login(self, kwargs):
    #     """数据驱动自动化测试-基于yaml生成"""
    #     request = Request()
    #     allure.dynamic.title(kwargs.get('name'))
    #     request.logger.info(f"开始请求测试接口：{kwargs.get('name')}")
    #     data = kwargs.get('request')
    #     response = request(data.get("method"), f'{data.get("url")}', json=data.get("json"))
    #     assertor(kwargs.get("assert"), response)

    @pytest.mark.parametrize("kwargs", Excel(config.BASE_DIR / "data/case_user.xls").get_data(0, config.FIELD_LIST))
    def test_login(self, kwargs):
        """数据驱动自动化测试-基于excel生成"""
        request = Request()
        allure.dynamic.title(kwargs.get('case_name'))
        request.logger.info(f"开始请求测试接口：{kwargs.get('case_name')}")
        if kwargs.get("method").lower() in ["get", "delete"]:
            """发送get或delete"""
            response = request(kwargs.get("method"), f'{kwargs.get("url")}', params=kwargs.get("params"))
        else:
            """发送post，put，patch"""
            response = request(kwargs.get("method"), f'{kwargs.get("url")}', json=kwargs.get("params"))
        assertor(kwargs.get("assert_result"), response)

```

提交代码版本，代码：

```bash
git add .
git commit -m "feature: 基于excel数据驱动生成测试用例"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```



## 认证测试

在用户注册/登陆以后，往往项目会返回登陆状态（jwt,session, cookie）提供给客户端，所以上面我们所实现的mockserver实际上是有问题的。因此接下来我们继续来模拟存在jwt认证鉴权的服务端，并在测试框架中基于conftest.py来实现认证测试的这个流程。

![image-20220611183354232](assets/image-20220611183354232.png)

安装jwt

```bash
pip install flask-jwt-extended
```

`config.py`，代码：

```python

# 秘钥，不管是使用session还是jwt认证，都需要对认证的信息鉴权加密
SECRET_KEY = "ac361a52518d99f4525c1cfe5ba635572190aa6ac52bc8f27ae1b07529feafd0"
```

`api/__init__.py`，代码：

```python
import config
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager

# SQLAlchemy初始化
db = SQLAlchemy()

app = Flask(__name__)

jwt = JWTManager()

def init_app():
    """服务端初始化"""
    # 加载配置
    app.config.from_object(config)
    # 加载mysql数据库配置
    db.init_app(app)

    # jwt初始化
    jwt.init_app(app)

    # 自动创建数据表
    with app.app_context():
        db.create_all()

    return app
```

`api/views.py`，代码：

```python
from flask import request
from sqlalchemy import or_
from flask_jwt_extended import jwt_required, create_access_token

from . import app
from .models import User,db


@app.route("/user/register", methods=["POST"])
def register():
    """
    用户信息注册
    :return:
    """
    try:
        data = request.json
        # 创建用户数据
        user = User(**data)
        db.session.add(user)
        db.session.commit()
        return {"msg": "注册成功！", "data": {"id":user.id, "name": user.name}}, 200
    except Exception as e:
        return {"msg": "注册失败！", "data": {}}, 400


@app.route("/user/login", methods=["POST"])
def login():
    """
    用户登录
    :return:
    """
    user = User.query.filter(
        or_(
            User.mobile == request.json.get("username"),
            User.name == request.json.get("username"),
            User.email == request.json.get("username")
        )
    ).first()  # 实例化模型

    if not user:
        return {"msg": "登录失败！用户不存在！", "data": {}}, 400

    if not user.check_password(request.json.get("password")):
        return {"msg": "登录失败！密码错误！", "data": {}}, 400

    # 生成token，并返回给客户端
    access_token = create_access_token(identity={"id": user.id, "username": user.name})
    return {"msg": "登录成功", "data": {"token": access_token}}, 200


@app.route("/user", methods=["GET"])
@jwt_required()   # 当前这个装饰器的作用就是 校验用户是否登录
def user_center():
    return {"errmsg": "访问成功"}

```

项目根目录下创建`conftest.py`，代码：

```python
import pytest
import config
from utils.requestor import Request
from utils.yamler import Yaml

yaml = Yaml()


@pytest.fixture(scope="class", autouse=False)
def jwt_token():
    request = Request()
    request.logger.info("获取token")
    data = yaml.read(config.BASE_DIR / "data/test_user.yaml")
    response = request(data.get("method"), data.get("url"), json=data.get("json"))
    token = response.json().get("data", {}).get("token")
    yield token
    # 生成器函数中的暂停关键字，作用是当代码运行到yield时，把yield右边的数据作为返回值提供给调用处，把代码执行权交出去。
    request.logger.info("移除token")
```

`data/test_user.yaml`，填写一个保存正确用户信息的用例，方便在conftest中发送正确的账户信息获取token，代码：

```yaml
method: post
url: http://127.0.0.1:8000/user/login
json:
  "username": "xiaoming"
  "password": "123456"
```

新建一个测试用例，`tests/test_user.py`，代码：

```python
import allure
import pytest
import config
from utils.requestor import Request
from utils.yamler import Yaml
from utils.assertor import assertor


yaml = Yaml()


@allure.epic(config.WEB_NAME)
@allure.feature("用户模块")
@allure.story("用户中心")
class TestUser(object):
    @pytest.mark.usefixtures("jwt_token")
    @pytest.mark.parametrize("kwargs", yaml.read(config.BASE_DIR / "data/user_info.yaml"))
    def test_user(self, jwt_token, kwargs):
        allure.dynamic.title(kwargs.get('name'))
        request = Request()
        request.logger.info(f"开始请求测试接口：{kwargs.get('name')}")
        data = kwargs.get('request')
        data['headers']["Authorization"] = data['headers']["Authorization"].format(token=jwt_token)
        response = request(data.get("method"), data.get("url"), headers=data.get("headers"))
        assertor(kwargs.get("assert"), response)

```

`data/user_info.yaml`，代码：

```yaml
-
  name: 用户中心-测试jwt认证鉴权
  request:
    method: get
    url: http://127.0.0.1:8000/user
    headers:
      Authorization: "Bearer {token}"
  assert:
    - code == 200

```

提交代码版本，代码：

```bash
git add .
git commit -m "feature: 基于conftest实现jwt认证鉴权的测试用例"
# 推送代码记录到远程服务器的代码仓库
git push origin master
```

